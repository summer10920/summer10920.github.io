---
title: '[學習之路] JS 前端框架 Angular - HTTP 請求'
categories:
  - Zero Road
  - Angular
tag:
  - Angular
  - JavaScript
date: 2023-03-08 14:37:20
---

![](https://i.imgur.com/WC5iApN.png)
本篇深入探討一些資料流的應用觀念，包含 Observable 提供可觀察的非同步結果、以及 Form 表單的設計要點、pipe 管道的技巧。其中一些內容將會使用到 rxjs 的第三方工具使用。

<!-- more -->

# Http Request 伺服器請求
本節將介紹如何跟後端進行連線作業，透過 API 的方式進行串接。而 API 常見的 Server 連線方式有 REST 或 GraphQL 等，我們將以 REST 方式進行教導，以及搭配免費的虛擬後端做測試，減少開發練習的環境複雜性。
前端的 API 是指用於在網頁應用程式中通過瀏覽器與伺服器進行溝通的程式接口。API 可以是一個單獨的 JavaScript 函數，也可以是一組由伺服器提供的 RESTful API 端點。

## API 基本觀念
前端的 API 通常是用於從伺服器獲取數據，並將其用於呈現網頁上的內容。例如，當用戶在網頁應用程式中進行搜索時，前端的 API 將向伺服器發送請求，以獲取符合搜索條件的結果。伺服器端會處理這個請求，返回符合條件的數據，然後前端的 API 將這些數據轉換為適當的格式，例如 JSON 或 XML，以便在網頁上顯示。

除了從伺服器獲取數據，前端的 API 還可以用於將數據發送到伺服器，例如在使用者提交表單時。這種情況下，前端的 API 會將表單數據轉換為適當的格式，例如 JSON 或表單編碼，然後將其發送到伺服器上的 API 端點進行處理。伺服器端會處理這個請求，然後返回適當的響應，例如成功或錯誤信息。

總的來說，前端的 API 是一個關鍵的技術，它使得網頁應用程式能夠與伺服器進行通信，以獲取數據和處理用戶操作。API 主要是由前端透過 http request 向後端做資料請求，透過後端回應的 http response 取得資料庫資料，再進行資料處理回饋到 DOM 上呈現。

### HTTP Request
HTTP Request 是客戶端向伺服器發送請求的格式，用於請求特定的資源或服務。一個 HTTP Request 包含三部分：

- Request Line：包含請求方法、URL 和協議版本。常用的請求方法有 GET、POST、PUT、DELETE 等。
- Request Headers：包含一系列請求頭部資訊，用於描述請求的內容、格式、身份驗證等資訊，如 User-Agent、Host、Accept、Content-Type 等。
- Request Body：可選的請求體，包含發送到伺服器的資料，例如表單資料、JSON 資料等。

#### Request Line
Request Line（請求行）是 HTTP Request 中的第一部分，用於描述客戶端向伺服器發送的請求方法、URL 和協議版本等基本資訊。Request Line 的格式如下：

```bash
# <Method> <URL> <HTTP Version>
GET /index.html HTTP/1.1
```
- Method 是客戶端使用的請求方法，常見的有 GET、POST、PUT、DELETE 等；
- URL 是客戶端要訪問的資源地址，可以是絕對 URL 或相對 URL；
- HTTP Version 是 HTTP 協議的版本，通常是 HTTP/1.0 或 HTTP/1.1。

而這個 Request Line 例子，請求方法是 GET，URL 是 /index.html，HTTP 協議版本是 HTTP/1.1。當客戶端向伺服器發送這個 Request Line 時，伺服器會根據這些資訊來找到對應的資源並返回相應的內容。

#### Request Headers
Request Headers（請求頭部）是 HTTP Request 中的第二部分，用於描述客戶端向伺服器發送的請求的額外資訊，例如 User-Agent、Accept、Content-Type 等。以下是一個 HTTP Request Headers 的例子：

```bash
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
```

這個 Request Headers 中，包含了 Host、User-Agent、Accept、Accept-Encoding 和 Connection 等頭部資訊。這些頭部資訊可以告訴伺服器一些額外的資訊，例如客戶端使用的瀏覽器類型、網頁編碼格式、支援的資源類型等。

#### Request Body
Request Body（請求主體）是 HTTP Request 中的第三部分，通常用於在客戶端向伺服器發送資料。Request Body 的格式取決於請求的內容類型，例如在發送 JSON 格式的資料時，可以使用 application/json 作為 Content-Type，並在 Request Body 中以 JSON 格式傳遞資料。另外，Request Body 也可以是空的，例如當客戶端向伺服器發送 GET 請求時，通常是不需要 Request Body 的。

```bash
POST /api/data HTTP/1.1
Host: www.example.com
Content-Type: application/json

{
  "name": "John Doe",
  "age": 30,
  "email": "johndoe@example.com"
}
```

這個 HTTP Request 中使用了 POST 方法，Content-Type 是 application/json，Request Body 中包含了一個 JSON 物件。當客戶端向伺服器發送這個請求時，伺服器會根據 URL 和 Request Body 中的資訊，來處理請求並返回相應的結果。

## 環境建置準備
本篇的起始素材放置於 GitHub 底下提供使用，使用資料目錄 lokiSecond 作為初始環境。下載請記得 npm install 初始化環境。

>[Github download](https://github.com/summer10920/angularTraining) at lokiHttp-start Folder

另外，為了練習與後端連線，這裡會借用 Google 提供的 [FireBase](https://firebase.google.com/) 進行後端模擬使用。請先註冊免費會員並根據以下步驟進行準備。

- 登入帳號，並建立專案名稱自訂與完成專案
- 來到專案頁面選擇 Realtime Database 並建立可即時性的資料庫，選擇新加坡網速會稍快些。
- 選擇以測試模式啟動，使得全公開可以任意連線（練習用）。此時可見到 URL 請求網址使用。

![](https://i.imgur.com/vKtPpvD.png)
![](https://i.imgur.com/4yYA2gj.png)
![](https://i.imgur.com/dGOKVkL.png)
![](https://i.imgur.com/vYheBJQ.png)

{% note info %}
**Firebase**
可以用作網站的真實後端。Firebase 提供了一個全面的後端解決方案，包括用戶身份驗證、資料庫、雲端存儲、主機、分析和通知等功能，這些功能可以幫助你快速構建高效可靠的網站。

Firebase 的資料庫功能提供了實時數據庫（Realtime Database）和雲端 FireStore 兩個選項，這些都是 NoSQL 資料庫，可以存儲結構化和非結構化數據。Firebase 還提供了用戶身份驗證，可以通過電子郵件、社交媒體等方式進行註冊和登錄，以及用於管理和保護數據的安全規則。Firebase 的主機功能可以部署和管理網站代碼，而分析和通知功能可以幫助你了解用戶行為和互動並進行即時反饋。

總體而言，Firebase 是一個強大而靈活的後端解決方案，可以滿足大多數網站的需求。
{% endnote%}

## 基本 POST 與 GET
此小節透過基本的 post 方式與 get 方式進行 api 測試，以 REST 之協定觀念上，post 主要用於新增資料，而 get 作為請求資料（可以是全部或是一筆）。
### POST 請求
從素材之中，已規劃好 TD 表單並提供 title 與 content 的表單提交，本節將示範如何透過 API 進行 HTTP Request 進行 POST 發送。首先要進行之前，需進行先掛載 HttpClient 模組。

```typescript app.module.ts
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { HttpClientModule } from '@angular/common/http'; //※重點

import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    FormsModule,
    HttpClientModule //※重點
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

現在就能再 app.component.ts 內進行使用 HttpClient 使用。注意以下要點：

- 於建構子建立本地變數為 http 以及型別為 HttpClient
- 於 submit 處 onCreatePost 進行發送 post 請求，注意這裡的 URL 因 firebase 的 no-SQL 規則要求填寫為 posts.json。這不是標準 TEST 方法，這要取決真實後端的 URL 規定。
- 第二參數為 body，傳送 json 表單資料，以目前的設定簡略，Angular 會自動整理判斷所有 Request 所需要的 Header,Body。包含`Content-Type: application/json`會自動判定。
- Angular 內使用 http 必須要進行 subscribe 才能運作，subscribe 能讓我們接受到 response 回來的資料為何。
- 編寫完嘗試發送出去，觀察 F12>Network 以及 FireBase 後台資料情況。你應該可觀察到 require 與獲得 response。

```ts app.component.ts
import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';//※重點

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {
  loadedPosts = [];

  constructor(
    private http: HttpClient //※重點
  ) { }

  ngOnInit() { }

  onCreatePost(postData: { title: string; content: string }) {
    // Send Http request

    // console.log(postData);

    this.http.post(
      'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json',
      postData
    ).subscribe(response => console.log(response));
  }
  // ...
}
```

後端會回傳一個 name 參數，這是便於之後要找到該資料時所用。

### GET 請求
接著以範例獲取所有資料，透過 GET 方式做請求，此功能規畫於 fetch Button 使用，以及初始化 init 時全部載入。

- 規劃私有函式 fetchPosts，以 get 方式請求所有資料，這裡不需要發送 require 資料。
- 將 fetchPosts 觸發於 init 與 onFetchPosts 事件上。

```typescript app.component.ts
import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {
  loadedPosts = [];

  constructor(
    private http: HttpClient
  ) { }

  ngOnInit() {
    this.fetchPosts();
  }

  //...

  onFetchPosts() {
    // Send Http request
    this.fetchPosts();
  }

  //...

  private fetchPosts() {
    this.http.get(
      'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json'
    ).subscribe(response => console.log(response));
  }
}
```

此時載入畫面以及按下 fetch 按鈕都能透過 http get 取得完整資料。

#### 透過 pipe 轉換 response 數據
由於 API 是非同步的訂閱對象，我們可以使用 rxjs 的 pipe 對資料進行轉換，方便於我們的 response 數據轉成前端所需要的資料格式。

舉例來說，回傳的資料格式為了方便整理成以下：

```json
// before
{
  "-NQ-JEPX3OgPGMQNGBq0": {
    "content": "BB",
    "title": "AA"
  }
}
// after
[
  {
    "content": "BB",
    "title": "AA",
    "id": "-NQ-JEPX3OgPGMQNGBq0"
  }
]
```

因此，於 pipe 管道內，透過 map 試著轉換為陣列方式呈現。

```typescript app.component.ts
private fetchPosts() {
  this.http.get(
    'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json'
  ).pipe( //※重點
    map(responseData => { 
      console.log(responseData);
      const postAry = [];
      for (const key in responseData) {
        if (responseData.hasOwnProperty(key))
          postAry.push({ ...responseData[key], id: key })
      }
      return postAry;
    })
  ).subscribe(response => console.log(response));
}
```

同時，並遵循 TypeScript 試著套入型別。

### Modal 型別規劃
目前為止都能正常運行，為了遵循 TypeScript 應該對這些資料往返加強型別。

- 透過 cli 指令`ng g i post --type=model`或`ng g interface post --type=model`，也可手動建置 post.model.ts

```typescript post.model.ts
export interface Post {
  title: string;
  content: string;
  id?: string;
}
```

# hr
---
# 參考文獻
- [Udemy Angular - The Complete Guide (2023 Edition)](https://www.udemy.com/course/the-complete-guide-to-angular-2/) SESSION 18