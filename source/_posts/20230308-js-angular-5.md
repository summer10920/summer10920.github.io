---
title: '[學習之路] JS 前端框架 Angular - HTTP 請求、身分驗證&路由'
categories:
  - Zero Road
  - Angular
tag:
  - Angular
  - JavaScript
date: 2023-03-08 14:37:20
---

![](https://i.imgur.com/WC5iApN.png)
本篇深入探討一些資料流的應用觀念，包含 Observable 提供可觀察的非同步結果、以及 Form 表單的設計要點、pipe 管道的技巧。其中一些內容將會使用到 rxjs 的第三方工具使用。

<!-- more -->

# Http Request 伺服器請求
本節將介紹如何跟後端進行連線作業，透過 API 的方式進行串接。而 API 常見的 Server 連線方式有 REST 或 GraphQL 等，我們將以 REST 方式進行教導，以及搭配免費的虛擬後端做測試，減少開發練習的環境複雜性。
前端的 API 是指用於在網頁應用程式中通過瀏覽器與伺服器進行溝通的程式接口。API 可以是一個單獨的 JavaScript 函數，也可以是一組由伺服器提供的 RESTful API 端點。

## API 基本觀念
前端的 API 通常是用於從伺服器獲取數據，並將其用於呈現網頁上的內容。例如，當用戶在網頁應用程式中進行搜索時，前端的 API 將向伺服器發送請求，以獲取符合搜索條件的結果。伺服器端會處理這個請求，返回符合條件的數據，然後前端的 API 將這些數據轉換為適當的格式，例如 JSON 或 XML，以便在網頁上顯示。

除了從伺服器獲取數據，前端的 API 還可以用於將數據發送到伺服器，例如在使用者提交表單時。這種情況下，前端的 API 會將表單數據轉換為適當的格式，例如 JSON 或表單編碼，然後將其發送到伺服器上的 API 端點進行處理。伺服器端會處理這個請求，然後返回適當的響應，例如成功或錯誤信息。

總的來說，前端的 API 是一個關鍵的技術，它使得網頁應用程式能夠與伺服器進行通信，以獲取數據和處理用戶操作。API 主要是由前端透過 http request 向後端做資料請求，透過後端回應的 http response 取得資料庫資料，再進行資料處理回饋到 DOM 上呈現。

### HTTP Request
HTTP Request 是客戶端向伺服器發送請求的格式，用於請求特定的資源或服務。一個 HTTP Request 包含三部分：

- Request Line：包含請求方法、URL 和協議版本。常用的請求方法有 GET、POST、PUT、DELETE 等。
- Request Headers：包含一系列請求頭部資訊，用於描述請求的內容、格式、身份驗證等資訊，如 User-Agent、Host、Accept、Content-Type 等。
- Request Body：可選的請求體，包含發送到伺服器的資料，例如表單資料、JSON 資料等。

#### Request Line
Request Line（請求行）是 HTTP Request 中的第一部分，用於描述客戶端向伺服器發送的請求方法、URL 和協議版本等基本資訊。Request Line 的格式如下：

```bash
# <Method> <URL> <HTTP Version>
GET /index.html HTTP/1.1
```
- Method 是客戶端使用的請求方法，常見的有 GET、POST、PUT、DELETE 等；
- URL 是客戶端要訪問的資源地址，可以是絕對 URL 或相對 URL；
- HTTP Version 是 HTTP 協議的版本，通常是 HTTP/1.0 或 HTTP/1.1。

而這個 Request Line 例子，請求方法是 GET，URL 是 /index.html，HTTP 協議版本是 HTTP/1.1。當客戶端向伺服器發送這個 Request Line 時，伺服器會根據這些資訊來找到對應的資源並返回相應的內容。

#### Request Headers
Request Headers（請求頭部）是 HTTP Request 中的第二部分，用於描述客戶端向伺服器發送的請求的額外資訊，例如 User-Agent、Accept、Content-Type 等。以下是一個 HTTP Request Headers 的例子：

```bash
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
```

這個 Request Headers 中，包含了 Host、User-Agent、Accept、Accept-Encoding 和 Connection 等頭部資訊。這些頭部資訊可以告訴伺服器一些額外的資訊，例如客戶端使用的瀏覽器類型、網頁編碼格式、支援的資源類型等。

#### Request Body
Request Body（請求主體）是 HTTP Request 中的第三部分，通常用於在客戶端向伺服器發送資料。Request Body 的格式取決於請求的內容類型，例如在發送 JSON 格式的資料時，可以使用 application/json 作為 Content-Type，並在 Request Body 中以 JSON 格式傳遞資料。另外，Request Body 也可以是空的，例如當客戶端向伺服器發送 GET 請求時，通常是不需要 Request Body 的。

```bash
POST /api/data HTTP/1.1
Host: www.example.com
Content-Type: application/json

{
  "name": "John Doe",
  "age": 30,
  "email": "johndoe@example.com"
}
```

這個 HTTP Request 中使用了 POST 方法，Content-Type 是 application/json，Request Body 中包含了一個 JSON 物件。當客戶端向伺服器發送這個請求時，伺服器會根據 URL 和 Request Body 中的資訊，來處理請求並返回相應的結果。

## 環境建置準備
本篇的起始素材放置於 GitHub 底下提供使用，使用資料目錄 lokiSecond 作為初始環境。下載請記得 npm install 初始化環境。

>[Github download](https://github.com/summer10920/angularTraining) at lokiHttp-start Folder

另外，為了練習與後端連線，這裡會借用 Google 提供的 [FireBase](https://firebase.google.com/) 進行後端模擬使用。請先註冊免費會員並根據以下步驟進行準備。

- 登入帳號，並建立專案名稱自訂與完成專案
- 來到專案頁面選擇 Realtime Database 並建立可即時性的資料庫，選擇新加坡網速會稍快些。
- 選擇以測試模式啟動，使得全公開可以任意連線（練習用）。此時可見到 URL 請求網址使用。

![](https://i.imgur.com/vKtPpvD.png)
![](https://i.imgur.com/4yYA2gj.png)
![](https://i.imgur.com/dGOKVkL.png)
![](https://i.imgur.com/vYheBJQ.png)

{% note info %}
**Firebase**
可以用作網站的真實後端。Firebase 提供了一個全面的後端解決方案，包括用戶身份驗證、資料庫、雲端存儲、主機、分析和通知等功能，這些功能可以幫助你快速構建高效可靠的網站。

Firebase 的資料庫功能提供了實時數據庫（Realtime Database）和雲端 FireStore 兩個選項，這些都是 NoSQL 資料庫，可以存儲結構化和非結構化數據。Firebase 還提供了用戶身份驗證，可以通過電子郵件、社交媒體等方式進行註冊和登錄，以及用於管理和保護數據的安全規則。Firebase 的主機功能可以部署和管理網站代碼，而分析和通知功能可以幫助你了解用戶行為和互動並進行即時反饋。

總體而言，Firebase 是一個強大而靈活的後端解決方案，可以滿足大多數網站的需求。
{% endnote%}

## 基本 POST/GET/DELETE
此小節透過基本的 post 方式與 get 方式進行 api 測試，以 REST 之協定觀念上，post 主要用於新增資料，而 get 作為請求資料（可以是全部或是一筆）。
### POST 請求
從素材之中，已規劃好 TD 表單並提供 title 與 content 的表單提交，本節將示範如何透過 API 進行 HTTP Request 進行 POST 發送。首先要進行之前，需進行先掛載 HttpClient 模組。

```typescript app.module.ts
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { HttpClientModule } from '@angular/common/http'; //※重點

import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    FormsModule,
    HttpClientModule //※重點
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

現在就能再 app.component.ts 內進行使用 HttpClient 使用。注意以下要點：

- 於建構子建立本地變數為 http 以及型別為 HttpClient
- 於 submit 處 onCreatePost 進行發送 post 請求，注意這裡的 URL 因 firebase 的 no-SQL 規則要求填寫為 posts.json。這不是標準 TEST 方法，這要取決真實後端的 URL 規定。
- 第二參數為 body，傳送 json 表單資料，以目前的設定簡略，Angular 會自動整理判斷所有 Request 所需要的 Header,Body。包含`Content-Type: application/json`會自動判定。
- Angular 內使用 http 必須要進行 subscribe 才能運作，subscribe 能讓我們接受到 response 回來的資料為何。
- 編寫完嘗試發送出去，觀察 <kbd>F12</kbd> > Network 以及 FireBase 後台資料情況。你應該可觀察到 require 與獲得 response。

```ts app.component.ts
import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';//※重點

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {
  loadedPosts = [];

  constructor(
    private http: HttpClient //※重點
  ) { }

  ngOnInit() { }

  onCreatePost(postData: { title: string; content: string }) {
    // Send Http request

    // console.log(postData);

    this.http.post(
      'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json',
      postData
    ).subscribe(response => console.log(response));
  }
  // ...
}
```

後端會回傳一個 name 參數，這是便於之後要找到該資料時所用。

### GET 請求
接著以範例獲取所有資料，透過 GET 方式做請求，此功能規畫於 fetch Button 使用，以及初始化 init 時全部載入。

- 規劃私有函式 fetchPosts，以 get 方式請求所有資料，這裡不需要發送 require 資料。
- 將 fetchPosts 觸發於 init 與 onFetchPosts 事件上。

```typescript app.component.ts
import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {
  loadedPosts = [];

  constructor(
    private http: HttpClient
  ) { }

  ngOnInit() {
    this.fetchPosts();
  }

  //...

  onFetchPosts() {
    // Send Http request
    this.fetchPosts();
  }

  //...

  private fetchPosts() {
    this.http.get(
      'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json'
    ).subscribe(response => console.log(response));
  }
}
```

此時載入畫面以及按下 fetch 按鈕都能透過 http get 取得完整資料。

#### 透過 pipe 轉換 response 數據
由於 API 是非同步的訂閱對象，我們可以使用 rxjs 的 pipe 對資料進行轉換，方便於我們的 response 數據轉成前端所需要的資料格式。

舉例來說，回傳的資料格式為了方便整理成以下：

```json
// before
{
  "-NQ-JEPX3OgPGMQNGBq0": {
    "content": "BB",
    "title": "AA"
  }
}
// after
[
  {
    "content": "BB",
    "title": "AA",
    "id": "-NQ-JEPX3OgPGMQNGBq0"
  }
]
```

因此，於 pipe 管道內，透過 map 試著轉換為陣列方式呈現。

```typescript app.component.ts
private fetchPosts() {
  this.http.get(
    'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json'
  ).pipe( //※重點
    map(responseData => { 
      console.log(responseData);
      const postAry = [];
      for (const key in responseData) {
        if (responseData.hasOwnProperty(key))
          postAry.push({ ...responseData[key], id: key })
      }
      return postAry;
    })
  ).subscribe(response => console.log(response));
}
```

同時，並遵循 TypeScript 試著套入型別。

### Modal 型別規劃
目前為止都能正常運行，為了遵循 TypeScript 應該對這些資料的往返進行加強型別。試著在原處 post 與 get 的 api 處理上追加型別。

- 透過 cli 指令`ng g i post --type=model`或`ng g interface post --type=model`，也可手動建置 post.model.ts
- 規劃 response 內所出現的三種字串型別。

```typescript post.model.ts
export interface PostModel {
  title: string;
  content: string;
  id?: string;
}
```

- 造訪 app.component.ts，找到 onCreatePost，原本這裡的型別已宣告成 model，可以抽換為 PostModel。

```typescript app.component.ts
// ...
import { PostModel } from './post.model';
// ...
export class AppComponent implements OnInit {
  // onCreatePost(postData: { title: string; content: string }) {
    onCreatePost(postData: PostModel) { //※重點
    this.http.post(
      'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json',
      postData
    ).subscribe(response => console.log(response));
  }
// ...
}
```

- 同處找到 fetchPosts，map 之後的陣列會是`PostModel[]`型別。
- 而 map 之前的 response 型別，可以規劃為`{ [key: string]: PostModel }`，但不是很優。
- 同上，我們可以使用 TypeScript 的泛型，在 get 處添加`<{ [key: string]: PostModel }>`讓 Angular 知道 get 所回傳的型別為何。

```typescript app.component.ts
private fetchPosts() {
  // this.http.get(
  this.http.get<{ [key: string]: PostModel }>( //※重點：方法二
    'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json'
  ).pipe(
    // map((responseData: { [key: string]: PostModel }) => {  //※重點：方法一
    map(responseData => {
      console.log(responseData);
      const postAry: PostModel[] = []; //※重點
      for (const key in responseData) {
        if (responseData.hasOwnProperty(key))
          postAry.push({ ...responseData[key], id: key })
      }
      return postAry;
    })
  ).subscribe(response => console.log(response));
}
```

### GET 數據顯示畫面上與 Loading 提示
接著將 get 訂閱出來的資料回饋到畫面上，目前已存在一個本地變數為 loadedPosts 試圖回存於此。另外於 html 模板上透過判斷 ngIf 有資料透過迴圈 ngFor 則 list 出來。

```typescript app.component.ts
private fetchPosts() {
  // this.http.get(
  this.http.get<{ [key: string]: PostModel }>(
    'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json'
  ).pipe(
    map(responseData => {
      console.log(responseData);
      const postAry: PostModel[] = [];
      for (const key in responseData) {
        if (responseData.hasOwnProperty(key))
          postAry.push({ ...responseData[key], id: key })
      }
      return postAry;
    })
  ).subscribe(response => this.loadedPosts = response); //※重點
}
```
```html app.component.html
<div class="row">
  <div class="col-xs-12 col-md-6 col-md-offset-3">
    <p *ngIf="loadedPosts.length<1">No posts available!</p>
    <ul
      *ngIf="loadedPosts.length>0"
      class="list-group"
    >
      <li class="list-group-item" *ngFor="let item of loadedPosts">
        <h3>{{item.title}}</h3>
        <p>{{item.content}}</p>
      </li>
    </ul>
  </div>
</div>
```

爾後針對 GET 的 API 作業中，增加一個 loading 訊息作為等待提示，只需多宣告一個本地變數 Boolean，在於 require 之前與 response 之後去改變。以及畫面上根據此 Boolean 做對應的顯示即可。

```typescript app.component.ts
import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { map } from 'rxjs/operators';
import { PostModel } from './post.model';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {
  loadedPosts = [];
  loading = false; //※重點

    // ...

  private fetchPosts() {
    this.loading = true;//※重點
    this.http.get<{ [key: string]: PostModel }>(
      'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json'
    ).pipe(
      map(responseData => {
        console.log(responseData);
        const postAry: PostModel[] = [];
        for (const key in responseData) {
          if (responseData.hasOwnProperty(key))
            postAry.push({ ...responseData[key], id: key })
        }
        return postAry;
      })
    ).subscribe(response => {
      this.loading = false; //※重點
      this.loadedPosts = response;
    });
  }
}
```
```html app.component.html
<div class="row">
  <div class="col-xs-12 col-md-6 col-md-offset-3">
    <p *ngIf="loading">Loading...</p>
    <p *ngIf="loadedPosts.length<1 && !loading">No posts available!</p>
    <ul
      *ngIf="loadedPosts.length>0 && !loading"
      class="list-group"
    >
      <li
        class="list-group-item"
        *ngFor="let item of loadedPosts"
      >
        <h3>{{item.title}}</h3>
        <p>{{item.content}}</p>
      </li>
    </ul>
  </div>
</div>
```

### Service 規劃
目前設計來說都依賴於 app 元件上過於複雜，因此可將這些 HTTP 工作搬移至 Service 服務去，如此你的元件就相對精簡乾淨專注於與模板 HTML 相關工作。

#### 搬移 POST
- 透過 CLI 指令`ng g s http --skip-tests=true`生成 http service
- 規劃 addPost 來處理原本 http post 相同代碼搬入
- 傳遞參數的型別可共用 PostModel，同時我們也需要設定 HttpClient 於建構子內
- 最後修改 component 這裡，改從 Service 這裡處理 http，注意需要設定 httpService 於建構子內

```typescript http.service.ts
import { PostModel } from './post.model';
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class HttpService {

  constructor(
    private http: HttpClient
  ) { }

  addPost(postData: PostModel) {
    this.http.post(
      'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json',
      postData
    ).subscribe(response => console.log(response));
  }
}
```
```typescript
import { HttpService } from './http.service'; //※重點
import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { map } from 'rxjs/operators';
import { PostModel } from './post.model';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {
  loadedPosts = [];
  loading = false; 

  constructor(
    private http: HttpClient,
    private HttpService: HttpService //※重點
  ) { }

  // ...

  onCreatePost(postData: PostModel) {
    this.HttpService.addPost(postData); //※重點
    // this.http.post(
    //   'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json',
    //   postData
    // ).subscribe(response => console.log(response));
  }
  // ...
}
```

#### 搬移 GET
同樣作業搬移 fetchPost 工作部分，與前作業不同的是 GET 所回應的 response 有資料處理需求，而 POST 不需要考慮回應的資料如何處理。因此在 subscribe 部分應由 app 元件做等待，Service 只需處理到 pipe 即可，將整個非同步動作直接 return 給元件做訂閱。而 loading 提示的動作仍由 app 元件處置。

```typescript http.service.ts
fetchPost() {
  return this.http.get<{ [key: string]: PostModel }>(
    'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json'
  ).pipe(
    map(responseData => {
      console.log(responseData);
      const postAry: PostModel[] = [];
      for (const key in responseData) {
        if (responseData.hasOwnProperty(key))
          postAry.push({ ...responseData[key], id: key })
      }
      return postAry;
    })
  );
  // ).subscribe(response => {
  //   this.loading = false; //※重點
  //   this.loadedPosts = response;
  // });
}
```
```typescript app.component.ts
private fetchPosts() {
  this.loading = true;//※重點

  this.HttpService.fetchPost().subscribe(response => {
    this.loading = false; //※重點
    this.loadedPosts = response;
  });
  // this.http.get<{ [key: string]: PostModel }>(
  //   'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json'
  // ).pipe(
  //   map(responseData => {
  //     console.log(responseData);
  //     const postAry: PostModel[] = [];
  //     for (const key in responseData) {
  //       if (responseData.hasOwnProperty(key))
  //         postAry.push({ ...responseData[key], id: key })
  //     }
  //     return postAry;
  //   })
  // ).subscribe(response => {
  //   this.loading = false; //※重點
  //   this.loadedPosts = response;
  // });
}
```

### DELETE 請求
同樣的對 clear Button 進行 HTTP 請求刪除所有資料，這部分依賴 Service 完成並回傳，使 app 元件透過訂閱完成後續動作（例如清空變數資料）。

```typescript http.service.ts
deletePostAll() {
  return this.http.delete(
    'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json'
  );
}
```
```typescript app.component.ts
onClearPosts() {
  // Send Http request
  this.HttpService.deletePostAll().subscribe(() => {
    this.loadedPosts = [];
  });
}
```

隨著操作解析，第一次刪除按鈕會要求後端刪除資料，回應後前也刪除資料。隨事後更新按鈕按下則後端回傳空陣列使前端呈現無資料。

## Error 事件處置
進行 API 串接時，可能根據一些狀況產生非預期的行為進行回報。HttpClient 在發送 HTTP 請求時，如果收到非 2xx 的狀態碼，就會產生錯誤。錯誤對象包含多個屬性，前端可針對這部分做期望的錯誤考量處置。

首先我們先將 Firebase 的 read 權限進行關閉，使得 API 進行 GET 會發生錯誤的拒絕連線問題。來到 Firebase 網頁後台即時資料庫的規則參數，調整 read 為 false 拒絕寫入。

![](https://i.imgur.com/H3h6Rjh.png)

現在任何的 GET 操作都能<kbd>F12</kbd> > network 發現 401 連線錯誤。接下來會介紹三種方式處理 Error 作業，介紹順序以逐漸由高而推薦。

### 訂閱 HttpClient 的 HttpErrorResponse
使用 HttpClient 當發生錯誤時，不會進入正常 Response 環節（也就是原本的 pipe 管道不會觸發進行）。而是會以第二組參數回傳。因此訂閱此 httpClient 結果，能在第二個回傳參數做 Error 工作。唯一的缺點是如果沒有使用訂閱去處理此 API，我們會不知道發生什麼事。

若要將錯誤資訊顯示於畫面上，可規劃一個本地變數 errorMsg 為 null，當訂閱於發生錯誤時將錯誤資訊存於此。模板根據邏輯判斷是否有內容則顯示畫面上。

```typescript app.component.ts
export class AppComponent implements OnInit {
  // ...
  errorResponse = null; //※重點
  // ...
  private fetchPosts() {
    this.loading = true;
  
    // 寫法一：
    // this.HttpService.fetchPost().subscribe(response => {
    //   this.loading = false;
    //   this.loadedPosts = response;
    // }, err => { //※重點，於第二組參數做 HttpErrorResponse
    //   this.loading = false; //※重點：發生錯誤也代表 loading 結束才對
    //   console.log(err); // ※重點：可觀察看看 HttpErrorResponse 夾帶那些 Spec. 屬性值被使用
    //   this.errorResponse = err;
    // });

    // 寫法二：
    this.HttpService.fetchPost().subscribe({
      next: response => {
        this.loading = false;
        this.loadedPosts = response;
      },
      error: err => {
        this.loading = false;
        console.log(err);
        this.errorResponse = err;
      }
    });
  }
}
```
```html app.component.html
<div class="row">
  <div class="col-xs-12 col-md-6 col-md-offset-3">
    <p *ngIf="loading && !errorResponse">Loading...</p> <!--無錯誤時-->
    <div class="alert alert-danger" *ngIf="errorResponse"> <!--有錯誤時-->
      <strong>Opps! - {{errorResponse.error.error}}</strong> <!--根據 API Error Spec. 狀況而使用 -->
      <p>{{errorResponse.message}}</p> <!--根據 API Error Spec. 狀況而使用 -->
    </div>
    <p *ngIf="loadedPosts.length<1 && !loading">No posts available!</p>
    <ul
      *ngIf="loadedPosts.length>0 && !loading"
      class="list-group"
    >
      <li
        class="list-group-item"
        *ngFor="let item of loadedPosts"
      >
        <h3>{{item.title}}</h3>
        <p>{{item.content}}</p>
        <button
          class="btn btn-danger"
          (click)="errorResponse=null"
        >Close</button><!--可關閉訊息，消除 errorResponse-->
      </li>
    </ul>
  </div>
</div>
```

### 用 Subject 觀察 subscribe
如前面提到，當沒有訂閱者去追蹤 API 的後續我們無法探知問題回報。如我們的 addPost 作業，subscribe 是寫在 service 內，而 app 元件不會得知問題出現。針對這問題可以考慮用 subject 來處理看看。

- 於 Service 內建立一個 Subject，並於 post 的 errorResponse 內使該 Subject 受到變化
- 要求初始化生命階段 ngOnInit 下，對該 service 的 Subject 的訂閱結果做 errMsg 的處理。
- 為了銷毀這個訂閱之效能，於 component 建立一個型別為 Subscription 的變數，使得 ngOnDestroy 階段能找到此訂閱消除之。

```typescript http.service.ts
export class HttpService {
  errSubject = new Subject<string>(); //※重點
  // ...
  addPost(postData: PostModel) {
    this.http.post(
      'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json',
      postData
    ).subscribe(
      response => console.log(response),
      err => this.errSubject.next(err) //※重點
    );
  }
  // ...
}
```
```typescript app.component.ts
import { HttpService } from './http.service';
import { Component, OnDestroy, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { PostModel } from './post.model';
import { Subscription } from 'rxjs';//※重點

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit, OnDestroy {
  loadedPosts = [];
  loading = false; 
  errorResponse = null;
  private errSubject: Subscription;//※重點

  constructor(
    private http: HttpClient,
    private HttpService: HttpService
  ) { }

  ngOnInit() {
    this.errSubject = this.HttpService.errSubject.subscribe(errMsg => {//※重點
      this.errorResponse = errMsg;
      console.log(errMsg);
    });
    this.fetchPosts();
  }

  ngOnDestroy() {
    this.errSubject.unsubscribe();//※重點
  }

  //...
}
```

回到 Firebase 階段，可以把 write 也關閉為 false，使得寫入 POST 失敗。觀察是否新增資料時也呈現於畫面上（回應訊息會跟 Fetch 失敗一樣）。

### 用 rxjs 的 catchError 處理
如果希望在 service 階段尚針對 error 做處理，可以利用 rxjs 的 catchError 於 pipe 管道內進行特別處理後。使得訂閱者可以獲得經處理過的 error 資訊。這裡額外多利用 throwError 做錯誤代表的 Observable 再回傳給前面提到的 HttpErrorResponse 或 Subject。

```typescript http.service.ts
import { catchError, map } from 'rxjs/operators';
import { Subject, throwError } from 'rxjs';
// ...

export class HttpService {
  // ...
  fetchPost() {
    return this.http.get<{ [key: string]: PostModel }>(
      'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json'
    ).pipe(
      map(responseData => {
        console.log(responseData);
        const postAry: PostModel[] = [];
        for (const key in responseData) {
          if (responseData.hasOwnProperty(key))
            postAry.push({ ...responseData[key], id: key })
        }
        return postAry;
      }),
      catchError(errorRes => { //※重點：catchError 可以處理發生錯誤時的處理
        return throwError(errorRes); //※重點：產生錯誤的 Observable 並回傳給訂閱者
      })
    );
  }
  // ...
}
```

## HttpClient 的相關設置
用於指定 Http 請求的配置選項。它可以包括請求的 URL、Http 的 method（GET、POST、PUT、DELETE 等等）、HttpHeaders、URLSearchParams、request body 等等。可以透過在 Angular 中注入 HttpClient，並使用該物件的 get()、post()、put()、delete() 等方法來發出 Http 請求。在這些方法中，可以傳遞一個選項對象。

### HttpHeaders 設定 Header 資訊
在使用 Angular 的 HttpClient 進行 HTTP 請求時，可以透過 HttpHeaders 類別設定 HTTP 請求的 headers，這可以讓我們在發送請求時，提供一些必要的信息，例如認證信息、內容類型等等。HttpHeaders 是不可變對象，需要使用 set 方法來添加或更改單個頭，或使用 append 方法來添加一個或多個頭。可以使用 HttpHeaders 的多種方法來創建或轉換頭。

- 於 get 或 post 的下一個參數提供 httpOptions 相關資訊。其中重點為 headers 的值
- 使用 `new HttpHeaders()` 來建立 Headers 所需套入的各屬性

```typescript http.service.ts
import { HttpClient, HttpHeaders } from '@angular/common/http';

// ...
export class HttpService {
  // ...
  fetchPost() {
    return this.http.get<{ [key: string]: PostModel }>(
      'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json',
      {
        headers: new HttpHeaders({ //※重點
          CustomHeader: 'Loki Jiang',
          Authorization: 'my-auth-token'
        })
      }
    ).pipe(
      map(responseData => {
        console.log(responseData);
        const postAry: PostModel[] = [];
        for (const key in responseData) {
          if (responseData.hasOwnProperty(key))
            postAry.push({ ...responseData[key], id: key })
        }
        return postAry;
      }),
      catchError(errorRes => throwError(errorRes))
    );
  }
  // ...
}
```

觀察經過 Fetch Button 動作的 <kbd>F12</kbd> > network > Headers > Request Headers 內是否多了兩個自訂屬性。

{% note info %}
**HttpHeaders 物件是不可變的**
一但創建了一個 headers 物件就不能再修改了。如果需要在現有的 headers 基礎上添加新的 headers，可以改使用 append() 方式插入，舉例如下：

```typescript http.service.ts
 fetchPost() {
    let myHeaders = new HttpHeaders(); // 空的
    myHeaders = myHeaders.append('CustomHeader', 'Loki Jiang'); // 插入
    myHeaders = myHeaders.append('Authorization', 'my-auth-token'); // 插入
 
    return this.http.get<{ [key: string]: PostModel }>(
      'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json',
      {
        headers: myHeaders,
        // headers: new HttpHeaders({
        //   CustomHeader: 'Loki Jiang',
        //   Authorization: 'my-auth-token'
        // }),
      }
    ).pipe(
      map(responseData => {
        console.log(responseData);
        const postAry: PostModel[] = [];
        for (const key in responseData) {
          if (responseData.hasOwnProperty(key))
            postAry.push({ ...responseData[key], id: key })
        }
        return postAry;
      }),
      catchError(errorRes => throwError(errorRes))
    );
  }
```
{% endnote%}

### HttpParams 設定 Query Params
除了可以直接於 URL 上面填寫 Query 參數（例如`.../posts.json?print=pretty`)，也能在 httpClient 內透過 HttpParams 指定，寫法與前面 HttpHeaders 雷同。

```typescript http.service.ts
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';

// ...
export class HttpService {
  // ...
  fetchPost() {
    let myHeaders = new HttpHeaders();
    myHeaders = myHeaders.append('CustomHeader', 'Loki Jiang');
    myHeaders = myHeaders.append('Authorization', 'my-auth-token');

    let myParams = new HttpParams();
    myParams = myParams.append('print', 'pretty');
    myParams = myParams.append('todo', 'add');

    return this.http.get<{ [key: string]: PostModel }>(
      'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json',
      {
        headers: myHeaders,
        // headers: new HttpHeaders({
        //   CustomHeader: 'Loki Jiang',
        //   Authorization: 'my-auth-token'
        // }),
        params: myParams
        // params: new HttpParams().set('article', '3')
      }
    ).pipe(
      map(responseData => {
        console.log(responseData);
        const postAry: PostModel[] = [];
        for (const key in responseData) {
          if (responseData.hasOwnProperty(key))
            postAry.push({ ...responseData[key], id: key })
        }
        return postAry;
      }),
      catchError(errorRes => throwError(errorRes))
    );
  }
  // ...
}
```
觀察經過 Fetch Button 動作的 <kbd>F12</kbd> > network > General > Request URL 內是否多了兩個 Query 屬性。

>`?print=pretty`剛始是 Firebase 的 Query 參數功能，可以將 response 格式美化，可以嘗試到 Firebase 後台將 read 功能 true 查看效果。

### observe 觀察 response
observe 參數是指要觀察的 response 型別，可選值包括 body、response、events。若設為 body，則 HttpClient 會嘗試將 response body 轉換為指定的 response 型別，如 JSON 或文字等。若設為 response，則 HttpClient 會將整個 response 回傳，包含 headers、status code 等資訊。若設為 events，則 HttpClient 會回傳一個事件流（Observable），可用於監聽 request 的進度及狀態。通常預設值是 "body"。

未指定的情況下只會回傳 response 數據，若要檢查 HttpResponse  完整資訊，可這樣做（以 addPost 為示範）:

```typescript
addPost(postData: PostModel) {
  this.http.post(
    'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json',
    postData,
    {
      observe: 'response' //※重點：觀察完整的 HttpResponse 
    }
  ).subscribe(
    response => console.log(response),
    err => this.errSubject.next(err)
  );
}
```
觀察經過 Send Button 動作的 <kbd>F12</kbd> > console.log 能呈現所有 HttpResponse 資訊，涵蓋了 body,headers,status... 等等。

若要觀察 API 的 event 事件處理，舉例來說當進行 deletePostAll 時，會有 api 的送出與返回兩個事件。可以透過`observe: 'events'`來觀察並做對應處理。其中 event 底下 type 能代表目前是 Send（數字 0),Response（數字 4)... 等等事件類別。我們可利用 angular 的`HttpEventType`做判斷。以下根據刪除 API 作判別處理 SEND 與 RESPONSE 的處置。

```typescript http.service.ts
import { HttpClient, HttpEventType, HttpHeaders, HttpParams } from '@angular/common/http';
// ...
export class HttpService {
  // ...
  deletePostAll() {
    return this.http.delete(
      'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json',
      {
        observe: 'events'
      }
    ).pipe(
      tap(event => {
        if (event.type === HttpEventType.) console.log('刪除提交中');
        if (event.type === HttpEventType.Response) console.log('刪除已回應');
        console.log(event);
      })
    );
  }
}
```

>RxJS 的 tap 操作符用於監視 Observable 的值，並在它們被發出時執行一些操作，而不影響流中的元素。它是一種副作用操作符，因為它不會修改流中的元素，但是可以對 Observable 中的值執行副作用操作，例如打印日誌、修改變數等等。
需要注意的是，tap 操作符不會改變流中的元素，而是返回一個與源 Observable 相同的 Observable。因此，在 tap 操作符後面可以接其他操作符，例如 map、filter、reduce 等等。

### responseType 指定回應型別
預設為 json 型別，我們也能指定回傳的 response 該用怎樣的型別回傳。除非你有需要可以抽換成'text'而不是預設的'json'，此範例不會特別改成其他避免 json 處理失敗。

```typescript http.service.ts
deletePostAll() {
  return this.http.delete(
    'https://loki-angular-training-default-rtdb.asia-southeast1.firebasedatabase.app/posts.json',
    {
      observe: 'events',
      responseType: 'text'
    }
  ).pipe(
    tap(event => {
      if (event.type === HttpEventType.Sent) console.log('刪除提交中');
      if (event.type === HttpEventType.Response) console.log('刪除已回應');
      console.log(event);
    })
  );
}
```

## HttpInterceptor 攔截處理
HttpInterceptor 是 Angular 中一個重要的功能，可以在發送請求和接收響應的過程中對它們進行攔截和處理。通常情況下，HttpInterceptor 被用來實現以下幾個功能：

- 設置 Http 請求的 headers，如授權信息，token 等等。
- 在發送 Http 請求前進行簡單的日誌記錄。
- 在響應返回之前對其進行處理和轉換，例如：添加 response header，篩選和修改返回的數據等等。

通過實現 HttpInterceptor，我們可以將這些重複的代碼抽取出來，使代碼更加清晰簡潔，而且還可以很方便地對 Http 請求和響應進行統一處理。

- 透過 cli 指令`ng g s auth-interceptor --skip-tests=true`建立 service 為 auth-interceptor.service.ts
- 對 class AuthInterceptorService 進行介面定義取自 HttpInterceptor，這部分可從 angular http 取得 import。

### intercept 實作方法
intercept 是 HttpInterceptor 介面中必須實作的方法之一，它用來攔截 HTTP 請求，並且可以對請求進行變更、增加欄位、設定 headers 等等。intercept 方法的輸入參數是 HttpRequest 和 HttpHandler。當 intercept 方法被呼叫時，會把當前的 HttpRequest 對象傳入這個方法，並傳入一個 HttpHandler 對象。HttpHandler 對象可以用來發送 HTTP 請求。

在 intercept 方法中，可以先對 HttpRequest 對象進行變更、增加欄位、設定 headers 等等。然後，再使用 HttpHandler 對象的 handle 方法來發送經過修改後的請求。

最後，handle 方法返回一個 `Observable<HttpEvent<any>>`。這個 Observable 可以被訂閱，以獲取由後端返回的數據。如果不訂閱這個 Observable，那麼這個請求就不會被發送出去。

- 接著編寫 intercept 於 AuthInterceptorService 內。
- 下列代碼範例中，我們嘗試攔截 request 並調整為含有 Headers 的新 authReq，以及 response 回應的部分動作。

```typescript auth-interceptor.service.ts
import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from '@angular/common/http';
// import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

// 不宣告於此，稍晚定義於 app.modules.ts 內
// @Injectable({
//   providedIn: 'root'
// })

export class AuthInterceptorService implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    console.log('API 攔截處理中');

    // 在請求被發送前執行一些前置處理，例如加入 token 到 headers 中
    const authReq = req.clone({
      headers: req.headers.set('Authorization', 'Loki insert by intercept!!')
    });
    //這裡用 set 修改，也可以使用 append 插入新的 headers 其他屬性資訊

    // 攔截並繼續執行請求，處理後續的響應
    return next.handle(authReq).pipe(
      tap(
        event => console.log('HttpResponse', event),
        error => console.log('HttpErrorResponse', error)
      )
    );
  }
  // constructor() { }
}
```

### 註冊 Interceptor 於 app.modules.ts
要註冊 Interceptor 於 AppModule 中，需先在 providers 陣列中加入對應的 Interceptor 服務，並使用 { provide, useClass } 的方式告訴 Angular 要提供哪個服務以及使用哪個 Interceptor 類別。透過提供 HTTP_INTERCEPTORS 令牌，將 Interceptor 加入 providers 陣列中。

在下面的範例中，我們提供了 HTTP_INTERCEPTORS 令牌，設定其值為 AuthInterceptorService 此服務，並將 multi 設為 true。multi 的設定代表我們可能會有多個 Interceptor，所以需要設為 true，讓 Angular 知道有多個 Interceptor，可以和其他的 Interceptor 一起運作。

```typescript app.module.ts
import { AuthInterceptorService } from './auth-interceptor.service'; //※重點
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http'; //※重點
import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    FormsModule,
    HttpClientModule
  ],
  providers: [{ //※重點
    provide: HTTP_INTERCEPTORS,
    useClass: AuthInterceptorService,
    multi: true
  }],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

#### 註冊多個 Interceptor
這裡多規劃一個新的 Interceptor 服務，試圖註冊兩組 Interceptor 到 app.module.ts

- 透過 cli 指令`ng g s login-interceptor --skip-tests=true`建立 service 為 login-interceptor.service.ts
- 調整與前例雷同的代碼環境。包含`implements HttpInterceptor`與`intercept()`

```typescript login-interceptor.service.ts
import { HttpInterceptor, HttpEventType, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

export class LoginInterceptorService implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    console.log('Login 攔截處理中');
    console.log(req.url);

    return next.handle(req).pipe(
      tap(
        event => {
          if (event.type === HttpEventType.Response) console.log('Login is Response');
        }
      )
    );
  }
}
```

回到 app.module.ts，只需要第二組 intercept 添加在 providers 陣列內即可。

> 注意陣列順序前後，所有的 api 會先依序套入前一個開始依序做攔截處理。

```typescript app.module.ts
import { LoginInterceptorService } from './login-interceptor.service';
import { AuthInterceptorService } from './auth-interceptor.service';
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';

import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    FormsModule,
    HttpClientModule
  ],
  providers: [
    {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptorService,
      multi: true
    },
    {
      provide: HTTP_INTERCEPTORS,
      useClass: LoginInterceptorService,
      multi: true
    }
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

# 身分驗證與路由防護
---
# 參考文獻
- [Udemy Angular - The Complete Guide (2023 Edition)](https://www.udemy.com/course/the-complete-guide-to-angular-2/) SESSION 18, 20