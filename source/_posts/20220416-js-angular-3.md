---
title: '[學習之路] JS 前端框架 Angular - 服務與依賴注入'
categories:
  - Zero Road
  - Web Fronted
tag:
  - Angular
  - JavaScript
date: 2022-04-16 22:57:44
---

![](https://i.imgur.com/WC5iApN.png)

<!-- more -->

服務是一個廣義的概念，它包括應用所需的任何值、函式或特性。狹義的服務是一個明確定義了用途的類別。它應該做一些具體的事，並做好。Angular 把元件和服務區分開，以提高模組性和複用性。 透過把元件中和檢視有關的功能與其它型別的處理分離開，你可以讓元件類別更加精簡、高效。

# Service 服務
來討論服務的作用，假設一個應用程式擁有以下組織並提供一些方法：

- AppComponent
  - AboutComponent (Method:log data to console)
  - UserComponent (Method:store user data)
    - UserDetailComponent (Method:log data to console)

有兩個 (Method: 能將 data 輸出到 console.log) 的用途很相近幾乎相同，然後另一個 (Method: 儲存用戶資訊）在 User 原件上雖然只有單獨，也許之後這個單獨 Method 之後可能也會出現在其他元件內重複使用。

服務就是將這些 Method 獨立起來成為應用程式的另一部分，使用服務可以將你重複使用的代碼集中起來並可添加到任何元件類別底下做成依賴注入。因此我們可以產生一個 log 用的服務以及儲存用戶資料的服務。

## 示範與前置準備
本篇的起始素材放置於 GitHub 底下提供使用，使用資料目錄 lokiService 作為初始環境。下載請記得 npm install 初始化環境。

>[Github download](https://github.com/summer10920/angularTraining) at lokiService-start Folder

素材內可看到
- 有三個元件，app 根元件、新增用戶元件、用戶紀錄元件。
- 且用戶紀錄元件能按鈕控制切換狀態輸出到 console.log 並被儲存起來（字串插植），也許這可以做為服務做為代碼集中。
- app 元件將整個東西整合在一起。對 new-account 元件進行`@Output`自訂事件綁定，對 account 元件進行`@input/@Output`屬性與自訂事件綁定。
- 由 app 元件提供 account[] 陣列資料，提供迴圈重複 account 元件使用
- account 透過按鈕觸發更改狀態並透過自訂事件通知 app 元件做資料更改。
- new-account 透過按鈕觸發除了 console.log 資訊也透過自訂事件通知 app 元件做資料新增。

## 建立 log 用的服務
我們要建立出一個服務做為 ts 檔案，可手動到 app 目錄下新增一個`logging.serve.ts`並編寫以下內容：

```ts logging.service.ts
export class LoggingService {

}
```
>或者透過 CLI 指令 `ng g service logging` 或 `ng g s logging`來自動生成。

如果你選擇手動新增此檔案，你可能以為我們創建了元件，以為下一步是對本 ts 檔案宣告`@Component`資訊，以及還要到 add.module.ts 填寫 declarations。事實上不用做這些事，因為 service 不是元件他只是一個 typescript 腳本代碼，目前這些就已經叫做 service。

我們在該 service 內新增一個 Method 能幫助我們進行 console.log。console.log 格式可參考 new-account 的 ts。

```ts logging.service.ts
export class LoggingService {
  // constructor() { } //用不到

  logState(status: string) {
    console.log('A server status changed, new status: ' + status);
  }
}
```

接下來我們要將服務放入到有需要的元件內使用，這裡會示範手動方式（不推薦）與 Angular 提供的依賴注入（推薦）來實施。

### 手動將服務實體化 （不推薦）
接下來我們要剛做好的服務，放回到素材內可以服務來取代的相同代碼。透過 new 實體化來載入服務（記得宣告來源）。

```ts new.account.component.ts
import { Component, EventEmitter, Output } from '@angular/core';
import { LoggingService } from './../logging.service'; //※重點，我們要宣告服務來源

@Component({
  selector: 'app-new-account',
  templateUrl: './new-account.component.html',
  styleUrls: ['./new-account.component.css']
})
export class NewAccountComponent {
  @Output() accountAdded = new EventEmitter<{ name: string, status: string }>();

  onCreateAccount(accountName: string, accountStatus: string) {
    this.accountAdded.emit({
      name: accountName,
      status: accountStatus
    });
    const service = new LoggingService(); //透過 new 得到剛剛的服務 object 並實體化
    service.logState(accountStatus); //使用這個服務底下的函式方法
    
    // console.log('A server status changed, new status: ' + accountStatus);
  }
}
```

### Hierarchical Injector 依賴注入
是指這個元件類別所需要依賴的東西為何，例如目前我們的 new-account 將依賴我們的 loggingService。透過依賴注入把 loggingService 注入到 new-account。由 angular 來幫我們處理在 new-account 內引用 loggingService 做實體化。作法如下：

- 首先我們需要在 angular 對這個元件實體化時，在建構函式內提供該私有參數使得元件內能使用到這個方法（注意強型別來自於 LoggingService)。
- 接著要告知這個元件所依賴的提供者為何，在`@Component`內宣告 providers 並使用陣列。
- 現在你能在元件類別內去直接使用這個方法，因為 Angular 已經幫你實體化到這個元件內。
- 最後測試一下是否與前一節的動作獲得相同的 console.log 預期結果。

```ts new-account.component.ts
import { Component, EventEmitter, Output } from '@angular/core';
import { LoggingService } from './../logging.service'; //※重點，我們要宣告服務來源

@Component({
  selector: 'app-new-account',
  templateUrl: './new-account.component.html',
  styleUrls: ['./new-account.component.css'],
  providers:[LoggingService] //※重點：配置所依賴的提供者為何
})
export class NewAccountComponent {
  @Output() accountAdded = new EventEmitter<{ name: string, status: string }>();

  constructor(private theLoggingService: LoggingService) { }
  /*
  ※重點：
  在建構函式內定義此物件做為參數，是讓 Angular 當對元件進行實體化時，在建構階段上能夠加載到這個參數
  才能提供我們類別內的後續進行使用
  */

  onCreateAccount(accountName: string, accountStatus: string) {
    this.accountAdded.emit({
      name: accountName,
      status: accountStatus
    });

    // console.log('A server status changed, new status: ' + accountStatus);
    this.theLoggingService.logState(accountStatus); //※重點：透過依賴注入所獲得方法來執行
  }
}
```

將同樣的方法應用在另一個相同需要相同的服務，並透過依賴注入的方式放入到 account 元件內。

```ts account.component.ts
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { LoggingService } from './../logging.service'; //※重點

@Component({
  selector: 'app-account',
  templateUrl: './account.component.html',
  styleUrls: ['./account.component.css'],
  providers: [LoggingService] //※重點
})
export class AccountComponent {
  @Input() account!: { name: string; status: string; };
  @Input() id!: number;
  @Output() statusChanged = new EventEmitter<{ id: number, newStatus: string }>();

  constructor(private theLoggingState: LoggingService) { } //※重點

  onSetTo(status: string) {
    this.statusChanged.emit({ id: this.id, newStatus: status });
    // console.log('A server status changed, new status: ' + status);
    this.theLoggingState.logState(status); //※重點
  }
}
```

目前為止，我們將相同的 log 輸出代碼集中成一個服務做成外包，另外利用依賴注入的方式提供給所需要的元件們，且是由 Angular 來幫助我們在元件內實體化這些方法（服務內的方法）。簡化大量重複的代碼。

## 建立儲存資料的服務
這一節我們將原本在 app 元件負責進行資料新增修改的代碼，也打包給服務。
- 先建立 accounts 服務，這裡會存放我們用戶資料以及新增修改方法 （參考 app 元件做外包）。
- 然而 app 本身負責要將用戶資料集中站，會需要提供自己的陣列給 account 元件跑迴圈，所以我們要透過依賴注入，先初始空陣列之後在生命週期的 OnInit 階段從服務那裡取得用戶資料覆蓋此本地的用戶陣列資料。

```ts accounts.services.ts
export class AccountsService {
  accounts = [
    {
      name: 'Master Account',
      status: 'active'
    },
    {
      name: 'Test Account',
      status: 'inactive'
    },
    {
      name: 'Hidden Account',
      status: 'unknown'
    }
  ];

  AccountAdd(newAccount: { name: string, status: string }) {
    this.accounts.push(newAccount);
  }

  //原本 App 那裏的參數是物件資料，這裡簡化成兩個參數做提供，其實觀念都一樣
  StatusChange(id: number, newStatus: string) {
    this.accounts[id].status = newStatus;
  }
}
```
```ts app.component.ts
import { AccountsService } from './accounts.service';
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
  providers: [AccountsService]
})
export class AppComponent implements OnInit {
  accounts: { name: string, status: string }[] = [];

  constructor(private accountsService: AccountsService) { }

  ngOnInit() {
    this.accounts = this.accountsService.accounts;
  }
}
```

此時畫面報錯，找不到 App 元件內的 onAccountAdded() 與 onStatusChanged()，因為我們把這些也都外包給服務了。因此換個角度來說這些子元件現在應該是向服務直接做資料新增修改，不用再`@Output`給 App 元件了。

- 將 app 元件與 new-account 元件的`@Output`與自訂事件綁定給取消，讓 new-account 自己跟服務做新增。
- 對 new-account 進行依賴注入、注意 import、providers、constructor private
- 取消原本 new account 的自訂事件，直接對服務的方法進行新增

```html app.component.html
<!-- <app-new-account (accountAdded)="AccountAdd($event)"></app-new-account> -->
<app-new-account></app-new-account>
```
```ts new-account.component.ts
import { LoggingService } from './../logging.service';
import { AccountsService } from './../accounts.service'; //※重點，我們要宣告服務 AccountsService 來源
import { Component, EventEmitter, Output } from '@angular/core';

@Component({
  selector: 'app-new-account',
  templateUrl: './new-account.component.html',
  styleUrls: ['./new-account.component.css'],
  providers: [LoggingService, AccountsService] //※重點：配置所依賴的提供者 AccountsService
})
export class NewAccountComponent {
  //※重點 - 原本配自訂事件是為了@Output 給 App，現在透過服務所以就不需要了
  // @Output() accountAdded = new EventEmitter<{ name: string, status: string }>();

  constructor(
    private theLoggingService: LoggingService,
    private accountsService: AccountsService // ※重點
  ) { }

  onCreateAccount(accountName: string, accountStatus: string) {

    //※重點 - 原本配自訂事件是為了@Output 給 App，現在透過服務所以就不需要了
    // this.accountAdded.emit({
    //   name: accountName,
    //   status: accountStatus
    // });

    //※重點 - 直接將資料提供給服務內的方法做新增作業
    this.accountsService.AccountAdd({ name: accountName, status: accountStatus });

    // console.log('A server status changed, new status: ' + accountStatus);
    this.theLoggingService.logState(accountStatus);
  }
}
```

現在剩下 app 元件與 account 元件的通信也要取消。都由服務來直接操作。

- 將 app 元件與 account 元件的`@Output`與自訂事件綁定給取消，讓 account 自己跟服務做修改。
- 對 account 進行依賴注入、注意 import、providers、constructor private
- 取消原本 account 的自訂事件，直接對服務的方法進行修改

```html app.component.html
<!-- <app-account
  *ngFor="let acc of accounts; let i = index"
  [account]="acc"
  [id]="i"
  (statusChanged)="onStatusChanged($event)"
></app-account> -->
<app-account
  *ngFor="let acc of accounts; let i = index"
  [account]="acc"
  [id]="i"
></app-account>
```
```ts account.component.ts
import { LoggingService } from './../logging.service';
import { AccountsService } from './../accounts.service';  //※重點
import { Component, EventEmitter, Input, Output } from '@angular/core';

@Component({
  selector: 'app-account',
  templateUrl: './account.component.html',
  styleUrls: ['./account.component.css'],
  providers: [LoggingService, AccountsService] //※重點
})
export class AccountComponent {
  @Input() account!: { name: string; status: string; };
  @Input() id!: number;
  // @Output() statusChanged = new EventEmitter<{ id: number, newStatus: string }>();

  constructor(
    private theLoggingState: LoggingService,
    private accountsService: AccountsService //※重點
  ) { }

  onSetTo(status: string) {
    // this.statusChanged.emit({ id: this.id, newStatus: status });
    this.accountsService.StatusChange(this.id, status);

    // console.log('A server status changed, new status: ' + status);
    this.theLoggingState.logState(status); //※重點
  }
}
```

目前沒有報錯了且 console 部分看似很正常，只剩下 View 的部分沒有準確更新似乎有問題。這是因為在服務的使用邏輯上出了些問題。

### 非相同實體化的服務解決
依賴注入是一種具備分層級的用途，各自層級進行建立允許有單獨的依賴注入。如果沒有特別宣告提供者則會根據樹狀層級單向往下應用。

目前來說我們對三個元件（一個上層兩個下層）都進行一樣的依賴注入，都是要求提供者為何才進行建立。因此每當 Angular 針對我們的需求會從 service 那裏獲得實體化物件，目前來說這三個元件的服務都是獨立的實體化彼此不是相同記憶體所在處的值。自然而然都是各自的資料獨立存取。（而前一節 log 服務來說沒有發現因為只是 console.log)

因此如果需要透過服務來對資料存取，勢必需要讓 Angular 由上層 app 元件來告知一組提供者，而下層元件就依賴上層元件的實體化物件即可，使得三者元件都是修改自同一個記憶體位置。

作法很簡單，只需要取消下層元件的提供者資料即可，這樣會去爬上層的提供者對象。

```ts account.component.ts * new-account.component.ts
// providers: [LoggingService, AccountsService]
providers: [LoggingService] //※重點：下層不要寫，這會吃到上層的提供者
```

## 將服務注入到另一個服務
回頭想一下整個 app 的服務邏輯，new-account 會去執行 accounts 服務做新增，也會去執行 logging 服務做 console。account 也是一樣做修改與 console 共兩個服務。如果這兩個小元件只需要對 account 服務就好，由 account 服務去帶動 logging 服務工作更好。

我們可以把 logging 服務注入到 account 服務內，使得所有的元件只需要吃到 account 服務，除了能使用 account 本身的服務，也能使用 logging 服務。

在這之前還有一招可介紹，我們能將服務的樹狀拉到最高，最高不是 app 元件而是整個應用程式。發現 app.module 內也有提供者可以填寫。

```ts app.module.ts
import { AccountsService } from './accounts.service'; //※重要
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';

import { AppComponent } from './app.component';
import { AccountComponent } from './account/account.component';
import { NewAccountComponent } from './new-account/new-account.component';

@NgModule({
  declarations: [
    AppComponent,
    AccountComponent,
    NewAccountComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
  ],
  providers: [AccountsService], //※重要
  bootstrap: [AppComponent]
})
export class AppModule { }
```
```ts app.component.ts
import { AccountsService } from './accounts.service';
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
  // providers: [AccountsService] 
  //我們只是取消提供者而已，改由上層的應用程式來負責
})
export class AppComponent implements OnInit {
  accounts: { name: string, status: string }[] = [];

  constructor(private accountsService: AccountsService) { }

  ngOnInit() {
    this.accounts = this.accountsService.accounts;
  }
}
```
如此一來依賴注入會將同一個服務往下延伸到所有元件給予實體化使用相同服務。現在整份文件都有 account 服務，接著就能將 logging 服務放到 account 服務內，因此勢必的 app 模組也是需要提供者將 logging 寫入（我們不會再對元件填寫提供者 logging 服務）。之後回到 account 與 new-account 元件，將原本的提供者取消。

```ts app.module.ts
import { LoggingService } from './logging.service';//※重要
import { AccountsService } from './accounts.service';

// ...

@NgModule({
  declarations: [
    AppComponent,
    AccountComponent,
    NewAccountComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
  ],
  providers: [AccountsService, LoggingService], //※重要
  bootstrap: [AppComponent]
})
export class AppModule { }
```
```ts new-account.component.ts & account.component.ts
// providers: [LoggingService]
```

接著我們不會透過 account 與 new-account 元件來執行 logging 服務了，而是用 account 服務來執行 logging 服務。因此取消這兩個原本對服務的動作。

```ts new-account.component.ts & account.component.ts
// this.theLoggingService.logState(accountStatus); 
    //※重點 取消該元件要對服務做的事，到時候由 account 服務來做
```

現在需要由 account 服務來執行 logging 服務內的方法，因為是 Class 寫法我們也是需要利用 constructor 的參數來實體化 logging。接著整合到原本 addAccount() 與 updateStatus() 內去做 log 工作。 

```ts accounts.service.ts
import { LoggingService } from './logging.service'; //※重要
export class AccountsService {
  accounts = [
    {
      name: 'Master Account',
      status: 'active'
    },
    {
      name: 'Test Account',
      status: 'inactive'
    },
    {
      name: 'Hidden Account',
      status: 'unknown'
    }
  ];

  constructor(private loggingService: LoggingService) { }

  AccountAdd(newAccount: { name: string, status: string }) {
    this.accounts.push(newAccount);
    this.loggingService.logState(newAccount.status);
  }

  StatusChange(id: number, newStatus: string) {
    this.accounts[id].status = newStatus;
    this.loggingService.logState(newStatus);
  }
}
```

此時又獲得一個錯誤資訊。

{% cq %}
The class 'AccountsService' cannot be created via dependency injection, as it does not have an Angular decorator. This will result in an error at runtime.
Either add the @Injectable() decorator to 'AccountsService', or configure a different provider (such as a provider with 'useFactory').
(-992005)
---
“AccountsService”不能通過依賴注入創建，因為它沒有 Angular 裝飾器。這將導致運行時出錯。
將 @Injectable() 裝飾器添加到“AccountsService”，或配置不同的提供者（例如具有“useFactory”的提供者）。
{% endcq %}

原因是我們的 accounts 服務內沒有`@Component{}`這樣的元資料 (MetaData)，因此 Angular 無法像元件那樣知道如何處理、實體化和使用。但這又不是元件不應該這樣寫。因此我們需要透過`@Injectable()`寫在類別之前，告知 Angular 關於這個類別是可注入的。

換言之，如果你需要在某服務內注入一些東西，就需要在該類別添加前綴符號`@Injectable`。

```ts accounts.service.ts
import { Injectable } from '@angular/core';//※重要
import { LoggingService } from './logging.service'; 

@Injectable() export class AccountsService {
  //...
}
```

> 過去看到的`@Component()`其實是 export class 的前墜符號。

## 利用服務進行跨元件通信
目前知道，透過服務我們不再需要依賴`@Input/@Output`來依賴父元件通信，而是各自元件透過服務來進行資料處理。換言之兩個兄弟元件可透過服務來通信。簡單舉例如下

- 對 accounts 服務增加一個自訂事件之屬性，而整份 app 都能同樣吃到這個自訂事件
```ts accounts.service.ts
mport { Injectable, EventEmitter } from '@angular/core';//※重要
import { LoggingService } from './logging.service'; 

@Injectable() export class AccountsService {
  accounts = [
    {
      name: 'Master Account',
      status: 'active'
    },
    {
      name: 'Test Account',
      status: 'inactive'
    },
    {
      name: 'Hidden Account',
      status: 'unknown'
    }
  ];
  statusAlert=new EventEmitter<string>();//添加一個自訂事件的屬性

  constructor(private loggingService: LoggingService) { }

  AccountAdd(newAccount: { name: string, status: string }) {
    this.accounts.push(newAccount);
    this.loggingService.logState(newAccount.status);
  }

  StatusChange(id: number, newStatus: string) {
    this.accounts[id].status = newStatus;
    this.loggingService.logState(newStatus);
  }
}
```
- 來到 new-account 元件，我們利用建構函式執行當下，去對服務內的自訂事件 subscribe 註冊此實例發出事件的處理器。
```ts new-account.component.ts
export class NewAccountComponent {
  constructor(
    private theLoggingService: LoggingService,
    private accountsService: AccountsService
  ) {
     // ※重點 - 這裡會在建構實體化時會執行一次
    accountsService.statusAlert.subscribe(
      (status: string) => alert('the status is ' + status)
    );
  }

  onCreateAccount(accountName: string, accountStatus: string) {
    this.accountsService.AccountAdd({ name: accountName, status: accountStatus });
  }
}
```
- 來到 account 元件，我們利用建構函式執行當下，去對服務內的自訂事件 emit 發出包含給定值的事件。

```ts
onSetTo(status: string) {
  this.accountsService.StatusChange(this.id, status);
  
  //※重點 發射執行之結果
  this.accountsService.statusAlert.emit(status);

}
```

這樣的範例中，我們沒有使用到屬性綁定或事件綁定，單純透過相同服務進行通信。

> 自訂事件 EventEmitter [詳閱 Angular.tw](https://angular.tw/api/core/EventEmitter)

## 小節練習
待補 - 
<!-- https://www.udemy.com/course/the-complete-guide-to-angular-2/learn/lecture/12982448#content -->

# Routing 路由
路由是指在同一頁面下不會重新請求伺服器網頁載入，直接替換 DOM 模擬出新的大版面內容以及更換 URL，你感覺好像有重新連結網頁但事實上你的連線沒有重新加載。

## 示範與前置準備
本篇的起始素材放置於 GitHub 底下提供使用，使用資料目錄 lokiRouting 作為初始環境。下載請記得 npm install 初始化環境。

>[Github download](https://github.com/summer10920/angularTraining) at lokiRouting-start Folder

素材內可看到：
- 一開始的 app 內有主要元件為 users, servers, home，且各自有自己的子元件先不討論這部份。
- 目前希望從上面的 nav-bar 透過點選連結來動態加載這三個，一次只顯示一個元件而不是像這樣看到三個。

首先我們需要將這些超連結的位置被記錄起來，來到最外面的 app.module.ts 

- 進行設定一變數並指定型別為 Routes（來自 Angular/router)，因為是複數且陣列所以路由指向可以很多項。位置最好提早於 ngModel
- 在自訂變數內設定你的 URL 路徑之字串，以及對應的元件名稱，不用添加`/`而空字串為一開始首頁。
- 接著來到 imports 這裡要求載入 RouterModule（來自 Angular/router)，在利用 forRoot() 告知 Angular 我們的路徑設定檔

```ts app.module.ts
import { RouterModule, Routes } from '@angular/router'; //※重點

const lokiRoutes: Routes = [ //※重點
  { path: '', component: HomeComponent },
  { path: 'users', component: UsersComponent },
  { path: 'servers', component: ServersComponent }
];

@NgModule({
  declarations: [
    AppComponent,
    HomeComponent,
    UsersComponent,
    ServersComponent,
    UserComponent,
    EditServerComponent,
    ServerComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    RouterModule.forRoot(lokiRoutes)  //※重點
  ],
  providers: [ServersService],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

目前 Angular 已經知道我們路由要求變化，但需要告知路由的動態載入要規劃至範本的何處以及提供有效連結給 nav-bar。
- 來到 app 元件的 html 調整原本的元件模板取消，使用 router-outlet 來插入。
- 在接著來到 nav-bar 的範本這裡，試著將以下超連結對應綁到三個 a:link。

```html app.component.html
<div class="container">
  <div class="row">
    <div class="col">
      <ul class="nav nav-tabs">
        <li class="nav-item">
          <a class="nav-link active" aria-current="page" href="/">Home</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/servers">Servers</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/users">Users</a>
      </ul>
    </div>
  </div>
  <hr>
  <div class="row">
    <div class="col">
      <router-outlet></router-outlet>
      <!-- <app-home></app-home>
    </div>
  </div>
  <div class="row">
    <div class="col">
      <app-users></app-users>
    </div>
  </div>
  <div class="row">
    <div class="col">
      <app-servers></app-servers> -->
    </div>
  </div>
</div>
```

然而實際操作下，你並不是真正的透過路由進行動態 DOM 抽換，而是還是每次透過連結請求網址來進行加載。

## 觸發路由動作
觸發的方式可以從範本上的屬性綁定呼叫 Route 指令來執行。或者從 TypeScript 內去執行 Route 指令。

### 從 Template
因此需要改一下前面的範本的連結設定讓 Angular 知道這是要內部路由模擬處理。將原本的 href 屬性抽換成 routerLink 屬性。

```html app.component.html
<ul class="nav nav-tabs">
  <li class="nav-item">
    <a class="nav-link active" routerLink="/">Home</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" routerLink="/servers">Servers</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" [routerLink]="['/users']">Users</a>
</ul>
```

現在網址不會加載，檢查 F12 可發現 DOM 自行做切頁的效果。
- touterLink 本身是一個屬性綁定，`routerLink="/users"`等價於`[routerLink]="['/users']"`。比較特別這裡的指定值是陣列。
- routerLink 所填寫的值為相對路徑且觀念一致，寫法根據文件所在地以及 index 頁面有關。
- 可利用 routerLinkActive 屬性幫我們針對運作中的元件添加指定樣式 class，我們使用 Bootstrap 規則的 active 來做美化。

```html app.component.html
<ul class="nav nav-tabs">
  <li class="nav-item">
    <a class="nav-link" routerLinkActive="active" routerLink="/">Home</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" routerLinkActive="active" routerLink="/servers">Servers</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" routerLinkActive="active" routerLink="/users">Users</a>
</ul>
```

Home 的 active 經操作檢查下持續保持這因為預設關係，Home 的路由位置在`/server`與`/users`的同本源路徑。如果你希望這個 home 這個唯獨不要這樣效果，可以透過選項的屬性綁定把活動項目對象為固定。

```html app.component.html
<a
  class="nav-link"
  routerLinkActive="active"
  routerLink="/"
  [routerLinkActiveOptions]="{exact:true}"
>Home</a>
```

現在 home 只會在自己的網址上反應，不會對其他對象有作用。

### 從 TypeScript
我們也可以從 TypeScript 對路由下指令，先弄素材放置到 Home 元件，透過事件綁定要求 TypeScript 來執行路由指令。

```html home.component.html
<button class="btn btn-primary" (click)="loadServers()">load Servers</button>
```

來到 typeScript 部份，作業如下：
- 規劃私有 Router 屬性，來自於 Router 這個模組。
- 方法執行當下透過 navigate() 能幫助我們對路由下達指令切頁，你可以在那之前做一些代碼工作才切頁。

```ts home.component.ts
import { Router } from '@angular/router';//※重點
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html',
  styleUrls: ['./home.component.css']
})
export class HomeComponent implements OnInit {

  constructor(private lokiRouter: Router) { }//※重點

  ngOnInit() {
  }

  loadServers() {  //※重點
    //run sql content then go page to servers
    this.lokiRouter.navigate(['/servers']);
  }
}
```

#### navigate 路徑觀念
`navigate()`的路徑觀念跟範本上使用`routerLink=''`是不同的。首先討論範本上的 routerLink 部份會根據你是否添加`/`而有不同的相對路徑影響。但 TypeScript 上的 navigate 的相對路徑是非絕對的，因為 TypeScript 是腳本代碼，因此不會知道當前頁會是在哪裡，因此 Angular 只能根據整個網站的路徑開始指向。

如果你需要明確地給`navigate()`有明確的相對位置參考，使得它能依據相對路徑來獲得疊加的 URL 位置。對第二參數增加指定物件名，並提供目前作用的 activeRoute。

```ts
import { ActivatedRoute, Router } from '@angular/router'; //※重點
import { Component, OnInit } from '@angular/core';
import { ServersService } from './servers.service';

@Component({
  selector: 'app-servers',
  templateUrl: './servers.component.html',
  styleUrls: ['./servers.component.css']
})
export class ServersComponent implements OnInit {
  public servers: { id: number, name: string, status: string }[] = [];

  constructor(
    private serversService: ServersService,
    private router: Router, //※重點
    private nowAt: ActivatedRoute //※重點
  ) { }

  ngOnInit() {
    this.servers = this.serversService.getServers();
  }

  reloadServer() { //※重點
    //at: localhost/servers
    // this.router.navigate(['/servers'], { relativeTo: this.nowAt });

    //at: localhost/servers/servers
    this.router.navigate(['servers'], { relativeTo: this.nowAt });
  }
}
```

>如果路由的位置，跟目前所在的切頁位置相同且資料不變，Angular 會自動忽略此路由要求。
https://www.udemy.com/course/the-complete-guide-to-angular-2/learn/lecture/6656296#overview

## 向路由傳遞參數
假設我們有個頁面需要顯示特定用戶的資料，而路由的網址參數可以做為我們的動態變數使用。舉例來說你可以訪問`http://localhost/user/3`代表 id 為 3 的單筆資料。首先需要從 app.modules.ts 那裏先設定路由位置。其中`:id`代表 id 是我們的動態變數。可以多個

```ts app.module.ts
const lokiRoutes: Routes = [ //※重點
  { path: '', component: HomeComponent },
  { path: 'users', component: UsersComponent },
  { path: 'users/:id/:name', component: UserComponent },
  { path: 'servers', component: ServersComponent }
];
```

接著來到該 user 子元件這裡，透過 TypeScript 來獲得目前路由上的動態變數，該變數放置於路由快照下的 params 陣列內，根據你的變數名稱取得。
- 規劃私有自訂名稱 lokiRoute 屬性賦予 ActivatedRoute 型別，使得 class 內可讀取該模組變數。
- 當網頁初始化時，向該變數 lokiRoute 的深層位置 params 參數並找到該動態變數，指定回我們的初始變數 user。

```ts user.component.ts
import { ActivatedRoute } from '@angular/router';
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-user',
  templateUrl: './user.component.html',
  styleUrls: ['./user.component.css']
})
export class UserComponent implements OnInit {
  user!: { id: number, name: string };
  constructor(private lokiRoute: ActivatedRoute) { }

  ngOnInit() {
    this.user = {
      id: this.lokiRoute.snapshot.params['id'],
      name: this.lokiRoute.snapshot.params['name']
    }
    //console.log(this.user); //try http://localhost:4200/users/3/loki
  }
}
```

現在我們有了元件屬性綁定，回到範本就能透過字串差值顯示在畫面上。

```html user.component.html
<p>User with ID {{user.id}} loaded.</p>
<p>User name is {{user.name}}</p>
```

snapshot 快照是指當下動作成功時的備份處，他用於有發生路由轉換時列入。但某條件不會列入快照。如下節說明。

### 從 Template 觸發同處路由
此時我們添加一個超連結按鈕，利用`[routerLink]="['/users']"`來完成，而陣列內的其餘參數能代表路徑上的動態變數值。

```html user.component.html
<p>User with ID {{user.id}} loaded.</p>
<p>User name is {{user.name}}</p>
<hr>
<a [routerLink]="['/users',10,'max']">User Max(sn:10)</a>
```

如果你是從`http://localhost:4200/users`的按鈕跳躍到`http://localhost:4200/users/10/max`這沒問題快照有捕捉到參數。但是如果從某用戶跳躍例如`http://localhost:4200/users/3/loki`的按鈕想跳躍`http://localhost:4200/users/10/max`，會發現快照沒有更新停留在 loki 的資料上。這是因為 Angular 收到 link 的變化但組件沒有重新加載的需求，因此不會觸發 Oninit 初始化，自然不會有快照。如果要克服我們需要使用到訂閱功能。

講訂閱之前，需要先提到 Angular 在處理一些非同步任務（某代碼之後才會在某時間下才執行），這是 Angular 利用 RxJS 第三方函式庫的 Observable 可觀察對象所達到的，之後會在介紹。只需要透過訂閱就能向 Observable 要求當時機達到時做甚麼事情。而 Angular 很多模組參數（屬於 Observable) 並提供訂閱讓你做到時候該做的事。

因此我們在本元件初始化時，除了要求初始一開始先獲得快照下的參數。同時也從這個路由的參數觀察來訂閱他，當這個地方發生非同步作業（也就是之後才有變化），就幫我們取得參數寫回我們的屬性值。而不是靠下次重新加載本元件才能獲得。

```ts user.component.ts
import { ActivatedRoute, Params } from '@angular/router';
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-user',
  templateUrl: './user.component.html',
  styleUrls: ['./user.component.css']
})

export class UserComponent implements OnInit {
  user!: { id: number, name: string };
  constructor(private lokiRoute: ActivatedRoute) { }

  ngOnInit() {
    this.user = {
      id: this.lokiRoute.snapshot.params['id'],
      name: this.lokiRoute.snapshot.params['name']
    }

    this.lokiRoute.params.subscribe((obsParams: Params) => {
      this.user = {
        id: obsParams.id,
        name: obsParams.name
      }
    });
    //console.log(this.user); //try http://localhost:4200/users/3/loki
  }
}
```

現在不管元件有沒有重新加載初始化，只要我們的路由位置有獲得動態變數也就是 params 參數時，就幫我們指定給 user 物件並更新值。

> subscribe 訂閱用途，在可用的場合下，提前跟 Angular 說到時候這裡會需要做些什麼事情。

### 取消訂閱於銷毀階段

在 Angular 觀念當中，需要知道每一次的訂閱動作本身會占用記憶體空間。隨著你離開畫面時 Angular 自動銷毀元件釋放空間但訂閱不會。之後再重新加載這頁面你又進行新訂閱隨著重複動作將使記憶體空間不足。因此你需要透過生命週期 OnDestroy 階段主動取消訂閱，使得訂閱會隨著元件銷毀時一起結束。

像 setInterval 一樣我們需要一個 key 記住當下訂閱的編號，之後在 OnDestroy 階段透過這個 key 來取消訂閱。

- 規劃一個 Subscription 區域變數為 key，型別注意。
- 在訂閱當下儲存給此變數，在銷毀階段上對此變數執行

```ts user.component.ts
import { ActivatedRoute, Params } from '@angular/router';
import { Component, OnDestroy, OnInit } from '@angular/core'; //※重點
import { Subscription } from 'rxjs'; //※重點

@Component({
  selector: 'app-user',
  templateUrl: './user.component.html',
  styleUrls: ['./user.component.css']
})
export class UserComponent implements OnInit, OnDestroy {
  user!: { id: number, name: string };
  subscriptionKey!: Subscription; //※重點
  constructor(private lokiRoute: ActivatedRoute) { }

  ngOnInit() {
    this.user = {
      id: this.lokiRoute.snapshot.params['id'],
      name: this.lokiRoute.snapshot.params['name']
    }
    this.subscriptionKey = this.lokiRoute.params.subscribe((obsParams: Params) => { //※重點
      this.user = {
        id: obsParams.id,
        name: obsParams.name
      }
    });
  }
  ngOnDestroy(): void { //※重點
    this.subscriptionKey.unsubscribe();
  }
}
```

### 讀寫 Query 參數與片段
假設熟悉 GET 的資料應用，這裡主要談如何規劃網址上的資料，包含了如何生成如`?category=37&article=33`或錨點連結`#go`（錨點跳躍不會自動觸發，你需要自己添加向下滾動行為）。以及後半段的如何讀取這些 Query 資料。

#### 從 Template 指定
- 來到 app.module 這裡先添加一個路由，一個允許我們編輯某項 Server 的頁面指定給 edit-server 元件。
- 來到 servers 元件的範本左半部 list-group，先將 href 更改為 routerLink 屬性綁定使得能連結到指定路由位置為指定位置，例如`http://localhost:4200/servers/1/edit`
- 而 query 參數是`?`透過 queryParams 屬性綁定並指定物件資料。
- 錨點參數`#`則是 fragment 屬性綁定並指定字串，所以可簡化`[]`直接指定關鍵字

```ts app.module.ts
const lokiRoutes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'users', component: UsersComponent },
  { path: 'users/:id/:name', component: UserComponent },
  { path: 'servers', component: ServersComponent },
  { path: 'servers/:id/edit', component: EditServerComponent }  //※重點
];
```
```html servers.component.html
<div class="row">
  <div class="col-xs-12 col-sm-4">
    <div class="list-group">
      <a
        [routerLink]="['/servers',server.id,'edit']"
        [queryParams]="{allowEdit:1}"
        fragment="loading"
        class="list-group-item"
        *ngFor="let server of servers"
      >
        {{ server.name }}
      </a>
    </div>
  </div>
  <div class="col-xs-12 col-sm-4">
    <button (click)="reloadServer()">Reload Server</button>
    <app-edit-server></app-edit-server>
    <hr>
    <app-server></app-server>
  </div>
</div>
```

測試並點選畫面上的 side menu 你會獲得類似這樣的路由位置
```txt sample
http://localhost:4200/servers/2/edit?allowEdit=1#loading
```

#### 從 TypeScript 指定
我們來到 home 元件做示範，假設需要一個按鈕能載入 server 1 號。

```html home.component.html
<button class="btn btn-primary" (click)="loadServers(1)">load Servers 1</button>
```

現在回到 home 元件的 ts 部份，對 query 與 fragment 的寫入方式位於 Router.navigate 之第二參數，以物件資料指定。

```ts home.component.ts
loadServers(id: number) {  //※重點
  // this.lokiRouter.navigate(['/servers']);
  this.lokiRouter.navigate(
    ['/servers', id, 'edit'],  //這裡取消靜態 5 改抓函式參數
    {
      queryParams: {
        allowEdit: 1
      },
      fragment: "loading"
    }
  );
}
```

測試並點選 Home 畫面上的按鈕你會獲得類似這樣的路由位置

```txt sample
http://localhost:4200/servers/1/edit?allowEdit=1#loading
```

#### 從 TypeScript 讀取
來到 edit-server 元件，這裡已經出現很多現成代碼，大致說明會透過 ServersService 這支服務，進行獲得全部 server 資資料、獲得指定 id 資料、更新指定 id 資料。

可透過 ActivatedRoute 的快照來獲得非即時反應性資料，但如同前面所說自加載本元件之後當前頁面進行變動參數時無法即時更新當前修改（因為沒有重新加載元件）。

```ts edit-server.component.ts
import { ActivatedRoute } from '@angular/router'; //※重點
import { Component, OnInit } from '@angular/core';

import { ServersService } from '../servers.service';

@Component({
  selector: 'app-edit-server',
  templateUrl: './edit-server.component.html',
  styleUrls: ['./edit-server.component.css']
})
export class EditServerComponent implements OnInit {
  // server: { id: number, name: string, status: string };
  server: any;
  serverName = '';
  serverStatus = '';

  constructor(private serversService: ServersService, private route: ActivatedRoute) {
  }

  ngOnInit() {
    console.log(this.route.snapshot.fragment);
    console.log(this.route.snapshot.queryParams);

    // if (this.serversService.getServer(1) !== null) 
    this.server = this.serversService.getServer(1);
    this.serverName = this.server.name;
    this.serverStatus = this.server.status;
  }

  onUpdateServer() {
    this.serversService.updateServer(this.server.id, { name: this.serverName, status: this.serverStatus });
  }
}
```

另一種直接從 queryParams 的可觀察對象進行訂閱，一旦這處發生變化仍可以獲得目前值。

```ts edit-server.component.ts
this.route.fragment.subscribe(e => console.log(e));
this.route.queryParams.subscribe(e => console.log(e));
```

>Router 模組與 ActivatedRoute 模組各自主要工作為，Router 能幫助我們前往某指定路由位置依賴旗下的 navigate，ActivatedRoute 能幫助我獲得路由上的資訊，像是 snapshot 快照

### 操作示範與陷阱注意
讓我們先回到 users 元件，先修正 side menu 超連結要帶領要去的路由位置。參考 app.moudle 稍早的定義類似要去`/users/id/name`，因此到範本這裡使用 routerlink 來帶入動態變數。讓我們可以訪問到單項 user 資訊。

```html users.component.html
<a
  [routerLink]="['/users',user.id,user.name]"
  class="list-group-item"
  *ngFor="let user of users"
>
```

同樣之前的 servers 元件之 side menu 僅是為了示範直接跳到 edit 模式，這裡協助修正路由適當的位置，
- 從 servers 元件關於列表部份，取消原單一 server 連結的 edit 路徑，使得變成只有訪問單項 server 資訊。之後再適合的動線上再進入 edit 切頁。
-  app.module 也要設定路徑增加此項。幫助我們訪問單一時帶到 server 元件去。

```ts app.module.ts
const lokiRoutes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'users', component: UsersComponent },
  { path: 'users/:id/:name', component: UserComponent },
  { path: 'servers', component: ServersComponent },
  { path: 'servers/:id', component: ServerComponent }  //※重點
  { path: 'servers/:id/edit', component: EditServerComponent }
];
```
```html servers.component.html
<!-- 拿掉 ,'edit' -->
<a
  [routerLink]="['/servers',server.id]"
  [queryParams]="{allowEdit:1}"
  fragment="loading"
  class="list-group-item"
  *ngFor="let server of servers"
>
  {{ server.name }}
</a>
```

現在我們需要當從 server side menu 點選時拜訪單一 server 切頁，將直接 URL 上面獲得 id，並透過 server.service 來進行資料查詢單筆。
- 來到 server 元件我們需要啟用可訪問路由的 ActivatedRoute。
- 在 OnInit 階段上，透過 ActivatedRoute 來獲得我們的 params 上的 id（層級名稱），拿來提供 server 服務部份所需要的 getServer 參數刷新網頁
- 同時需要注意 params 因同頁面下的變化，因此需要以訂閱方式來更新我們的 getServer 參數刷新網頁

```ts server.component.ts
import { ActivatedRoute, Params } from '@angular/router';
import { Component, OnInit } from '@angular/core';
import { ServersService } from '../servers.service';

@Component({
  selector: 'app-server',
  templateUrl: './server.component.html',
  styleUrls: ['./server.component.css']
})
export class ServerComponent implements OnInit {
  // server: {id: number, name: string, status: string};
  server: any;

  constructor(private serversService: ServersService, private route: ActivatedRoute) { } //※重點

  ngOnInit() {
    const id = this.route.snapshot.params.id;
    this.server = this.serversService.getServer(id); //※重點
    // this.server = this.serversService.getServer(1);

    this.route.params.subscribe((prm: Params) => {
      this.server = this.serversService.getServer(prm.id); //※重點
    });
  }
}
```

現在有兩個 Bug 我們需要修復，透過畫面來到 servers 頁面 (`http://localhost:4200/servers`)。這裡出現了以下資訊：

```log
 Cannot read properties of null (reading 'name') at ServerComponent_Template, ...
```

這因為原本總列表這裡我們有塞一個 server 元件並提供靜態 serverID 為 1 的示範素材。現在被我們改成將從路由上抓取 id 作為資料處理的一部份，在目前頁面上抓不到就產生不了 server.name 的字串差值。等於我們路由設計不適合這樣被放在 servers 總表的畫面上，可以先註解先拿掉。

```html servers.component.html
<!-- <app-server></app-server> -->
```

servers 總列表的畫面正常後，再來是另一個問題，當點選任何 server 進入細節時發生錯誤。

```log
ERROR TypeError: Cannot read properties of null (reading 'name') at ServerComponent_Template, ...
```

這是因為型別錯誤，原因是從 Params 捕捉回來的資料格式全都是 string，而我們 id 的型別為 number 因此這樣指定出現問題。你可以使用很快的方式強迫將 string 轉為 number。在需要的地方前綴增加`+`符號使得型態轉為數字，也包含訂閱那裏。

```ts server.component.ts
ngOnInit() {
  const id = +this.route.snapshot.params.id;  //型別 string to number
  this.server = this.serversService.getServer(id);
  // this.server = this.serversService.getServer(1);

  this.route.params.subscribe((prm: Params) => {
    this.server = this.serversService.getServer(+prm.id); //型別 string to number
  });
}
```

### 嵌套路由 Nesting Route
舉例 servers 的 side menu 如果可以像 frame 那樣的技術，讓左側選單的是對應對右側`<app-edit-server>`做路由切換。以及 app.module 設定在 servers 路徑上有點重複。

```ts app app.module.ts
const lokiRoutes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'users', component: UsersComponent },
  { path: 'users/:id/:name', component: UserComponent },
  { path: 'servers', component: ServersComponent },
  { path: 'servers/:id', component: ServerComponent },
  { path: 'servers/:id/edit', component: EditServerComponent }
];
```

可透過第三個屬性 children （注意這裡是設定陣列結構為型別不是給值）來代表子路由位置進行分組。列入 serversComponent 內的子路由。

```ts app.module.ts
const lokiRoutes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'users', component: UsersComponent },
  { path: 'users/:id/:name', component: UserComponent },
  {
    path: 'servers', component: ServersComponent, children: [
      { path: ':id', component: ServerComponent },
      { path: ':id/edit', component: EditServerComponent }
    ]
  }
];
```

此時檢查頁面，發現所有在 servers 底下的 side menu 的切頁功能會失效，只有 url 變化有成功。還記得我們在 app.component 上的路由動作是在該 app 元件下進行路由導向輸出到`<router-outlet></router-outlet>`位置。而這些子路由則目前在 servers 元件底下，因此我們缺乏一個 servers 子路由所需要的`<router-outlet></router-outlet>`。現在我們需要能切頁到右側就應該這樣處理：

```html servers.component.html
<div class="row">
  <div class="col-xs-12 col-sm-4">
    <div class="list-group">
      <a
        [routerLink]="['/servers',server.id]"
        [queryParams]="{allowEdit:1}"
        fragment="loading"
        class="list-group-item"
        *ngFor="let server of servers"
      >
        {{ server.name }}
      </a>
    </div>
  </div>
  <div class="col-xs-12 col-sm-4">
    <router-outlet></router-outlet>
    <!-- <button (click)="reloadServer()">Reload Server</button>
    <app-edit-server></app-edit-server>
    <hr> -->
    <!-- <app-server></app-server> -->
  </div>
</div>
```

現在請幫忙優化 users 那裏也改成嵌套路由。

```ts app.module.ts
const lokiRoutes: Routes = [
  { path: '', component: HomeComponent },
  {
    path: 'users', component: UsersComponent, children: [
      { path: ':id/:name', component: UserComponent }
    ]
  },
  {
    path: 'servers', component: ServersComponent, children: [
      { path: ':id', component: ServerComponent },
      { path: ':id/edit', component: EditServerComponent }
    ]
  }
];
```
```html servers.component.html
<div class="row">
  <div class="col-xs-12 col-sm-4">
    <div class="list-group">
      <a
        [routerLink]="['/users',user.id,user.name]"
        class="list-group-item"
        *ngFor="let user of users"
      >
        {{ user.name }}
      </a>
    </div>
  </div>
  <div class="col-xs-12 col-sm-4">
    <!-- <app-user></app-user> -->
    <router-outlet></router-outlet>
  </div>
</div>
```

### 練習使用 Query 參數
現在試著讓範例的動線更好，我們將 edit server 的功能放置在各自 server 畫面底下。

- 對 server 元件的範本上規劃按鈕並賦予事件綁定為 onEdit。
- 對 server 元件的 TS 之此方法進行導覽到指定路由位置為`/server/id/edit`，這需要透過 navigate 達到指令因此我們需要使用到 Router 模組。
- 前往位置的方式有兩種，你可以重新再寫一次完整路徑，或根據相對目前路徑做延伸。但這兩種都不會協助將原本目前路徑的 query 參數轉向（之後再解決）。
- 
```html server.component.html
<h5>{{ server.name }}</h5>
<p>Server status is {{ server.status }}</p>
<button (click)="onEdit()">Edit Button</button>
```  
```ts server.component.ts
import { ActivatedRoute, Params, Router } from '@angular/router'; // ※重點
import { Component, OnInit } from '@angular/core';
import { ServersService } from '../servers.service';

@Component({
  selector: 'app-server',
  templateUrl: './server.component.html',
  styleUrls: ['./server.component.css']
})
export class ServerComponent implements OnInit {
  // server: {id: number, name: string, status: string};
  server: any;

  constructor(
    private serversService: ServersService,
    private route: ActivatedRoute,
    private router: Router
  ) { }

  ngOnInit() {
    const id = +this.route.snapshot.params.id;
    this.server = this.serversService.getServer(id);

    this.route.params.subscribe((prm: Params) => {
      this.server = this.serversService.getServer(+prm.id);
    });
  }

  onEdit() { // ※重點
    //目前位置為 /servers/2 ，並自帶參數為 ?allowEdit=1#loading
    // this.router.navigate(['/servers', this.server.id, 'edit']);  // 方法一
    this.router.navigate(['edit'], { relativeTo: this.route })  //方法二：使用相對目前位置路徑添加 edit 位置
  }
}
```

再來是舉例`?allowEdit=1`的 Query 資料進行應用，設計為在某條件下才允許編輯資訊，假設我們靜態指定當 id 為 3 的 server 才能進行編輯 (1 為 true)。回到 servers 元件這裡的 html 部份，這是 allowEdit 一開始出現的地方，符合上句描述。

```html servers.component.html
<a
  [routerLink]="['/servers',server.id]"
  [queryParams]="{allowEdit:server.id===3?1:0}"
  fragment="loading"
  class="list-group-item"
  *ngFor="let server of servers"
>
```

現在只有第三個 server 的詳細資訊有夾帶`?allowEdit=1`。試著去在 edit-component 訪問下底下進行判斷，如果持有`?allowEdit=1`則提供編輯功能否則提示文字。

```ts edit-server.component.ts
import { ActivatedRoute, Params } from '@angular/router';  //※重點
import { Component, OnInit } from '@angular/core';
import { ServersService } from '../servers.service';

@Component({
  selector: 'app-edit-server',
  templateUrl: './edit-server.component.html',
  styleUrls: ['./edit-server.component.css']
})
export class EditServerComponent implements OnInit {
  // server: { id: number, name: string, status: string };
  server: any;
  serverName = '';
  serverStatus = '';
  allowEdit = false; //※重點

  constructor(private serversService: ServersService, private route: ActivatedRoute) {
  }

  ngOnInit() {
    // console.log(this.router.snapshot.fragment);
    // console.log(this.router.snapshot.queryParams);
    // this.router.fragment.subscribe(e => console.log(e));
    // this.router.queryParams.subscribe(e => console.log(e));
    
    this.route.queryParams.subscribe((params: Params) => { //※重點
      this.allowEdit = params.allowEdit === '1' ? true : false;
    });

    // if (this.serversService.getServer(1) !== null) 
    this.server = this.serversService.getServer(1);
    this.serverName = this.server.name;
    this.serverStatus = this.server.status;
  }

  onUpdateServer() {
    this.serversService.updateServer(this.server.id, { name: this.serverName, status: this.serverStatus });
  }
}
```

然後來到 edit-server 元件的範本，透過 ngIf 來評估是否呈現編輯元素或提示字。

```html edit-server.component.html
<h4 *ngIf="!allowEdit">You're not not allow to edit!</h4>
<section *ngIf="allowEdit">
  <div class="form-group">
    <label for="name">Server Name</label>
    <input
      type="text"
      id="name"
      class="form-control"
      [(ngModel)]="serverName"
    >
  </div>
  <div class="form-group">
    <label for="status">Server Status</label>
    <select
      id="status"
      class="form-control"
      [(ngModel)]="serverStatus"
    >
      <option value="online">Online</option>
      <option value="offline">Offline</option>
    </select>
  </div>
  <button
    class="btn btn-primary"
    (click)="onUpdateServer()"
  >Update Server</button>
</section>
```

最後來修正如何讓 navigate 可以夾帶目前的 query 參數。來到消失前的關鍵按鈕動作位於 server 元件的 onEdit() 部份。主要為讓 navigate 協助導覽時，在第二參數多一個屬性為 queryParamsHandling 並提供字串保留，你可以要求舊值處理。 選 preserve 則為只用舊值，選 merge 則為與新值合併。

```ts server.component.ts
onEdit() { // ※重點
  //目前位置為 /servers/2 ，並自帶參數為 ?allowEdit=1#loading
  // this.router.navigate(['/servers', this.server.id, 'edit']);  // 方法一
  // this.router.navigate(['edit'], { relativeTo: this.route })  //方法二：使用相對目前位置路徑添加 edit 位置
  this.router.navigate(['edit'], {
    relativeTo: this.route,
    queryParamsHandling: 'preserve'
  })  //可合併原本的 query params
}
```

{% note warning %}
  **科普知識：preserve 與 merge**
根據這兩者的應用如下，假設你目前位置為`/firstUrl?name=bat7`要跳到`/secondUrl`：
```ts
this.router.navigate(['/secondUrl'], { queryParamsHandling: 'preserve' });
// like this http://localhost:4200/secondUrl?name=bat7

this.router.navigate(['/secondUrl/newVal'], { queryParams: { age: 'not-known'}, queryParamsHandling: 'merge' });
//http://localhost:4200/secondUrl?name=bat7&age=not-known
```
{% endnote%}

## 路由重新導向
你可以指定當用戶輸入無效的位置時，進行重新導向到像似 page 404 之類的動作。先手動添加一個新元件命名為 page-not-found 並規劃範本為簡單的文字說明

```shell
ng g c page-not-found
```
```html page-not-found.component.html
<h1>THIS PAGE WAS NO FOUND</h1>
```

再來是來到 app.module.ts 來註冊這個預設路由位置。同時再多新增一個測試用的位置，透過 redirectTo 帶往到這個 404 位置。

```ts app.module.ts
const lokiRoutes: Routes = [
  { path: '', component: HomeComponent },
  {
    path: 'users', component: UsersComponent, children: [
      { path: ':id/:name', component: UserComponent }
    ]
  },
  {
    path: 'servers', component: ServersComponent, children: [
      { path: ':id', component: ServerComponent },
      { path: ':id/edit', component: EditServerComponent }
    ]
  },
  { path: '404', component: PageNotFoundComponent },
  { path: 'try', redirectTo: '/404' }
];
```

測試 404 與 try 最後都是在 404 的畫面，這就是重新導向的做法。如果你需要排除已知以外的路徑都要導向到 404，可使用`**`通用字符來代表。需注意位置順序，由上到下解析。因此必需要放在陣列處最後一組。

```ts app.module.ts
const lokiRoutes: Routes = [
  { path: '', component: HomeComponent },
  {
    path: 'users', component: UsersComponent, children: [
      { path: ':id/:name', component: UserComponent }
    ]
  },
  {
    path: 'servers', component: ServersComponent, children: [
      { path: ':id', component: ServerComponent },
      { path: ':id/edit', component: EditServerComponent }
    ]
  },
  { path: '404', component: PageNotFoundComponent },
  { path: '**', redirectTo: '/404' }
];
```

{% note danger %}
**新手陷阱：pathMatch='prefix'**
Angular 所有路由的 pathMatch 參數其預設值為 prefix，這代表會參考前綴符號來查找。舉例來說
```ts
const lokiRoutes: Routes = [
  // ...
  { path: '404', component: PageNotFoundComponent },
  { path: 'a', redirectTo: '/404' }
];
```
會發生跳轉到 404 的組合為只要網址如下例有 a 的分類都會跳轉。

```txt
http://localhost:4200/a
http://localhost:4200/a/b
http://localhost:4200/a/b/c
```

因此，如果你希望只有`/a`的位置會跳轉而後綴其他位置不影響，你需要綁定為 full 作為匹配範圍
```ts
const lokiRoutes: Routes = [
  // ...
  { path: '404', component: PageNotFoundComponent },
  { path: 'a', redirectTo: '/404', pathMatch: 'full' }
];
```

而危險的動作是，如果你這樣設計寫法為任何網頁都會是要去 404，但想停留在 404 時連自己也找不到。因為整個都被覆蓋了
```ts
const lokiRoutes: Routes = [
  // ...
  { path: '404', component: PageNotFoundComponent },
  { path: '', redirectTo: '/404'}
];
```
{% endnote %}

## 路由配置的檔案
如果你的路由設定非常的多都寫在 app.module.ts 是不健康的，一般作法會將路由相關配置獨立一個檔案在外部。在 CLI 協助建立專案過程中特別詢問你是否要建立 Routing 如果你確定（假設專案名取為 app) 則會多產生一隻 app-routing.module.ts，並幫你添加到 app.module.ts 內。

你可以事後要求產生模組檔案並提供這兩支給你。

```shell
ng generate module loki --routing
# same ng g m loki --routing
```

請手動新增檔案`app-routing.module.ts`位於相對`app.module.ts`位置參考這兩隻檔案進行初步整理。或參考以下初始檔案跟著動作：

```ts app-routing.module.ts
import { NgModule } from '@angular/core';

@NgModule({
})
export class AppRoutingModule { }
```

- 將 const lokiRoutes 等路由資料，從 app.module.ts 搬移至 app-routing.module.ts 檔內。
- 利用修復工具快速將所有遺失的元件宣告來源補回來。
- 找到原本 app.module.ts 內的 imports 部分，試著搬移 RouterModule 的資訊
- 同時要添加 exports 將這個路由模駔輸出。
- 回到 app.module.ts 需要將 AppRoutingModule 宣告。
- 現在路由模組名字換成這裡要 import 模組進來。
- 最後測試一下有無成功。

```ts app-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { PageNotFoundComponent } from './page-not-found/page-not-found.component';
import { EditServerComponent } from './servers/edit-server/edit-server.component';
import { ServerComponent } from './servers/server/server.component';
import { ServersComponent } from './servers/servers.component';
import { UserComponent } from './users/user/user.component';
import { UsersComponent } from './users/users.component';

const lokiRoutes: Routes = [
  { path: '', component: HomeComponent },
  {
    path: 'users', component: UsersComponent, children: [
      { path: ':id/:name', component: UserComponent }
    ]
  },
  {
    path: 'servers', component: ServersComponent, children: [
      { path: ':id', component: ServerComponent },
      { path: ':id/edit', component: EditServerComponent }
    ]
  },
  { path: '404', component: PageNotFoundComponent },
  { path: '**', redirectTo: '/404' }
];

@NgModule({
  imports: [
    RouterModule.forRoot(lokiRoutes)
  ],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```
```ts app.module.ts
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { AppComponent } from './app.component';
import { HomeComponent } from './home/home.component';
import { UsersComponent } from './users/users.component';
import { ServersComponent } from './servers/servers.component';
import { UserComponent } from './users/user/user.component';
import { EditServerComponent } from './servers/edit-server/edit-server.component';
import { ServerComponent } from './servers/server/server.component';
import { ServersService } from './servers/servers.service';
import { PageNotFoundComponent } from './page-not-found/page-not-found.component'; //※重點
import { AppRoutingModule } from './app-routing.module';

@NgModule({
  declarations: [
    AppComponent,
    HomeComponent,
    UsersComponent,
    ServersComponent,
    UserComponent,
    EditServerComponent,
    ServerComponent,
    PageNotFoundComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    AppRoutingModule
  ],
  providers: [ServersService],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

## Guards 路由守衛 
指的是當你要進行路由加載之前以及離開路由之前可以進行一系列的動作前置，舉例來說在範例上來到 server 列表之中可以選擇單一 server 進行編輯，在進入這個路由之前進行用戶身分認證的功能。而不是透過元件初始化階段 onInit 階段進行檢查。守衛本身只是一個服務上的系列動作之設計，主要仍回歸使用內建函式 CanActivate 與 CanDeactivate 返還給我們的資料去達到路由進出的控制。

### CanActivate 許可路由進入
要使用守衛方式透過自建服務並透過 CanActivate 來自訂守衛。服務添加的使用方式與其他一般服務添加方式一致。

- 在跟目錄下新增服務檔案或 CLI 指令`ng g s auth-guard`。獲得`auth-guard.service.ts`
- 接著我們需要對 CanActivate 這隻模組做宣告載入 implements 介面使用，並使用固定命稱 canActivate 方法且本身會吃兩個參數。
- 在 該函式規劃一參數自訂名為 route 作為路由已啟用之快照，並指定為 ActivatedRouteSnapshot 型別。 
- 在 該函式規劃一參數自訂名為 state 作為路由狀態之快照，並指定為 RouteStateSnapshot 型別。 
- 整個 CanActivate 函式會回傳一個 Observable 可觀察對象，因此要確保該型別為 Observable，同時這個 Observable 會包含一個 Boolean 值。另外一種可能會回傳一個 Promise，Promise 會包含 Boolean 值，也可能直接回傳一個 Boolean。因此我們有三種回傳的型別可能。

> 以上規畫皆固定，可參考複製於官方的 [canActivate 結構說明](https://angular.tw/api/router/CanActivate#canActivate)。

```ts auth-guard.service.ts
import { ActivatedRouteSnapshot, CanActivate, RouterStateSnapshot } from '@angular/router';
import { Observable } from 'rxjs';

export class AuthGuardService implements CanActivate {

  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean{
    //something
  }
}
```

我們希望做一個能登入登出功能，因此規劃另一個服務作為身分認證使用，命名為 `auth.service.ts` ，這裡只是測試實際工作上會連線到後端進行登入登出並檢查當前的身分狀態。

- 可透過 CLI 進行`ng g s auth`，獲得該檔案。
- 規劃區域屬性 loggedIn 為 false 代表未登入，方法 login() 能改此為 true，方法 logout() 能改此為 false。
- 規劃 isAuthenticated() 方法，這是為了假裝是跟後端諮詢登入狀態，利用 Promise 並延遲 1 秒後回傳告知登入狀態初始為 false，整個服務範圍都是為了假裝跟後端拿登入的布林值。

```ts auth.service.ts
export class AuthService {
  loggedIn = false;

  isAuthenticated() {
    const promise = new Promise(
      (res, rej) => {
        setTimeout(() => {
          res(this.loggedIn);
        }, 1000);
      }
    );
  }

  login() {
    this.loggedIn = true;
  }

  logout() {
    this.loggedIn = false;
  }
}
```

現在已模擬一個假後端的服務，透過這個服務能一秒後告知我們用戶的登入狀態為何，我們將利用到這個 auth-guard 服務，因此需要設定注入添加到 auth-guard 內。讓 auth 服務能注入到這個守衛服務。現在能在 AuthGround 的建構函式來私有化使用

- 對 auth-ground.service 添加`@Injectable()`
- 宣告匯入 AuthService 這支服務
- 同時規劃一 authService 私有屬性到 constructor，並指定 AuthService 型別
- 來到 canActivate() 方法內，找到 authService 屬性內的 isAuthenticated() 告知我們登入狀態，因為 isAuthenticated() 本身是 promise 所以用 then 來後續處理。
- 在 then 裡面透過判斷是否登入並回傳布林值到 canActivate()，同時如果未登入 false 利用 router.navigate 導向到首頁去。
- 最後 canActivate() 本身也要回傳出去，所以將這個 boolean 再回傳出去。

```ts auth-ground.service.ts
import { AuthService } from './auth.service';
import { ActivatedRouteSnapshot, CanActivate, Router, RouterStateSnapshot } from '@angular/router';
import { Observable } from 'rxjs';
import { Injectable } from '@angular/core';

@Injectable()

export class AuthGuardService implements CanActivate {
  constructor(
    private authService: AuthService,
    private router: Router
  ) { }

  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean {
    //something
    return this.authService.isAuthenticated().then(
      (value) => {
        console.log(value);
        if (value) return true;
        else {
          this.router.navigate(['/']);
          return false;
        }
      }
    );
  }
}
```

現在已設計完守衛的功能，就看是要在哪裡使用守衛服務。來到定義路由的 app.routing.module 這裡試著將守衛服務放入到路由內，使得路由執行前能觸發守衛。

- 對想要守衛服務的路徑設定上，插入屬性為 canActive 值為 Boolean。範例這裡是對 servers 這支作業，其子路由也會吃到這個守衛。
- 現在透過除非 AuthGuardService 回傳 true，這個 servers 路徑才能被訪問。
- 以及需要到 app.module 這裡將這個兩隻服務放入到 providers 內。

```ts app-routing.module.ts
const lokiRoutes: Routes = [
  { path: '', component: HomeComponent },
  {
    path: 'users', component: UsersComponent, children: [
      { path: ':id/:name', component: UserComponent }
    ]
  },
  {
    path: 'servers', canActivate: [AuthGuardService], component: ServersComponent, children: [ //※重點
      { path: ':id', component: ServerComponent },
      { path: ':id/edit', component: EditServerComponent }
    ]
  },
  { path: '404', component: PageNotFoundComponent },
  { path: '**', redirectTo: '/404' }
];
```
```ts app.module.ts
//...
import { AuthGuardService } from './auth-guard.service';
import { AuthService } from './auth.service';

@NgModule({
  declarations: [
    AppComponent,
    HomeComponent,
    UsersComponent,
    ServersComponent,
    UserComponent,
    EditServerComponent,
    ServerComponent,
    PageNotFoundComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    AppRoutingModule
  ],
  providers: [ServersService, AuthService, AuthGuardService],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

現在服務已被設定給整份 app，在還沒呼喚 login() 之前，因為初始為 false 現在會拒絕我們訪問整個 servers 路由與子路由。現在試著從 users 位置點選 servers 位置是否一秒後轉回首頁。目前設計為適合要阻擋整個 servers 路徑，但如果只想阻擋在內部下層的 path 路徑上，你可以剪貼到下層各自的 path 去，但還有更好的方法為 CanActivateChild，它能設定在父路由上，使得子路由都會吃到這個守衛設定。

- 來到 auth-guard.service 這裡，多一組介面為 CanActivateChild。
- 同 canActivate() 結構，多做一份固定名稱 canActivateChild() 結構一致。而 return 的項目為依賴 canActive 動作即可。將獲得的兩參數轉給 canActive。

```ts auth-guard.service.ts
import { AuthService } from './auth.service';
import { ActivatedRouteSnapshot, CanActivate, CanActivateChild, Router, RouterStateSnapshot, UrlTree } from '@angular/router';
import { Observable } from 'rxjs';
import { Injectable } from '@angular/core';

@Injectable()

export class AuthGuardService implements CanActivate, CanActivateChild {
  constructor(
    private authService: AuthService,
    private router: Router
  ) { }

  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean {
    //something
    return this.authService.isAuthenticated().then(
      (value) => {
        console.log(value);
        if (value) return true;
        else {
          this.router.navigate(['/']);
          return false;
        }
      }
    );
  }
  canActivateChild(childRoute: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean | Observable<boolean> | Promise<boolean> {
    return this.canActivate(childRoute, state);
  }
}
```
再回到 app-routing.module 這裡，現在不使用 canActivate 而是使用 canActivateChild。

```ts app-routing.module.ts
const lokiRoutes: Routes = [
  { path: '', component: HomeComponent },
  {
    path: 'users', component: UsersComponent, children: [
      { path: ':id/:name', component: UserComponent }
    ]
  },
  {
    path: 'servers',
    // canActivate: [AuthGuardService],
    canActivateChild: [AuthGuardService], //※重點
    component: ServersComponent,
    children: [ 
      { path: ':id', component: ServerComponent },
      { path: ':id/edit', component: EditServerComponent }
    ]
  },
  { path: '404', component: PageNotFoundComponent },
  { path: '**', redirectTo: '/404' }
];
```

現在只有這底下的子路由才會受阻擋。現在你學會阻擋整個路由或是侷限在子路由的阻擋。

#### 模擬已登入效果
現在要模擬登入後的守衛狀態，來到 home 元件這裡的範本規劃兩組按鈕登入登出。再來到 ts 這裡將我們的 AuthService 私有實例介面化才能使用 login 與 logout 改變布林值。

```html home.component.html
<button class="btn btn-success" (click)="onLogin()">Login</button>
<button class="btn btn-danger" (click)="onLogout()">Logout</button>
```
```ts home.component.ts
import { Router } from '@angular/router';
import { Component, OnInit } from '@angular/core';
import { AuthService } from './../auth.service';//※重點

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html',
  styleUrls: ['./home.component.css']
})
export class HomeComponent implements OnInit {

  constructor(
    private lokiRouter: Router,
    private authService: AuthService //※重點
  ) { }

  ngOnInit() {
  }

  loadServers(id: number) {  //※重點
    // this.lokiRouter.navigate(['/servers']);
    this.lokiRouter.navigate(
      ['/servers', id, 'edit'],
      {
        queryParams: {
          allowEdit: 1
        },
        fragment: "loading"
      }
    );
  }

  onLogin() { //※重點
    this.authService.login();
  }
  onLogout() { //※重點
    this.authService.logout();
  }
}
```

現在你擬透過 login 切換布林值來獲得 servers 底下子路由的權限。

### canDeactivate 許可路由離開
現在可以來討論如何控制目前路由是否允許你離開。例如進行表單編輯當下不小心操作到離開頁面，就能提醒住戶表單資料未送出或是否取消等設計。防止住戶進行意料之外的路由導航。

- 規劃新服務為 deactivate-guard，可利用 CLI 指令`ng g s deactivate-guard`完成，這支檔案我們放置在 edit-server 的目錄下只有這裡會用到。
- 同樣需要規劃 CanDeactivate 這隻模組做宣告載入 implements 介面使用，並使用固定名稱來調用 canDeactivate 方法且本身會吃三個參數。
- 除了有兩個地方會使用到型別 (canDeactivate 使用方法），因此型態另外規劃成型別介面並命名為 ComponentNameComponent。
- 這支 DeactivateGuardService 服務本身會回傳 ComponentNameComponent 型別資料
- canDeactivate 的第一個參數為告知目前所在的元件，且需要 ComponentNameComponent 的型別。
- 第二參數為當前路由為何，可透過 ActivatedRouteSnapshot 獲得型別。
- 第三參數為當前狀態為何，可透過 RouterStateSnapshot 獲得型別。
- 第四參數（非必要）為下一路由為何，也可透過 ActivatedRouteSnapshot 獲得型別。
- 這隻 canDeactivate 為可觀察的，能回傳 Observable 的 boolean 或 Promise 的 boolean 或 boolean。
- 最後 canDeactivate 會回傳我們當前元件的調用 canDeactivate 結果。

>以上規畫皆固定，可參考複製官方對於 [canDeactivate 結構](https://angular.tw/api/router/CanActivate#canActivate) 說明。或使用 VSCode 關鍵字生成做參考。

```ts deactivate-guard.service.ts
import { ActivatedRouteSnapshot, CanDeactivate, RouterStateSnapshot } from '@angular/router';
import { Observable } from 'rxjs';

export interface ComponentNameComponent {
  canDeactivate: () => Observable<boolean> | Promise<boolean> | boolean;
}

export class DeactivateGuardService implements CanDeactivate<ComponentNameComponent> {
  canDeactivate(
    component: ComponentNameComponent,
    currentRoute: ActivatedRouteSnapshot,
    currentState: RouterStateSnapshot,
    nextStat?:RouterStateSnapshot
  ): Observable<boolean> | Promise<boolean> | boolean {
    return component.canDeactivate();
  }
}

// vssocde quikykeyworad is a-guard-can-deactivate
```

現在離開檢查工具服務已設計完成，就剩下你需要在哪個路由上使用，以及如何去接收這個布林值做想做的事情。回到 app-routing 的路由設定模組這。這裡我們假定只有當編譯 server 時未送出前離開需要做守衛阻擋。指定參數為 canDeactivate 而值對應某類別下同名的函式。

```ts app-routing.module.ts
//...
import { DeactivateGuardService } from './servers/edit-server/deactivate-guard.service'; //※重點

const lokiRoutes: Routes = [
  { path: '', component: HomeComponent },
  {
    path: 'users', component: UsersComponent, children: [
      { path: ':id/:name', component: UserComponent }
    ]
  },
  {
    path: 'servers',
    // canActivate: [AuthGuardService],
    canActivateChild: [AuthGuardService],
    component: ServersComponent,
    children: [
      { path: ':id', component: ServerComponent },
      { path: ':id/edit', component: EditServerComponent, canDeactivate: [DeactivateGuardService] } //※重點
    ]
  },
  { path: '404', component: PageNotFoundComponent },
  { path: '**', redirectTo: '/404' }
];
//...
```

現在守衛已經在指定的 edit-server 頁面上執行，但可不可以批准的布林值我們還沒設計出來。因此現在對 server 3 進行編輯時無法離開路由且報錯。

#### 設計提示離開效果
現在我們要來設計當此頁面離開時，經檢查提供用戶是否確定要離開。為了確保元件能讀到 Service 我們到 App.module 底下宣告該 Deactivate 能被所有元件使用到。

```ts app.moudle.ts
//...
import { DeactivateGuardService } from './servers/edit-server/deactivate-guard.service';

@NgModule({
  declarations: [
    AppComponent,
    HomeComponent,
    UsersComponent,
    ServersComponent,
    UserComponent,
    EditServerComponent,
    ServerComponent,
    PageNotFoundComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    AppRoutingModule
  ],
  providers: [ServersService, AuthService, AuthGuardService, DeactivateGuardService],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

回到我們需要會調用這個 Deactivate 功能的對象也就是 edit-server 元件，對其進行 implements 工具化整合入內，這樣我們才能在這個元件內使用 canDeactivate 模組。接著對該模組直接操作提供可觀察的結果布林值。這樣 app-routing 那裏會得到對應的布林值允許離開 (true) 或不離開 (false)

```ts app-routing.module.ts
import { DeactivateGuardService } from './deactivate-guard.service';
import { ActivatedRoute, Params } from '@angular/router';
import { Component, OnInit } from '@angular/core';
import { ServersService } from '../servers.service';
import { Observable } from 'rxjs';

@Component({
//...
})
export class EditServerComponent implements OnInit, DeactivateGuardService { //※重點
  // server: { id: number, name: string, status: string };
  server: any;
  serverName = '';
  serverStatus = '';
  allowEdit = false;
  changesSave = false; //※重點，還沒有設計判斷是否改變，這裡是假靜態

  constructor(private serversService: ServersService, private route: ActivatedRoute) {
  }

  ngOnInit() {
    // console.log(this.router.snapshot.fragment);
    // console.log(this.router.snapshot.queryParams);
    // this.router.fragment.subscribe(e => console.log(e));
    // this.router.queryParams.subscribe(e => console.log(e));
    this.route.queryParams.subscribe((params: Params) => {
      this.allowEdit = params.allowEdit === '1' ? true : false;
    });

    // if (this.serversService.getServer(1) !== null) 
    this.server = this.serversService.getServer(1);
    this.serverName = this.server.name;
    this.serverStatus = this.server.status;
  }

  onUpdateServer() {
    this.serversService.updateServer(this.server.id, { name: this.serverName, status: this.serverStatus });
  }

  canDeactivate(): boolean | Observable<boolean> | Promise<boolean> { //※重點
    if (!this.allowEdit) return true; //如果不允許編輯則可離開
    // 如果某欄位有修改且發生變化
    if (this.serverName != this.server.name || this.serverStatus != this.server.status && !this.changesSave)
      return confirm('Do you want leave page?');  //如果住戶回復 yes 會得到 true 而離開 false 則不能離開
    else return false; //沒有改變，可以離開
  }
}
```

最後順手更新原本的靜態 id=1 為動態，id 來自於路由 route 的快照內可獲得（網址參數），注意的是之前已提過自串轉數字的作法。

```ts edit-server.component.ts
ngOnInit() {
  this.route.queryParams.subscribe((params: Params) => {
    this.allowEdit = params.allowEdit === '1' ? true : false;
  });

  // if (this.serversService.getServer(1) !== null)
  const id = this.route.snapshot.params.id;  //※重點
  this.server = this.serversService.getServer(+id); //※重點

  this.serverName = this.server.name;
  this.serverStatus = this.server.status;
  }
```

現在才是正確載入 server 3 原有資料，而 server1 與 2 因沒有開放 allowEdit 仍無法登入。

### 資料傳遞至路由
我們可以透過路由來獲得資料，而不透過網址參數來獲得。可用在一些 404 錯誤的頁面上，網址是乾淨的但是 404 元件能從路由那裏獲得一些 data 進行字串插植到畫面上顯示特定文字。

#### 靜態數據示範
先從簡單開始，試著從路由取得固定的字串到畫面上。

- 來到 page-not-found 元件代碼規劃新屬性為 errorMessage。
- 來到 page-not-found 元件代碼範本做字串差值輸出。
- 由於靜態資料是固定的，所以可以把資料寫在 app-routing 模組。透過屬性 data 其值格式為物件

```ts page-not-found.component.ts
export class PageNotFoundComponent implements OnInit {
  errorMessage: string = '';
}
```
```html page-not-found.component.html
<h1>{{errorMessage}}</h1>
```
```ts app-routing.module.ts
// { path: '404', component: PageNotFoundComponent },
{
  path: '404', component: PageNotFoundComponent, data: {
    message: "you miss the way...."
  }
},
```

回到 page-not-found 元件，現在能從 ActivateRoute 來獲得這資料。一樣這裡有兩種方法，你需要知道兩者執行上的差異在於：
- 如果路由沒有發生變化也就是同頁面露由觸發，快照不會感應到 data 有變化。
- 對 data 進行可觀察對象，這樣一旦發生變化就會立即更新。可用於同頁面路由。但靜態資料來說 data 不會變所以這兩招都沒差。

```ts page-not-found.component.ts
import { ActivatedRoute } from '@angular/router';
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-page-not-found',
  templateUrl: './page-not-found.component.html',
  styleUrls: ['./page-not-found.component.css']
})
export class PageNotFoundComponent implements OnInit {
  errorMessage: string = '';
  constructor(private route:ActivatedRoute){}

  ngOnInit() {
    // this.errorMessage = this.route.snapshot.data.message;
    
    this.route.data.subscribe((data: Data) => {
      this.errorMessage = data.message;
    });
  }
}
```

#### 動態數據透過 Resolve
動態數據的用途在於，能否在新路由渲染出來之前就開始獲取。舉例目前範例上對單一 server 查看時，我們事先進行 onInit 階段才跟後端非同步動作進行拿資料而等待 1 秒。如果是在觸發路由當下去獲得資料，確定有資料再從路由提供 server 資訊，最後於 server 元件上進行捕獲。

這樣的設計技巧我們需要創立一個使用 Resolve 解析器的 service 來幫忙處理這件事。就像我們使用守衛那樣但是本身只是解析後端，並不會對路由觸發進行阻礙進出仍會進行渲染組建，但會進行預先加載畫面並等待後端資料回來更新。

- 目前要做的 service 指對單一 server 元件所用，因此在同層目錄下建立 `ng g s server-resolve` 之服務檔案。
- 宣告 Resolve 並實例介面化，這是一個泛型型別，它能包裝你任何的資料進行獲得。同時我們手動定義回傳的型別為 id,name,status，也就是原本 server 要從後端拿到的東西。
- 因為型別大量用到，可用 interface 介面化定義 ServerType 型別起來。
- 參考 [官方對於 resolve 定義](https://angular.tw/api/router/Resolve) 規劃結構。這裡我們要拿的是後端資料所以所有的回傳都會是 ServerType 型別，不管是不是非同步或可訂閱對象。

```ts server-resolve.service.ts
import { ActivatedRouteSnapshot, Resolve, RouterStateSnapshot } from '@angular/router';
import { Observable } from 'rxjs';

interface ServerType { id: number, name: string, status: string }

export class ServerResolveService implements Resolve<ServerType> {
  constructor() { }
  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) : Observable<ServerType> | Promise<ServerType> | ServerType{
    //something here
  }
}
```
- 我們要在 resolve 裡面模擬假裝到後端拿資料，這需要跟 server.service 來提供，因此需要進行 Injectable 以及建構函式上私有實體化。
- 屆時 app-routing 設定那，一但使用本 ServerResolveService 時，會參數提供 id 給我，就能從 server.service 獲得 server 資訊。
- 回到 app.module 註冊一下此 service。

```ts server-resolve.service.ts
import { ServersService } from './../servers.service';
import { Injectable } from '@angular/core';
import { ActivatedRouteSnapshot, Resolve, RouterStateSnapshot } from '@angular/router';
import { Observable } from 'rxjs';

interface ServerType { id: number, name: string, status: string }
@Injectable()
export class ServerResolveService implements Resolve<ServerType> {

  constructor(private serverService: ServersService) { }
  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<ServerType> | Promise<ServerType> | ServerType {
    return this.serverService.getServer(+route.params.id)!;
    //被 TypeScript 認為有 null 可能這裡！強迫它
  }
}
```
```ts app.module.ts
providers: [ServersService, AuthService, AuthGuardService, DeactivateGuardService, ServerResolveService],
```
現在服務做好了也加入倒 app 模組內了，就剩下是誰要去執行這個服務。我們會在對應到只有 server 單一頁面的路由，需要靠這裡去做撈資料的動作。
- 使用`resolve:{...,...}`加入到範圍上的路由位置，透過服務我們能獲得物件資料指定給自訂名稱 server 的值。
- 現在資料會在 route.data.server 內，回到 server 元件，原本的透過後端服務之管道取得的方式取消，改成路由之管道取得方式。
- 我們去訂閱路由的資料，等他跑回來就能拿到資料，剛好結構位置直接對到 this.server 與 data.server。

```ts app-routing.module.ts
const lokiRoutes: Routes = [
  { path: '', component: HomeComponent },
  {
    path: 'users', component: UsersComponent, children: [
      { path: ':id/:name', component: UserComponent }
    ]
  },
  {
    path: 'servers',
    // canActivate: [AuthGuardService],
    canActivateChild: [AuthGuardService],
    component: ServersComponent,
    children: [
      { path: ':id', component: ServerComponent, resolve: { server: ServerResolveService } }, //※重點
      { path: ':id/edit', component: EditServerComponent, canDeactivate: [DeactivateGuardService] }
    ]
  },
  // { path: '404', component: PageNotFoundComponent },
  {
    path: '404', component: PageNotFoundComponent, data: {
      message: "you miss the way...."
    }
  },
  { path: '**', redirectTo: '/404' }
];
```
```ts server.component.ts
ngOnInit() {
  this.route.data.subscribe((data: Data) => {
    this.server = data.server;
  });
  // const id = +this.route.snapshot.params.id;
  // this.server = this.serversService.getServer(id);

  // this.route.params.subscribe((prm: Params) => {
  //   this.server = this.serversService.getServer(+prm.id);
  // });
}
```

## 網址策略
當你在本機環境開發很爽的時候，小心上傳到實體網頁伺服器會發現一個問題。在本地開發時由 Angular 去控制每個 URL 目錄是對應到哪個位置，但實體網頁伺服器是自己去尋找每個目錄下的 index.html 作為 URL 路徑規劃，這部分你的 Angular 不會有這些東西，你只有一個 index.html 跟一狗包的 Angular 應用。如果你可能發生了這樣問題，你的 Angular 無法從 clict 端去解析位置，試試看這個方法，來到 app-routing 模組啟用此功能。

```ts app-routing.module.ts
@NgModule({
  imports: [
    // RouterModule.forRoot(lokiRoutes)
    RouterModule.forRoot(lokiRoutes, { useHash: true })
  ],
  exports: [RouterModule]
})
```
預設值為 false，一旦開啟這個功能，你會發現所有的網站跟目錄都會多一個#，這能確保告知實體伺服器忽略#以後的 URL 解析，因為#本身對瀏覽器來說是標記不是網址目錄的一部分。如此一來就不會讓實體伺服器產生找不到實體 index 檔案的問題。

# Observable 可觀察物件
可觀察物件對在應用的各個部分之間傳遞訊息提供了支援。 它們在 Angular 中頻繁使用，並且推薦把它們用於事件處理、非同步程式設計以及處理多個值等場景。

觀察者（Observer）模式是一個軟體設計模式，它有一個物件，稱之為主體 Subject，負責維護一個依賴項（稱之為觀察者 Observer）的列表，並且在狀態變化時自動通知它們。 該模式和發佈/訂閱模式非常相似（但不完全一樣）。

Observable 可以被認為是一個 Data Sources，在 Angular 專案中，一個 Observable 就是從第三方 package (RxJS 函式庫）進行導入的物件。所以我們會有一個觀察者 Observer 並在時間線上讓 Observable 或 Data package 資料包由可觀察對象發出多個事件。

你可以連結一個按鈕，每當按下按鈕時 Data package 資料包就會發送一個事件給像是 Http Server 之類的獲得一個 http request，而當獲得 response 回傳時將資料包夾帶回來，這就是所謂的 subscribe 訂閱功能。

你可以透過三種方式來處理資料包可能，包含：
- Handle Data
- Handle Error
- Handle Completion

你可以控制當你收到資料包當下該做什麼事或是獲得什麼錯誤。而 Observable 結束時會發生什麼。Observable 拿來處理一些非同步任務，因為這裡所有的 Data Sources 或 Http 請求都是非同步作業。也許在 ES6 階段你學過 callback 或 promises，而 Observable 是另一種不同處理方法，與使用 Angular 具備優勢所提供的 Observable 有不同的選擇方式。

補充 Observable 來自於 RxJS 函式庫，透過 CLI 建立則會自動加入，如果手動環境沒有的需要自行安裝 [RxJS](https://www.npmjs.com/package/rxjs)

```shell
npm install rxjs
```

## 示範與前置準備
本篇的起始素材放置於 GitHub 底下提供使用，使用資料目錄 lokiSecond 作為初始環境。下載請記得 npm install 初始化環境。

>[Github download](https://github.com/summer10920/angularTraining) at lokiObservable-start Folder

素材本身提供簡單的路由頁面分為 Home,User1,User2。我們到 Home.component.ts 使用一下來自 RxJS 函式庫的內建 Observable 工具 Interval()，你可以設定時間並傳入一個數字，他會每秒觸發並計數。透過 subscribe 訂閱可觀察物件，

> 參閱 [RJS - interval](https://rxjs.dev/api/index/function/interval)

```ts home.component.ts
import { Component, OnInit } from '@angular/core';
import { interval } from 'rxjs'; //※重點

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html',
  styleUrls: ['./home.component.css']
})
export class HomeComponent implements OnInit {

  constructor() { }

  ngOnInit() {
    interval(1000).subscribe(count => console.log(count)); //※重點
  }

}
```

此如果試著離開 home 透過路由到其他頁再回來，會發現 Observable 不會因為銷毀 DOM 而停止訂閱。因此你需要銷毀當下取消訂閱。記住訂閱的屬性，其強型別為 Subscription。

```ts home.component.ts
import { Component, OnDestroy, OnInit } from '@angular/core';
import { interval, Subscription } from 'rxjs'; //※重點

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html',
  styleUrls: ['./home.component.css']
})
export class HomeComponent implements OnInit, OnDestroy {

  obsSubscriptionKey!: Subscription; //記住這個訂閱

  constructor() { }

  ngOnInit() {
    this.obsSubscriptionKey = interval(1000).subscribe(count => console.log(count)); //※重點
  }

  ngOnDestroy(): void {
    this.obsSubscriptionKey.unsubscribe(); //取消訂閱
  }
}
```
這是 RxJS 內建的 Observable，下一節我們來建構自訂的 Observable。

## 建構自訂的 Observable
參考以上同需求但使用自訂的，透過 new Observable() 並賦予觀察者為參數，使用觀察者的 next 來傳遞下一次的值。而訂閱與取消與前一節相同。

```ts home.component.ts
import { Component, OnDestroy, OnInit } from '@angular/core';
import { interval, Observable, Subscription } from 'rxjs'; //※重點

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html',
  styleUrls: ['./home.component.css']
})
export class HomeComponent implements OnInit, OnDestroy {

  private obsSubscriptionKey!: Subscription; //記住這個訂閱

  constructor() { }

  ngOnInit() {
    // this.obsSubscriptionKey = interval(1000).subscribe(count => console.log(count)); 
    const customIntervalObs = new Observable(observer => { //※重點
      let count = 0;
      setInterval(() => {  //這是 JS 不是 RxJS
        observer.next(count);
        count++;
      }, 1000);
    });

    this.obsSubscriptionKey = customIntervalObs.subscribe((res) => console.log(res));
  }

  ngOnDestroy(): void {
    this.obsSubscriptionKey.unsubscribe(); //取消訂閱
  }
}
```

### 錯誤與完成
這裡介紹錯誤與完成如何觸發，整個其時跟 ES6 的 Promise 觀念雷同。

> 自 RxJS 6.4 開始錯誤與完成的寫法有改動，參閱 [RxJS - Subscribe Arguments](https://rxjs.dev/deprecations/subscribe-arguments)

```ts home.component.ts
import { Component, OnDestroy, OnInit } from '@angular/core';
import { interval, Observable, Subscription } from 'rxjs'; //※重點

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html',
  styleUrls: ['./home.component.css']
})
export class HomeComponent implements OnInit, OnDestroy {

  private obsSubscriptionKey!: Subscription; //記住這個訂閱

  constructor() { }

  ngOnInit() {
    // this.obsSubscriptionKey = interval(1000).subscribe(count => console.log(count)); 
    const customIntervalObs = new Observable(observer => {
      let count = 0;
      setInterval(() => {  //這是 JS 不是 RxJS
        observer.next(count);
        if (count === 2)  //測試 error 要註解，不然跑不到 3
          observer.complete();
        if (count > 3)
          observer.error(new Error('Count is 3!')); //※重點 建立錯誤事件與資料包
        count++;
      }, 1000);
    });

    this.obsSubscriptionKey = customIntervalObs.subscribe({
      next: res => console.log(res),
      error: err => console.error(err),
      complete: () => console.info('complete')
    });
  }

  ngOnDestroy(): void {
    this.obsSubscriptionKey.unsubscribe(); //取消訂閱
  }
}
```

總結一下，絕大部分你不會自己創建一個自訂可觀察對象。而是 Angular 提供的 Hook 之中（例如路由）都會用到本身提供的 Observable 與訂閱。

## RxJS 運算子
Angular 整合 RxJS 不少運算子，等同於 JS 領域那些運算子。本節會使用 RxJS 提供的 map 以及 Pipe 來示範。map 本身同 Array.map 觀念，能將連續的資料做映射處理回傳。而 pipe 是管道能在傳遞過程中進行轉譯處理。

假設我們希望 console 從 0,1,2 變成 Round 1,Round 2,Round 3。你可能會直接寫在 console.log 處。

```ts home.component.ts
this.obsSubscriptionKey = customIntervalObs.subscribe({
  next: res => console.log(`Round ${res+1}`), //※重點
  error: err => console.error(err),
  complete: () => console.info('complete')
});
```
事實上這樣寫不好。如果可以能否在訂閱當下時就能做文字變化。

- 首先需要用到 pipe，這是 RxJS 提供的運算子，每個 observable 都有 pipe() 可用。 
- 再來是透過 map 將我們每次透過訂閱獲得的資料做映射處理並 return 給 pipe

```ts home.component.ts
//...
import { map } from 'rxjs/operators';
//...

export class HomeComponent implements OnInit, OnDestroy {
  //...
  ngOnInit() {
    //...
    this.obsSubscriptionKey = customIntervalObs
      .pipe( //※重點
        map( //※重點
          (data: any) => 'Round ' + (data + 1)
        )
      )
      .subscribe({
        next: res => console.log(res),
        error: err => console.error(err),
        complete: () => console.info('complete')
      });
      //...
  }
  //...
}
```

或者你可以使用 filter 來過濾大於 0 的 data 才輸出。pipe 可以多個工作。

```ts home.component.ts
//...
import { map } from 'rxjs/operators';
//...

export class HomeComponent implements OnInit, OnDestroy {
  //...
  ngOnInit() {
    //...
    this.obsSubscriptionKey = customIntervalObs
      .pipe(
        filter( //※重點
          (data: any) => data > 0
        ),
        map(
          (data: any) => 'Round ' + (data + 1)
        )
      )
      .subscribe({
        next: res => console.log(res),
        error: err => console.error(err),
        complete: () => console.info('complete')
      });
      //...
  }
  //...
}
```

## Subjects 主題
待補 - 
<!-- https://www.udemy.com/course/the-complete-guide-to-angular-2/learn/lecture/14466304#content -->

# Forms 表單
用表單處理使用者輸入是許多常見應用的基礎功能。 應用透過表單來讓使用者登入、修改個人檔案、輸入敏感資訊以及執行各種資料輸入任務。

Angular 提供了兩種不同的方法來透過表單處理使用者輸入：響應式表單和範本驅動表單。兩者都從檢視中捕獲使用者輸入事件、驗證使用者輸入、建立表單模型、修改資料模型，並提供追蹤這些更改的途徑。

## Template-driven forms 範本驅動表單 TD
範本驅動表單依賴範本中的指令來建立和操作底層的物件模型。它們對於嚮應用新增一個簡單的表單非常有用，比如電子郵件列表登錄檔單。它們很容易新增到應用中，但在擴充套件性方面不如響應式表單。如果你有可以只在範本中管理的非常基本的表單需求和邏輯，那麼範本驅動表單就很合適。

### 示範與前置準備
本篇的起始素材放置於 GitHub 底下提供使用，使用資料目錄 lokiSecond 作為初始環境。下載請記得 npm install 初始化環境。

>[Github download](https://github.com/summer10920/angularTraining) at lokiFormTD-start Folder

這是一個簡單的表格，目前沒有任何 sumbit 行為，接下來示範如何 TD 來完成表單提交，透過 Angular 來驅動表單。

如果你是使用 CLI 來完成初始化，CLI 幫你添加以下 import，這是表單 TD 會用到的表單模組。

```ts app.module.ts
import { FormsModule } from '@angular/forms';//※重點
//...

@NgModule({
  //...
  imports: [
    BrowserModule,
    FormsModule, //※重點
  ],
  //...
})
```

### 使用參數來訪問表單
Angular 不會自動偵測你的表單那些表單元素是否要協助處理，你需要主動提供類似 ngModel 的數據綁訂。這裡不需要使用`[(ngModel)]`直接使用屬性`ngModel`就好，以及提供 name 屬性值。

```html app.component.html
<!-- ... -->
<input
  type="text"
  id="username"
  class="form-control"
  ngModel
  name="username"
>
<!-- ... -->
<input
  type="email"
  id="email"
  class="form-control"
  ngModel
  name="email"
>
<!-- ... -->
<select
  id="secret"
  class="form-control"
  ngModel
  name="secret"
>
  <!-- option ... -->
</select>
<!-- ... -->
```

接著我們需要一個方法來進行作業處理，同時在範本的 form 元素上去綁定這個提交事件。同時可利用本地變數的方式 (#name)，將自己當作參數提交出去，可觀察 console 結果為合。

```html app.component.html
<form
  (ngSubmit)="onSubmit(myForm)"
  #myForm
>
```
```ts app.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  suggestUserName() {
    const suggestedName = 'Superuser';
  }

  onSubmit(form: HTMLFormElement) {
    console.log(form);
  }
}
```

實際上還有更好的默認方法，就是讓 Angular 能自動對這個表單捕獲有設定 ngModel 屬性的表單元素。就是將本地變數屬姓名不動，多添加值為 ngForm。 這樣就能用 ngForm 來捕獲表單內的資料。

```html app.component.html
<form
  (ngSubmit)="onSubmit(myForm)"
  #myForm="ngForm"
>
```
```ts app.component.ts
import { Component } from '@angular/core';
import { NgForm } from '@angular/forms';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  suggestUserName() {
    const suggestedName = 'Superuser';
  }

  onSubmit(form: NgForm) {
    // console.log(form);
    console.log(form.value);

  }
}
```

你可以研究 ngForm 鎖提供的變數除了 value 還提供不少好東西。包含像是元素類型、是否 dirty（已填）, disabled, enabled, errors, valid... 等等，這些都是能拿來做更好的用戶體驗。之後再細談示範。

### 使用 @ViewChild 訪問表單
這裡有另一個方式來訪問表單，還記得我們能透過`@ViewChild`來訪問本地變數嗎？保留上一做法做比較：

```html app.component.html
<!-- <form
  (ngSubmit)="onSubmit(myForm)"
  #myForm="ngForm"
> -->
<form
  (ngSubmit)="onSubmit()"
  #myForm="ngForm"
>
```
```ts app.component.ts
import { Component, ViewChild } from '@angular/core';
import { NgForm } from '@angular/forms';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  @ViewChild('myForm') viewForm!: NgForm;
  suggestUserName() {
    const suggestedName = 'Superuser';
  }
  // onSubmit(form: NgForm) {
  //   console.log(form.value);
  // }
  onSubmit() {
    console.log(this.viewForm.value);
  }
}
```

我們可以不靠參數，直接從 TS 去訪問範本的本地參數來捕捉 ngForm 並提供強型別。

### 驗證
你可以透過 HTML5 的 required 屬性添加，讓 Angular 自動配置確保表單提交是否無效以及檢查這些欄位是否有效輸入。而 mail 部分還能添加屬性 mail 讓 Angular 自動判斷 email 格式（也就是否有@符號而已）。同時可發現 Angular 會自動樣式表的的 class 名稱 ng-dirty, ng-valid 或 ng-invalid 來讓我們做視覺上的差異設計。

更多驗證器的功能請參考 [官方文件](https://angular.tw/api/forms/Validator)

> 您可能還想啟用 HTML5 驗證（默認情況下，Angular 禁用它）。您可以通過將 添加 ngNativeValidate  到模板中的控件來執行此操作。

驗證不會主動阻擋提交，我們可以透過對 sumbit 按鈕規劃一個 disable 判斷，利用本地變數的 ngForm.valid 值來確保 disabled 是否啟用。

```html app.component.html
<button
  class="btn btn-primary"
  type="submit"
  [disabled]="!myForm.valid"
>Submit</button>
```

你還能改善驗證時的 CSS 樣式，可多選擇到當有碰過的欄位但驗證錯誤的才做樣式效果。這些 css 的 class 由 Angular 自動生成。

```css app.component.css
form .ng-invalid.ng-touched {
  border: 1px solid red;
}
```

也可多添加提示字利用`*ngIf`來完成，對驗證時反應的提示欄位 p 添加本地變數且必需其指定值為 ngModel。

```html app.component.html
<div class="form-group">
  <label for="email">Mail</label>
  <input
    type="email"
    id="email"
    class="form-control"
    ngModel
    name="email"
    required
    email
    #myMail="ngModel"
  >
</div>
<p *ngIf="!myMail.valid&&myMail.dirty">Please input valid value</p>
```
至於 select 元素要如何綁訂預設值，我們可以透過雙向綁訂指向到 TS 內的屬性（你也可以單向）。

```html app.component.html
<select
  id="secret"
  class="form-control"
  ngModel
  name="secret"
  required
  [(ngModel)]="defaultAns" 
>
```
```ts app.component.ts
export class AppComponent {
  @ViewChild('myForm') viewForm!: NgForm;
  defaultAns = 'pet'; //※重點
  
  suggestUserName() {
    const suggestedName = 'Superuser';
  }
  // onSubmit(form: NgForm) {
  //   console.log(form.value);
  // }
  onSubmit() {
    console.log(this.viewForm.value);
  }
}
```

看樣子`[(ngModel)]`可以拿來做為表單元素的值，因此你可以當作任何表單元素的輸入。可檢查 sumbit 之後的 console 是否捕獲到這個 textarea 輸入或預設值。

```html app.component.html
<textarea
  name="userAns"
  rows="3"
  [(ngModel)]="answer"
></textarea>
```
```ts app.component.ts
export class AppComponent {
  @ViewChild('myForm') viewForm!: NgForm;
  defaultAns = 'pet'; 
  answer='your answer'; //※重點
  
  suggestUserName() {
    const suggestedName = 'Superuser';
  }
  // onSubmit(form: NgForm) {
  //   console.log(form.value);
  // }
  onSubmit() {
    console.log(this.viewForm.value);
  }
}
```

### ngModelGroup 群組化
回到一開始，我們知道如果要將指定欄位給範本驅動 TD 使用，你必需第一步手動對指定的欄位添加屬性 ngModel 才能咬到這些元素。事實上你可以把在某父層元件設定 ngModelGroup 弄成群組化。Angular 會試著找到這些下層持有 ngModel 屬性的弄成同一層物件，使得你的資料結構方便整理。

```html app.component.html
<div id="user-data" ngModelGroup="userData"> <!-- ※重點 -->
  <div class="form-group">
    <label for="username">Username</label>
    <input
      type="text"
      id="username"
      class="form-control"
      ngModel
      name="username"
      required
    >
  </div>
  <button
    class="btn btn-secondary"
    type="button"
  >Suggest an Username</button>
  <div class="form-group">
    <label for="email">Mail</label>
    <input
      type="email"
      id="email"
      class="form-control"
      ngModel
      name="email"
      required
      email
      #myMail="ngModel"
    >
  </div>
  <p *ngIf="!myMail.valid&&myMail.dirty">Please input valid value</p>
</div>
```

同時驗證功能也會在這個 `div#user-data` 作用，因此畫面上只要這個群組下只要其中一個驗證錯誤會是這個 div#user-data 驗證錯誤。與 ngModel 有一樣的控制驗證，也能用本地變數操作提示字段的設計。

```html app.component.html
<div
  id="user-data"
  ngModelGroup="userData"
  #myUserData="ngModelGroup"
>...</div>
<p *ngIf="!myUserData.valid&&myUserData.dirty">Please check user and mail</p>
```

### radio 不支援驗證
我們在畫面上多設計一個 radio 並探討如何控制它。先來到 ts 這裡初始屬性值。並在試著的位置上貼上 html

```ts app.component.ts
genders = ['man', 'woman']; //※重點
```
```html app.component.html
<div class="radio" *ngFor="let item of genders">
  <label>
    <input type="radio" value="item" name="gender"> {{item}}
  </label>
</div>
```

然而 radio 這樣的表單元素對於 required 無法做到驗證，特別告知一下但你可以設定預設值。

```html app.component.html
<input type="radio" value="item" name="gender" [checked]="item==='woman'"> {{item}}
```

如果我們要列入 ngModel 方便 TD 捕獲時，會發現原本的 checked 失效了，這是由於其實本來有選中，因為我們指定了 ngModel 未提供任何值，因此 angular 根據沒有值而幫我們取消了。所以你應該這樣寫

```html app.component.html
<input type="radio" [value]="item" name="gender" ngModel="woman"> {{item}}
```

### 自動填入與重置
素材上還有一個沒作用的按鈕，我們拿來綁定一個事件，當我們按下這個按鈕能幫我們把所有欄位填上預設值。

```html app.component.html
<button class="btn btn-secondary" type="button" (click)="suggestUserName()">Suggest an Username</button>
```
我們可以利用剛剛做好的秘密通道，透過`@ViewChild`而產出的 viewForm 可用屬性，獲得的是一個物件資料，就反向塞回去。

```ts app.component.ts
export class AppComponent {
  @ViewChild('myForm') viewForm!: NgForm;
  defaultAns = 'pet';
  answer = 'your answer';
  genders = ['man', 'woman']; //※重點

  suggestUserName() {
    const suggestedName = suggestedName;
    const defaultData = {
      gender: "man",
      secret: "pet",
      userAns: "your sky",
      userData: { username: 'super', email: 'aa@aa' }
    };
    this.viewForm.setValue(defaultData);
  }
  onSubmit() {
    console.log(this.viewForm.value);
  }
}
```
但如果只是想局部或是一個欄位呢？你可以改用 patchValue。

```ts app.component.ts
suggestUserName() {
  const suggestedName = 'Superuser';
  this.viewForm.form.patchValue({
    userData: { username: suggestedName }
  });
}
```

至於重置的方式為`reset()`，我們把這個代碼放置在提交後執行。
```ts app.component.ts
onSubmit() {
  console.log(this.viewForm.value);
  this.viewForm.reset();
}
```

## Reactive forms 響應式表單
兩者最大差異在於一個是 html 的範本來設計表單，一個是 TypeScript 來設計表單。響應式表單提供對底層表單物件模型直接、顯式的訪問。它們與範本驅動表單相比，更加健壯：它們的可擴充套件性、可複用性和可測試性都更高。如果表單是你的應用程式的關鍵部分，或者你已經在使用響應式表單來建構應用，那就使用響應式表單。

### 示範與前置準備
本篇的起始素材放置於 GitHub 底下提供使用，使用資料目錄 lokiSecond 作為初始環境。下載請記得 npm install 初始化環境。

>[Github download](https://github.com/summer10920/angularTraining) at lokiFormReactive-start Folder

這是一個簡單的表格，目前沒有任何 submit 行為，接下來示範如何 Reactive 來完成表單提交。而與 TD 不同，我們不需要 FormsModule 模組，但我們需要 ReactiveFormsModule 來實施表格。

```ts app.module.ts
import { ReactiveFormsModule } from '@angular/forms';//※重點
//...

@NgModule({
  //...
  imports: [
    BrowserModule,
    ReactiveFormsModule, //※重點
  ],
  //...
})
```
然而 TD 表格使用的是 ngForm，在 Reactive 表格則是使用 FormGroup 模組，也一併設定先。

```ts app.component.ts
import { Component } from '@angular/core';
import { FormGroup } from '@angular/forms';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  genders = ['male', 'female'];
  myForm!: FormGroup;
}
```

https://www.udemy.com/course/the-complete-guide-to-angular-2/learn/lecture/6656504#overview

### 同步 HTML 表單
我們需要讓 Angular 知道是哪個 HTML 需要同步給 TypeScript 處理，從範本中對 form 原入添加屬性綁定 FormGroup，並指定給你在 typeScript 內的持有 FormGroup 型別的相同變數。接著還要指定那些表單元素持有 formControlName 屬性中相同的屬性名。 

```html app.component.html<div class="container">
<div class="container">
  <div class="row">
    <div class="col">
      <form [formGroup]="myForm">
        <div class="form-group">
          <label for="username">Username</label>
          <input type="text" id="username" class="form-control" formControlName="username">
          <!-- 
            你可以使用綁定，但這裡是字串不是 ts 的屬性變數
            [formControlName]="'username'"
          -->
        </div>
        <div class="form-group">
          <label for="email">email</label>
          <input type="text" id="email" class="form-control" formControlName="email">
        </div>
        <div class="radio" *ngFor="let gender of genders">
          <label>
            <input type="radio" [value]="gender" formControlName="gender">{{ gender }}</label>
        </div>
        <button class="btn btn-primary" type="submit">Submit</button>
      </form>
    </div>
  </div>
</div>
```
```ts app.component.ts
import { Component, OnInit } from '@angular/core';
import { FormControl, FormGroup } from '@angular/forms';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {
  genders = ['male', 'female'];
  myForm!: FormGroup;

  ngOnInit() {
    this.myForm = new FormGroup({
      'username': new FormControl(null),
      'email': new FormControl(null),
      'gender': new FormControl('male')
    });
  }
}
```

接著 submit 的事件綁定給 form 元素去執行 typeScript 內的方法，而這裡不用傳遞參數或任何設定，因為資料本來就在 typescript 那裏。

```html app.component.html
<form [formGroup]="myForm" (ngSubmit)="onSubmit()">
```
```ts app.component.ts
onSubmit() {
  // console.log(this.myForm);
  console.log(this.myForm.value);

}
```

### 驗證
在 TD 作法，使用 HTML 的 required 屬性就能開啟驗證，但在 Reactive 這裡不受作用，因為表格輸入綁定方式是根據你的指令從 TypeScript 那裏同步配置給範本上，所以為什麼每個欄位元素都要 formControl 宣告 new 建構函式出來。所以你必須要從 TS 那裏透過參數去調整每個表單控制。
 
在 formControl 的參數，第一個為預設值，第二個為驗證器。驗證器需要依賴內建模組並使用`Validators.required`。當然你可以使用陣列填入第二參數，代表這個表單控制有多個驗證都要執行。舉例 email 除了必填也要符合 email 格式。

```ts app.component.ts
ngOnInit() {
  this.myForm = new FormGroup({
    'username': new FormControl(null, Validators.required),
    'email': new FormControl(null, [Validators.required, Validators.email]),
    'gender': new FormControl('male')
  });
}
```
>目前已經會自動提供驗證所需的樣式 class 名稱，而一樣 submit 當下不會幫你阻擋。

我們能透過 GET 函式如`formGroup.get(key).*`來獲得特定資訊，例如透過`myForm.get('username').valid`與`myForm.get('username').touched`來控制提示驗證是否出現。

```html app.component.html
<div class="form-group">
  <label for="username">Username</label>
  <input
    type="text"
    id="username"
    class="form-control"
    formControlName="username"
  >
  <p *ngIf="!myForm.get('username')?.valid && myForm.get('username')?.touched">
    please input a value
  </p>
</div>
```

>這裡使用？符號是因為 valid 可能型別上為 null。

同樣能改善驗證時的 CSS 樣式，可多選擇到當有碰過的欄位但驗證錯誤的才做樣式效果。這些 css 的 class 也由 Angular 自動生成且 class 命名相同。

```css app.component.css
form .ng-invalid.ng-touched {
  border: 1px solid red;
}
```

### FormGroup 嵌套群組化
在 TD 表單上，我們使用過 ngModelGroup 群組化，而 Reactive 這裡是利用兩層 FormGroup 來做群組化。舉例我們將 username 與 email 群組起來。

```ts app.component.ts
ngOnInit() {
  this.myForm = new FormGroup({
    'userData': new FormGroup({
      'username': new FormControl(null, Validators.required),
      'email': new FormControl(null, [Validators.required, Validators.email]),
    }),
    'gender': new FormControl('male')
  });
}
```

但目前有錯誤訊息找不到 username 的控制對象因為沒有`userData>*`的位置，所以同步的範本那裏要跟著修改。找到或規劃上層的 div 來扮演 userData。然後現在所有`get()`位置的 username 與 email 的字串變成`userData.username`與`userData.email`位置。

```html app.component.html
<div formGroupName="userData">
  <div class="form-group">
    <label for="username">Username</label>
    <input
      type="text"
      id="username"
      class="form-control"
      formControlName="username"
    >
    <p *ngIf="!myForm.get('userData.username')?.valid && myForm.get('userData.username')?.touched">
      please input a value
    </p>
  </div>
  <div class="form-group">
    <label for="email">email</label>
    <input
      type="text"
      id="email"
      class="form-control"
      formControlName="email"
    >
  </div>
</div>
```

### FormArray 表單控制元素陣列
如果表單欄位是動態增加，`new FormArray([])`是很適合的用途，你可以一開始就預設塞入一些 formControl 例如`new FormArray([new FormControl()])`這樣，可單一可多數。接著來示範如何去用到這個 FormArray();

- 素材增加按鈕並事件綁定觸發一個動作 `(click)="onAddlike()`。
- 這個`onAddlike()`方法是，會幫我們對 FormArray 塞入一個新的 FormControl 且該 FormControl 會設定必填驗證
- 範本上會有一個群組為`formArrayName="likes"`指定，內部元素會跑回圈。
- 內部元素是根據多少元素來執行批次輸出，要知道多少元素就必須依賴方法`getControls()`來獲得。
- `getControls()`能透過 get('likes').controls 回傳給我們在 likes 裡面有那些 control。
- 這些 control 也需要指定 formControlName 為何，但陣列只需要 index 為名稱，因此利用迴圈來提供 index 為 i

```html app.component.html
<button type="button" (click)="onAddlike()">Add like felid</button>
<div formArrayName="likes">
  <div *ngFor="let item of getControls();let i = index">
    <input
      type="text"
      [formControlName]="i"
    >
  </div>
</div>
```
```ts app.component.ts
export class AppComponent implements OnInit {
  genders = ['male', 'female'];
  myForm!: FormGroup;

  ngOnInit() {
    this.myForm = new FormGroup({
      'userData': new FormGroup({
        'username': new FormControl(null, Validators.required),
        'email': new FormControl(null, [Validators.required, Validators.email]),
      }),
      'gender': new FormControl('male'),
      'likes': new FormArray([]) //※重點
    });
  }

  onSubmit() {
    console.log(this.myForm.value);
  }
  onAddlike() { //※重點
    const newCtl = new FormControl(null, Validators.required);

    //※重點 - 透過 GET 找到這個 FormArray，並給予結果為 FormArray 型別
    (<FormArray>this.myForm.get('likes')).push(newCtl);
  }
  getControls() { //※重點
    return (<FormArray>this.myForm.get('likes')).controls;
  }
}
```

>formArray 本身也算是一種 FormGroup，驗證的判斷是一同整個群組下做反應的。
  
### 自訂驗證
目前為止的驗證都來自內建的 required 或 mail，如果想要自訂該如何做，這裡示範假設有指定的用戶名不想讓人輸入使用的客製化驗種。

- 規劃需驗證的資料陣列，這裡為 lockUserName 並指定兩個名字想鎖住。
- 創造一個方法，提供 FormControl 為參數，屆時會跟本區域內的 lockUserName 做判斷，如果要鎖住需要提供`{s:string:b:boolean}`這樣的東西，否則為 null
- 來到想驗證的欄位，對 new 函式參數添加這個你自訂的驗證器，變成`[Validators.required, this.checkLuckName.bind(this)]`。bind 是因為 JS 封閉空間觀念要克服。
- 最後測試驗證一下

```ts component.ts
export class AppComponent implements OnInit {
  genders = ['male', 'female'];
  myForm!: FormGroup;
  lockUserName = ['Loki', 'Max']; //※重點

  ngOnInit() {
    this.myForm = new FormGroup({
      'userData': new FormGroup({
        //※重點 -bind 進去才能在該函式內使用 this 找到 luckUserName
        'username': new FormControl(null, [Validators.required, this.checkLuckName.bind(this)]),
        'email': new FormControl(null, [Validators.required, Validators.email]),
      }),
      'gender': new FormControl('male'),
      'likes': new FormArray([])
    });
  }

  onSubmit() {
    console.log(this.myForm.value);
  }
  onAddlike() {
    const newCtl = new FormControl(null, Validators.required);
    (<FormArray>this.myForm.get('likes')).push(newCtl);
  }
  getControls() {
    return (<FormArray>this.myForm.get('likes')).controls;
  }
  //※重點 - 非強迫，可指定 return 的 強型別
  checkLuckName(ctl: FormControl): { [s: string]: boolean } | null {
    // 找到會提供該位置索引數字，當找不到時則為-1
    if (this.lockUserName.indexOf(ctl.value) !== -1) return { 'nameLuck': true };
    return null;
  }
}
```

如果要除錯這部分想知道每個表單欄位到底在進行什麼驗證，可透過 console 檢查這個大 FromGroup 每一層 error 或 Controls 內的任何一個對象 error。下列是幫你找到這個 username 的錯誤資訊，而驗證就是檢查這個底下的 error 是否非 null。如果感到好奇，你可以嘗試其他欄位打內建的錯誤會獲得甚麼樣的 error，答案會是`{'required':true}`。

```ts app.component.ts
onSubmit() {
  // console.log(this.myForm.value);
  // console.log(this.myForm);

  // console.log(this.myForm.controls['userData'].get('username')?.errors);
    console.log(this.myForm.get('userData.username')?.errors); // 同上
}
```

所以你可以利用這個 errors 位置去控制範本任何一處作為提示文字的判斷結果。

### 非同步自訂驗證
假設你的驗證功能來自於後端，你不會立即反映，我們需要等待非同步後結果才能告知驗證是否通過。這裡使用 Promise 與 setTimeOut 來模擬 2 秒後的動作。

- 規劃方法並參考自訂驗證做法，它會經過 promise 或是 Observable 來回傳 resolve 或 reject。而回傳的型別屬於 AsyncValidatorFn
- 綁定此自訂非同步驗證給 email 第三個參數

```ts app.component.ts
import { FormArray, FormControl, FormGroup, Validators, AsyncValidatorFn } from '@angular/forms'; //※重點
import { Observable } from 'rxjs'; 

//...

export class AppComponent implements OnInit {

//...

  ngOnInit() {
    this.myForm = new FormGroup({
      'userData': new FormGroup({
        'username': new FormControl(null, [Validators.required, this.checkLuckName.bind(this)]),
        //※重點 -第三個參數作為非同步驗證，因回傳的資料型別為 AsyncValidatorFn，注意先宣告
        'email': new FormControl(null, [Validators.required, Validators.email], <AsyncValidatorFn>this.checkLuckMailAsync),
      }),
      'gender': new FormControl('male'),
      'likes': new FormArray([])
    });

  checkLuckMailAsync(ctl: FormControl): Promise<any> | Observable<any> {
    const promise = new Promise((res, rej) => {
      setTimeout(() => {
        if (ctl.value === 'a@a') res({ 'emailLuck': true });
        else res(null);
        // 這裡不要用 rej(null)，避免發生 error 而中斷 valid 的後續動作
      }, 2000);
    });
    return promise;
  }
}
```

### 訂閱 FormGroup 的變化
我們可以對 FormGroup 底下的 valueChanges 與 statusChanges 是可觀察的對象，能進行進行訂閱做事何用途，這裡寫在 onInit 測試示範。

```ts app.component.ts
ngOnInit() {
  this.myForm = new FormGroup({
    'userData': new FormGroup({
      'username': new FormControl(null, [Validators.required, this.checkLuckName.bind(this)]),
      'email': new FormControl(null, [Validators.required, Validators.email], <AsyncValidatorFn>this.checkLuckMailAsync),
    }),
    'gender': new FormControl('male'),
    'likes': new FormArray([])
  });

  this.myForm.valueChanges.subscribe(val => console.log(val));  //訂閱 FormGrup 其中當有值變化時
  this.myForm.statusChanges.subscribe(val => console.log(val));  //訂閱 FormGrup 其中當有驗證結果變化時
}
```

### FormGroup 的資料更改與清除
在 FormGroup 模組底下，提供了 setValue 能複寫整個資料，這用於 onInit 階段進行整個初始化欄位預設值很有用。或者想局部複寫更新也可以，透過 patchValue 使用。可跟 setValue 並存無所謂只是刷兩次

```ts app.component.ts
  ngOnInit() {
    this.myForm = new FormGroup({
      'userData': new FormGroup({
        'username': new FormControl(null, [Validators.required, this.checkLuckName.bind(this)]),
        'email': new FormControl(null, [Validators.required, Validators.email], <AsyncValidatorFn>this.checkLuckMailAsync),
      }),
      'gender': new FormControl('male'),
      'likes': new FormArray([])
    });

    this.myForm.valueChanges.subscribe(val => console.log(val));  //訂閱 FormGrup 其中當有值變化時
    this.myForm.statusChanges.subscribe(val => console.log(val));  //訂閱 FormGrup 其中當有驗證結果變化時

    this.myForm.patchValue({
      userData: {
        username: 'July',
        email: 'cc@cc'
      },
      gender: 'female',
      likes: []
    });
    this.myForm.patchValue({
      userData: {
        username: 'Marry',
        email: 'dd@cc'
      }
    });
  }
```

最後講到 reset 部分，我們可以放到 sumbit 階段作業。

```ts app.component.ts
onSubmit() {
  console.log(this.myForm.get('userData.username')?.errors);
  this.myForm.reset(); // reset
}
```

### 小節練習
待補
<!-- https://www.udemy.com/course/the-complete-guide-to-angular-2/learn/lecture/12982454#overview -->

# Pipe 管道
管道是一種內建的特性能在轉換 template 過程當中進行輸出，出現在進行同步或非同步的資料處理之中。舉例來說你持有`username='Max'`這樣的屬性與值，你會用字串插值方式在範本上使用`<p>{{username}}</p>`。然而你想在該範本上全大寫顯示而不是先多準備新變數來儲存大寫後的字串值。這樣的需求就能使用內建管道來完成，範本上改使用`<p>{{username | uppercase}}</p>`就能在插入當下搭配 pipe 的 uppercase 轉大寫，管道能改變你原本的值做轉換，本節將介紹一些內建管道以及如何自訂管道。

## 示範與前置準備
本篇的起始素材放置於 GitHub 底下提供使用，使用資料目錄 lokiPipe 作為初始環境。下載請記得 npm install 初始化環境。

>[Github download](https://github.com/summer10920/angularTraining) at lokiPipe-start Folder

- 素材內可看到提供一些 server 陣列並透過迴圈方式輸出到畫面上。
- 已設計一組方法作為提供 ngClass 的屬性綁定的結果。ngClass 能提供物件資料內含 Boolean 值，ngClass 會根據哪個為 true 來提供該 class 名稱。因此方法內會提供全部 class 名稱並搭配 boolean 來要求 ngClass 自己判斷哪個 class 要添加到 CSS。

**uppercase**
現在我們想嘗試對 instanceType 所顯示的資料轉成大寫，你只要到範本上使用 Pipe 內建的 uppercase 就能達到，你不需要去在 TS 內規畫任何屬性本身變化或改變任何值。

```html app.component.html
<strong>{{ server.name }}</strong> | {{ server.instanceType| uppercase }} | {{ server.started }}
```

**date**
started 所顯示的資料沒有處理過，因此日期格式為`new Date()`預設 ISO 時間表示法。目前`{{ server.started }}`輸出如下：
```txt
Mon Aug 09 1920 00:00:00 GMT+0800 （台北標準時間）
```
而我們能透過 pipe 的 data 來改善，調整`{{ server.started | data}}`後輸出如下：
```txt
Aug 9, 1920
```

而事實上這樣的需求還沒滿足到，因此 pipe 是能提供參數的，透過`:`來指定參數獲得字串值使用。現在調整`{{ server.started | date:'fullDate'}}`後輸出如下：

>如果該 pipe 能提供多個參數則是類似這樣的語法來設定`{{yourString | pipeName:'arg1':'arg2}}`。

```txt
Monday, August 9, 1920
```

**其他 pipe**
你可以照訪 [官方 API 參考文件 - pipe](https://angular.tw/api?query=pipe) 部份，裡面會有所有 pipe 介紹，包含我們剛試玩過的 UpperCasePipe 與 DatePipe。其中 DatePipe 可以去了解參數根據國情不同有更適合的時間顯示方式。 例如我們可以改成`{{ server.started | date:'西元 yyyy 年 MM 月 dd 日 HH:mm'}}`如下結果：

```txt
西元 1920 年 08 月 09 日 00:00
```

這裡簡述一些基本 pipe 可自行前往了解。

- DatePipe ：
- UperCase - 有英文的部分全部轉換成大寫
- LowerCase - 有英文的部分全部轉換成小寫
- DecimalPipe - 數字單位關於小數點的捨進於第幾位
- Currency - 貨幣格式，雷同 DecimalPipe
- PercentPipe - 百分比格式
- JsonPipe - 可將任意值轉 JSON，例如字串、數字、物件
- SlicePipe - 把某個物件、集合切割出其中的某一塊資料出來，同 Array.Slice 觀念

### pipe 疊加之順序
你可以對一字串插值套用兩組 pipe 但有從左至右的解讀順序執行問題，舉例時間部份想套完整日期文字並轉大寫。那勢必是時間的物件先跑日期轉文字再跑文字轉大寫，如果反過來會造成失敗，因為時間物件不是字串，轉大寫 pipe 無法處理。標準順序` {{ server.started | date:'fullDate' | uppercase}}`為：

```txt
MONDAY, AUGUST 9, 1920
```

## 建立自訂 pipe
這裡會教你如何創建自己需要的 pipe，例如我們需要一個可自動判斷文字超過 15 個字會自動切掉的自訂管道。跟著以下步驟學習：

- 首先需創建管道的文件`short-text.pipe.ts`，或依賴 CLI 完成`ng g p short-text`
- 來到 short-text 管道這裡會使用到 PipeTransform 作為實體化界面提供我們 transform 轉換的方法
- 使用 transform 來獲得什麼進行處理再進行回傳，如果 CLI 完成的這裡已經準備好了，只是我們要使用 string 不適合 unknown。
- 我們試著設計拿到字串後透過 substring 只回傳前 10 個字段。
- 記得去 app.module 的 declarations 註冊這個自訂管道 ShortTextPipe，如果 CLI 完成這裡已經準備好了
- 以及注意要宣告 pipe 名稱透過`@pipe()`指定名稱叫 shortText，如果 CLI 完成的這裡已經準備好了。

```ts short-text.pipe.ts
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'shortText'
})
export class ShortTextPipe implements PipeTransform {

  transform(value: string, ...args: unknown[]): unknown {
    if (value.length > 15) return value.substring(0, 15) + '...';
    return value;
  }
}
```
```ts app.module.ts
//...
import { AppComponent } from './app.component';
import { ShortTextPipe } from './short-text.pipe'; //※重點

@NgModule({
  declarations: [
    AppComponent,
    ShortTextPipe //※重點
  ],
  imports: [
    BrowserModule,
    FormsModule,
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

現在你能在範本上使用`{{ server.name | shortText }}`獲得以下效果：
```txt
stableProduction Serv... | MEDIUM | MONDAY, AUGUST 9, 1920
stableUser Database | LARGE | MONDAY, AUGUST 9, 1920
offlineDevelopment Ser... | SMALL | MONDAY, AUGUST 9, 1920
stableTesting Environ... | SMALL | MONDAY, AUGUST 9, 1920

```

### 設計管道參數
在 transform 函式內第一個參數為要處理的資料，第二個以上參數開始為本身 pipe 的參數提供。我們能借用參數從範本來控制侷限字數為多少。

```ts app.component.ts
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'shortText'
})
export class ShortTextPipe implements PipeTransform {

  transform(value: string, ...args: number[]): string {
    if (value.length > args[0]) return value.substring(0, args[0]) + '...';
    return value;
  }
}
```
如此一來能從範本來控制字數，舉例`{{ server.name | shortText:5 }}`的完整效果如下：
```html app.component.html
stableProdu... | MEDIUM | MONDAY, AUGUST 9, 1920
stableUser ... | LARGE | MONDAY, AUGUST 9, 1920
offlineDevel... | SMALL | MONDAY, AUGUST 9, 1920
stableTesti... | SMALL | MONDAY, AUGUST 9, 1920
```

## 利用 pipe 做到篩選
pipe 除了能在字串插值時做轉換，也能在 ngFor 這樣的屬性命令上做出轉換處理。舉例來說 li 這樣的透過 ngFor 來達到批次輸出，如果部份項目不想輸出，你沒辦法在同 ngFor 層上添加 ngIf 控制是否輸出，換成程式觀念 if 條件一定是在 for 底下進入後才判斷。所以會用到兩層去且會產生空的 li 元素，像這樣：

```html app,component.html
<li
  class="list-group-item"
  *ngFor="let server of servers"
  [ngClass]="getStatusClasses(server)"
>
  <div *ngIf="server.status==='stable'">
    <span class="badge rounded-pill bg-secondary float-end">
      {{ server.status }}
    </span>
    <strong>{{ server.name | shortText:5 }}</strong> | {{ server.instanceType| uppercase }} | {{
    server.started |
    date:'fullDate' | uppercase}}
  </div>
</li>
```
這樣會產生多餘空白 li，因此你可以使用 ng-container 模擬假的元素層給 ngFor 使用。這樣是由 ngIf 來決定 li 的出現。

```html app.component.html
<ng-container *ngFor="let server of servers">
  <li
    *ngIf="server.status==='stable'"
    class="list-group-item"
    [ngClass]="getStatusClasses(server)"
  >
    <span class="badge rounded-pill bg-secondary float-end">
      {{ server.status }}
    </span>
    <strong>{{ server.name | shortText:5 }}</strong> | {{ server.instanceType | uppercase }} | {{
    server.started |
    date:'fullDate' | uppercase}}
  </li>
</ng-container>
```

以上是 ngFor 跟 ngIf 搭配的正確做法，但還有另一個做法就是不靠 ngIf 來決定，而是 ngFor 搭配 pipe 且只需一層真實元素就能搞定，原理為 nfFor 當下要輸出的內容`<li>...</li>`會轉換給 pipe 執行再輸出，因此我們只要在 pipe 階段去考慮不會原汁原味提供還是給個空談。這裡會順便把功能做更好：

- 規劃、input 欄位 text，並提供 HTML5 新功能 lists 供預設選擇，並使用雙向綁定將此欄位的 value 同步到 TS 去。
- 來到 TS 這裡配合產生此屬性初始為空字串。
- 回到範本，我們要在 ngFor 當下的動作多一個管道作業，因此位於 let...of... 這裡後續多管道動作，暫定送交給自訂管道 filterString，同時有兩參數一個是 input 的 value 等價 filterStatus 本地屬性，另一個為純文字'status'只單純不想寫死在 TS 沒有彈性。
- 自訂管道使用 CLI 指令`ng g p filter-string`獲得相關檔案並環境完成。
- 規劃 FilterStringPipe 設計，主要是如果沒東西進來或是沒輸入字串就退回去；批次觀看 li 資料如果 status 值是我們要的收集起來，最後還回去。

```html app.component.html
<div class="container">
  <div class="row">
    <div class="col">
      <input
        type="text"
        [(ngModel)]="filterStatus"
        list="options"
      >
      <datalist id="options">
        <option value="stable">stable</option>
        <option value="offline">offline</option>
      </datalist>
      <hr>
      <ul class="list-group">
        <li
          class="list-group-item"
          *ngFor="let server of servers | filterString:filterStatus:'status'"
          [ngClass]="getStatusClasses(server)"
        >
          <span class="badge rounded-pill bg-secondary float-end">
            {{ server.status }}
          </span>
          <strong>{{ server.name | shortText:5 }}</strong> | {{ server.instanceType| uppercase }} | {{ server.started | date:'fullDate' | uppercase}}
        </li>
      </ul>
    </div>
  </div>
</div>
```
```ts app.component.ts
filterStatus = '';
```
```ts filter-string.pipe.ts
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'filterString'
})
export class FilterStringPipe implements PipeTransform {
  transform(lists: any, ...args: unknown[]): unknown {
    // console.log(args[0]);
    if (!lists.length || args[0] === '') return lists;

    const resultAry = [];
    for (const item of lists) {
      if (item.status === args[0]) resultAry.push(item);
    }
    return resultAry;
  }
}
```

### 潛在問題與排除
看似完美有個效能問題要討論先，我們試著先設計一按鈕能夠自動添加 server 資料到列表之中。

- 範本上規劃事件綁定能對 TS 要求插入一筆假 server
- TS 部份宣告一方法能幫我們塞一組到原本的 servers 屬性內

```html app.component.html
<button (click)="addFakeServer()">Add Test Server</button>
```
```ts app.component.ts
addFakeServer() {
  this.servers.push({
    instanceType: 'medium',
    name: 'Test Server',
    status: 'stable',
    started: new Date(15, 1, 2017)
  });
}
```

縣在試著在各時間可能下操作新增按鈕，可發現一些問題所在。原因在於每當事後新資料增加時，Angular 不會重新對 pipe 要求重新運行重載，只有在一開始初始資料的送交給 pipe 這些項目有被修改才會重新觸發 pipe，這是為了效能上的調節。如果你希望犧牲效能能夠被徵測到，可以透過調整設定來回歸都要被徵測到。回到 pipe 檔案設定 pure 為 false。

```ts short-text.pipe.ts
@Pipe({
  name: 'shortText',
  pure: false
})
```

## 非同步管道
現在討論管道對於非同步作業下的幫助。假設元件規劃一屬性為 appStatus 假裝經過後端而非同步結果所獲得的結果字串值 stable!!（這裡用 promise 進行 timeout 2 秒）。然後將這個屬性透過字串插值方式放入到範本上：

```ts app.component.ts
export class AppComponent {
  appStatus = new Promise((res, rej) => {
    setTimeout(() => {
      res('stable!!')
    }, 2000);
  });
  //...
}
```
```html app.component.html
<h1>Server is {{appStatus}}</h1>
```

現在畫面上出現的為`Server is [object Promise]`且兩秒後也不會更新，因為我們現在這個屬性的值是一個 promise 的產物，過去你可能需要先創立一個空字串，在讓 promise 結果去複寫空字串。現在可以透過 pipe 直接幫我們轉換非同步的產物並直接提取。使用`{{appStatus | async}}`調整。async 可以對 promise 或 observables 使用，pipe 會意識到這是一個非同步產物，會等待並試著將結果轉出。

現在是從 Server is　然後等兩秒變 Server is stable!!

## 小節練習
待補
<!-- https://www.udemy.com/course/the-complete-guide-to-angular-2/learn/practice/280/introduction#overview -->

# Http Request 伺服器請求
https://www.udemy.com/course/the-complete-guide-to-angular-2/learn/lecture/14466318#content

# NgRx 
NgRx 是 Angular 另外一塊模組，能幫助我們大型開發應用上更有效率的妥善管理整個 Application state 應用狀態的方式。過去我們跟後端進行存取資料會利用 service 去獲取，而元件儲存資料到 service 內，這樣的整個資料流範圍就是一種前端的資料狀態，service 本身再跟後端進行 CRUD。
4
因此每個小元件都會依賴自己的 service 或是別人的 service 去存取後端資料，這樣的 state 會隨著架構越大你的整個網站的資料狀態就會越複雜而難以維護。原因包含：

- state 會在整個 app 任何地方被進行更新。
- state 本身是隨時可變化的，舉例你只有幾處想更改，但影響你需要覆蓋整個 state 為新。
- 隨 httpRequest 事件而影響 state。

雖然這些問題都能克服改善整個資料流的明確路線與可用方法來解決，但會更於複雜。因此會依賴 NgRx 來不強迫影響這些執行結果。

NgRx 本身是參考 React 框架的 Redux 而延伸來的。本身是一種額外的 state 管理應用 library。他的理念是透過大型集中 store 儲存你的 app，所有的元件與服務都能彼此交換資料但都需要從 store 來存取 state。ngRX 最主要由以下幾個部分組成：

- Actions
- State Change
- Selectors
- Store
- Effects

![](https://i.imgur.com/YcwZvTA.png)

舉例來說如果你需要進行新增資料，你會透過 Actins 來進行此操作，Actions 會先到達 Reducer 進行處理，Reducer 本身是一個 JS 函數，他能幫助我們獲得當前 state 與輸入動作後判斷要做怎樣的 CRUD 到 store 去，不修改現有影響 state 變化情況下產生新副本 state 提交給 store 要求後端 CRUD。

## 安裝
你需要透過npm來安裝NgRx，輸入指令

```shell
npm install @ngrx/store
```