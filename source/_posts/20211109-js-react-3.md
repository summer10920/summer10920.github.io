---
title: '[學習之路] JS 前端框架 React - 井字遊戲'
categories:
  - Zero Road
  - Web Fronted
tag:
  - ReactJS
  - JavaScript
date: 2021-11-09 23:55:47
---

![](https://i.imgur.com/iWnyS9n.png)
本篇根據官方學習指南所建議的 [互動小遊戲](https://codepen.io/gaearon/pen/gWWZgR) 進行實作練習。差別於官方以 0 程度進行新手講解，本內容根據已經學習過前面文章初階篇之程度來進行實作解說，因此步驟程度較快。並最後嘗試完成官方建議的進階難度的自我挑戰調整。

<!-- more -->

遊戲設計需求如下：

- 讓你玩井字遊戲
- 顯示哪一個玩家取得勝利
- 在遊戲進行的同時儲存遊戲歷史
- 讓玩家回顧遊戲的歷史，並回到棋盤之前的版本

初始視覺版型提供如下（微調過移除不必要的 div)：
![](https://i.imgur.com/3j9eZQu.png)
```html index.html
<div class="game">
    <div class="game-board">
      <div class="status">Next player: X</div>
      <div class="board-row">
        <button class="square"></button>
      </div>
      <div class="board-row">
        <button class="square"></button>
      </div>
      <div class="board-row">
        <button class="square"></button>
      </div>
    </div>
    <div class="game-info">
      <div></div>
      <ol></ol>
    </div>
  </div>
```
```css index.css
body {
  font: 14px "Century Gothic", Futura, sans-serif;
  margin: 20px;
}

ol, ul {
  padding-left: 30px;
}

.board-row:after {
  clear: both;
  content: "";
  display: table;
}

.status {
  margin-bottom: 10px;
}

.square {
  background: #fff;
  border: 1px solid #999;
  float: left;
  font-size: 24px;
  font-weight: bold;
  line-height: 34px;
  height: 34px;
  margin-right: -1px;
  margin-top: -1px;
  padding: 0;
  text-align: center;
  width: 34px;
}

.square:focus {
  outline: none;
}

.kbd-navigation .square:focus {
  background: #ddd;
}

#game {
  display: flex;
  flex-direction: row;
}

.game-info {
  margin-left: 20px;
}
```

# 初始化與基本畫面
先跟隨官方腳步，將九宮格透過 component 繪製出來。

1. 首先透過 react 架設所需環境。
```shell
npx create-react-app game
cd game
npm start
```
2. 清除到乾淨的應用環境，保留 src 底下的 index.css 與 index.js，public 只保留 index.html 並清乾淨。
3. 將前面素材 index.css 覆蓋至 src/index.css，素材 index.html 覆蓋至 public/index.html。

## 初始化 index.js
接著試著搬移 index.html 的元素代碼至 index.js 內的 componet 以 render 來完成渲染。

1. 將`<div class="game">...</div>`形成一個組件 Game
2. 將`<div class="game-board">...</div>`形成一個組件 Board
3. 將`<button class="square"></button>`形成一個組件 Square
4. 記得透過 import 來將 index.css 載入
5. 如果不想獲得警告，JSC 不喜歡 class 而是用 className 來指定原本 HTML 屬性
```js scr/index.js
import { Component } from 'react';
import ReactDOM from 'react-dom';
import './index.css';

class Square extends Component {
  render() {
    return (<button className="square"></button>);
  }
}

class Board extends Component {
  render() {
    return (
      <div className="game-board">
        <div className="status">Next player: X</div>
        <div className="board-row">
          <Square />
        </div>
        <div className="board-row">
          <Square />
        </div>
        <div className="board-row">
          <Square />
        </div>
      </div>
    );
  }
}

class Game extends Component {
  render() {
    return (
      <>
        <Board />
        <div className="game-info">
          <div></div>
          <ol></ol>
        </div>
      </>
    );
  }
}

ReactDOM.render(
  <Game />,
  document.getElementById('game')
);
```

## 標記 Square 的編號
為了之後計算 Square 的來源為誰，規劃 props.value 由上層 Board 提供編號給下層 Square。

1. 調整 Board 原本匯入 Square 的方式，改由透過本地函式來觸發，這樣使得 JSX 的畫面比較簡單整潔。
2. 方便測試，可以對 Square 嘗試渲染出 props.value。
```js src/index.js
//...
class Square extends Component {
  render() {
    return (<button className="square">{this.props.value}</button>);
  }
}

class Board extends Component {
  renderSquare(i) {
    return <Square value={i} />
  }
  render() {
    return (
      <div className="game-board">
        <div className="status">Next player: X</div>
        <div className="board-row">
          {this.renderSquare(0)} {/*等價 <Square value={0}/> 只是畫面比較亂*/}
          {this.renderSquare(1)}
          {this.renderSquare(2)}
        </div>
        <div className="board-row">
          {this.renderSquare(3)}
          {this.renderSquare(4)}
          {this.renderSquare(5)}
        </div>
        <div className="board-row">
          {this.renderSquare(6)}
          {this.renderSquare(7)}
          {this.renderSquare(8)}
        </div>
      </div>
    );
  }
}
//...
```

## click 事件下的變化
初始化階段下，接著需要對每個 Square 產生 click 事件替換內容為 X。

1. 因為是互動，規劃本地 state 初始為空字串，隨被點擊後修改 state 為 X 字串。
2. 這裡為了簡單，指定一觸發 onClick 時直接執行 this.setState 透過箭頭函式包覆。

```js scr/index.js
//...
class Square extends Component {
  state = {
    value: ''
  }
  render() {
    return (
      <button className="square"
        onClick={
          () => this.setState({ value: 'X' })
        }
      >{this.state.value}</button>
    );
  }
}
//...
```

# 規劃遊戲
目前為止已完成基本需要的畫面，接下來，正式加入一些遊戲機制。

## 交互放入 O 與 X
為了能計算出各自 Square 的值組合判斷出勝負，我們必須將原本在 Square 內的 state.value 提升到上層 Board，才能統一由上層來管理 9 組 square。

1. 首先將 square 內的 state 改到上層 Board 去，再透過 props 傳遞 state 與 setState 給下層使用。
2. Board 的 state 建立陣列長度 9，初始為 null 狀態。隨後如果有被 click 則更改為 X 字串值。
3. 利用 Board 的 render 部分稍早有提供 i 位置參考值，因此規劃 doClick(i) 發布給 9 個 square 使用。
4. Square 組件本身捨棄原本的 state.value，改由上層的 prop 過來的 value 使用，而有人對此 Square 進行 click 則是觸發上層的 doClick。
```js
//...
class Square extends Component {
  render() {
    return (
      <button className="square"
        onClick={this.props.onClick}
      >{this.props.value}</button>
    );
  }
}

class Board extends Component {
  state = {
    squares: Array(9).fill(null)
  }

  doClick = (i) => {
    const squares = this.state.squares.slice(); //copy
    squares[i] = 'X';
    this.setState({ squares: squares });
  }

  renderSquare(i) {
    return <Square
      value={this.state.squares[i]}
      onClick={() => this.doClick(i)}
    />
  }

  render() {
    return (
      <div className="game-board">
        <div className="status">Next player: X</div>
        <div className="board-row">
          {this.renderSquare(0)} {/*等價 <Square value={0}/> 只是畫面比較亂*/}
          {this.renderSquare(1)}
          {this.renderSquare(2)}
        </div>
        <div className="board-row">
          {this.renderSquare(3)}
          {this.renderSquare(4)}
          {this.renderSquare(5)}
        </div>
        <div className="board-row">
          {this.renderSquare(6)}
          {this.renderSquare(7)}
          {this.renderSquare(8)}
        </div>
      </div>
    );
  }
}
//...
```

接著，為了讓每次點擊都是 X 與 O 替換，我們需要在 Board 組件內多一個 state 來做切換。

1. 追加一個 state 為 xisNext，初始為 true，代表目前將是 X。
2. 在 doClick 內，對陣列指定處塞入值之前透過三元運算子判斷該塞 O 還是 X。
3. 對 setState 追加 xisNext 做顛倒。
4. 順便對標題也活動起來使用三元運算子。
5. 最後，如果按過的位置就不要讓他觸發 event 之後的動作
```js
class Board extends Component {
  state = {
    squares: Array(9).fill(null),
    xisNext: true
  }

  doClick = (i) => {
    const squares = this.state.squares.slice(); //copy
    if(squares[i]) return; //如果被點過就不發動後面動作

    // squares[i] = 'X';
    squares[i] = this.state.xisNext ? 'X' : 'O';

    this.setState({
      squares: squares,
      xisNext: !this.state.xisNext
    });
  }

  renderSquare(i) {
    return <Square
      value={this.state.squares[i]}
      onClick={() => this.doClick(i)}
    />
  }

  render() {
    return (
      <div className="game-board">
        <div className="status">Next player: {this.state.xisNext ? 'X' : 'O'}</div>
        <div className="board-row">
          {this.renderSquare(0)} {/*等價 <Square value={0}/> 只是畫面比較亂*/}
          {this.renderSquare(1)}
          {this.renderSquare(2)}
        </div>
        <div className="board-row">
          {this.renderSquare(3)}
          {this.renderSquare(4)}
          {this.renderSquare(5)}
        </div>
        <div className="board-row">
          {this.renderSquare(6)}
          {this.renderSquare(7)}
          {this.renderSquare(8)}
        </div>
      </div>
    );
  }
}
```

## 判斷勝負
判斷勝負的方式，我們需要一個檢查用的函式幫忙確定那些位置下的值當存在且相同時代表已勝利。接著一但獲得勝利嘗試畫面顯示且不再允許繼續 click 動作。

1. 規劃一函式 checkWin，提供 state.square 資料做批次檢查，一但指定某 3 處位置下的值存在且相同，則回傳此值。
```js
function checkWin(square) {
  const winLine = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];

  for (let i = 0; i < winLine.length; i++) {
    const [a, b, c] = winLine[i];
    if (square[a] && square[a] === square[b] && square[a] === square[c]) return square[a];
  }
  return null;
}
```
1. 在 Board 組件進行 render 當下，先執行檢查 checkWin 回傳，若獲得值則提供勝利的畫面。
2. 在 Board 組件提供 click 動作時，先執行檢查 checkWin 回傳，若獲得值則不執行後續動作。
```js
class Board extends Component {
  state = {
    squares: Array(9).fill(null),
    xisNext: true
  }

  doClick = (i) => {
    const squares = this.state.squares.slice(); //copy

    if (checkWin(squares) || squares[i]) return; //如果檢查勝利有結果，或者被點過就不發動後續

    squares[i] = this.state.xisNext ? 'X' : 'O';
    this.setState({
      squares: squares,
      xisNext: !this.state.xisNext
    });
  }

  renderSquare(i) {
    return <Square
      value={this.state.squares[i]}
      onClick={() => this.doClick(i)}
    />
  }

  render() {
    const checkWinner = checkWin(this.state.squares);
    const status = checkWinner ? 'Winner: ' + checkWinner : 'Next player: ' + (this.state.xisNext ? 'X' : 'O');

    return (
      <div className="game-board">
        <div className="status">{status}</div>
        <div className="board-row">
          {this.renderSquare(0)} {/*等價 <Square value={0}/> 只是畫面比較亂*/}
          {this.renderSquare(1)}
          {this.renderSquare(2)}
        </div>
        <div className="board-row">
          {this.renderSquare(3)}
          {this.renderSquare(4)}
          {this.renderSquare(5)}
        </div>
        <div className="board-row">
          {this.renderSquare(6)}
          {this.renderSquare(7)}
          {this.renderSquare(8)}
        </div>
      </div>
    );
  }
}
```

## 歷史紀錄清單
最後是要提供一個歷史紀錄的清單選取功能。大致想法為將每次原本在 Board 組件內的 state.squares 陣列變化透過另一個 history 陣列都保留下來，如果要回朔到某狀態的 state.squares 陣列就透過這個 history 某位置內的來覆蓋。

### 提升 state 至 Game
為了規劃歷史紀錄功能，由於歷史紀錄的 JSX 位置在 Game 組件上，同時 history 規劃在 Game 組件上也能確保下層 Borard 能夠被使用。因此我們必須要將 Board 的 state.squares 提升到 Game 裡去，但 Game 組件我們要創建更龐大的陣列 history。另外 state.xisNext 也要提升上來。

1. 消除原本 Borad 的 state，改在 Game 組件內提升並以 state.history 陣列型態做初始化。
2. 接著原本的 Board 的 render 部分消除，提升到 Game 組件的 render 去並調整寫法。原本要檢查的`state.squares`變成是在`state.history[history.length-1]`（最後一處）上。
3. 將要顯示的 status 遊戲文字改在 Game 的另半`<div className="game-info">`呈現，取消並不再透過 Board 做渲染。
4. 目前 history 最後的 squares 要傳給 Board 來渲染。透過`<Board squares={historyLast} />`完成。
5. 而 Board 內的 squares 已經不是 this.state 而是 this.props 了。doClick 也消除用不到（先註解），這裡之後由上層來負責。所以要修改的地方只剩 renderSquare 內。
```js
class Board extends Component {
  // state = {
  //   squares: Array(9).fill(null),
  //   xisNext: true
  // }

  // doClick = (i) => {
  //   const squares = this.state.squares.slice(); //copy

  //   if (checkWin(squares) || squares[i]) return; //如果檢查勝利有結果，或者被點過就不發動後續

  //   squares[i] = this.state.xisNext ? 'X' : 'O';
  //   this.setState({
  //     squares: squares,
  //     xisNext: !this.state.xisNext
  //   });
  // }

  renderSquare(i) {
    return (<Square
      value={this.props.squares[i]}
      // onClick={() => this.doClick(i)}
    />)
  }

  render() {
    // const checkWinner = checkWin(this.state.squares);
    // const status = checkWinner ? 'Winner: ' + checkWinner : 'Next player: ' + (this.state.xisNext ? 'X' : 'O');

    return (
      <div className="game-board">
        {/* <div className="status">{status}</div> */}
        <div className="board-row">
          {this.renderSquare(0)}
          {this.renderSquare(1)}
          {this.renderSquare(2)}
        </div>
        <div className="board-row">
          {this.renderSquare(3)}
          {this.renderSquare(4)}
          {this.renderSquare(5)}
        </div>
        <div className="board-row">
          {this.renderSquare(6)}
          {this.renderSquare(7)}
          {this.renderSquare(8)}
        </div>
      </div>
    );
  }
}

class Game extends Component {
  state = {
    history: [{
      squares: Array(9).fill(null)
    }],
    xisNext: true
  }
  render() {
    const history = this.state.history;
    const historyLast = history[this.state.history.length - 1];
    const checkWinner = checkWin(historyLast.squares);
      
    const status = checkWinner ? 'Winner: ' + checkWinner : 'Next player: ' + (this.state.xisNext ? 'X' : 'O');
    return (
      <>
        <Board squares={historyLast.squares} />
        <div className="game-info">
          <div>{status}</div>
          <ol></ol>
        </div>
      </>
    );
  }
}
```

接著原本 Board 內的 doClick 也是提交到 Game 去，由 Game 來提供給 Board ，再由 Board 提供給 Square 組件。

1. 將原 doClick 提升到 Game 組件內，但注意真正位置在 history 最後處，改寫時是添加到新最後處（因為非同步建議透過 concat 而不是 push)。
2. 將執行箭頭函式透過 props 傳遞給 Board 組件。該函式動作為提供 i 參數來執行本地 doClick(i)。
3. 原 Borad 的 this.doClick(i) 變成 this.props.doClick(i)
```js
class Board extends Component {
  // doClick = (i) => {
  //   const squares = this.state.squares.slice(); //copy

  //   if (checkWin(squares) || squares[i]) return; //如果檢查勝利有結果，或者被點過就不發動後續

  //   squares[i] = this.state.xisNext ? 'X' : 'O';
  //   this.setState({
  //     squares: squares,
  //     xisNext: !this.state.xisNext
  //   });
  // }
  renderSquare(i) {
    return <Square
      value={this.props.squares[i]}
      onClick={() => this.props.doClick(i)}
    />
  }

  render() {
    return (
      <div className="game-board">
        <div className="board-row">
          {this.renderSquare(0)}
          {this.renderSquare(1)}
          {this.renderSquare(2)}
        </div>
        <div className="board-row">
          {this.renderSquare(3)}
          {this.renderSquare(4)}
          {this.renderSquare(5)}
        </div>
        <div className="board-row">
          {this.renderSquare(6)}
          {this.renderSquare(7)}
          {this.renderSquare(8)}
        </div>
      </div>
    );
  }
}

class Game extends Component {
  state = {
    history: [{
      squares: Array(9).fill(null)
    }],
    xisNext: true
  }

  doClick = (i) => {
    const history = this.state.history;
    const squares = history[history.length - 1].squares.slice(); //copy

    if (checkWin(squares) || squares[i]) return; //如果檢查勝利有結果，或者被點過就不發動後續

    squares[i] = this.state.xisNext ? 'X' : 'O';
    this.setState({
      history: history.concat([{ squares: squares }]), //陣列合併
      xisNext: !this.state.xisNext
    });
  }

  render() {
    const history = this.state.history;
    const historyLast = history[this.state.history.length - 1];
    const checkWinner = checkWin(historyLast.squares);
    const status = checkWinner ? 'Winner: ' + checkWinner : 'Next player: ' + (this.state.xisNext ? 'X' : 'O');

    return (
      <>
        <Board
          squares={historyLast.squares}
          doClick={(i) => this.doClick(i)}
        />
        <div className="game-info">
          <div>{status}</div>
          <ol></ol>
        </div>
      </>
    );
  }
}
```

### 展示歷史畫面
接著需要將步驟紀錄顯示在畫面上，此位置在 Game 組件內處理。

1. 產生 li 元素標籤陣列 listMoves，透過對 history.map() 來批次產生多組 li。利用 index 值來產生步驟 0~N ，唯獨步驟 0（初始資料下的 squares) 的文字是 GameStart。
2. 因為 listMoves 標籤陣列提供給 JSX 需要綁一個 key 值，不建議使用數字或 index 來指定，改用第三方`npm install --save nanoid`來協助隨機碼，key 的位置落在 li 上面。
3. 最後將這個 li 群組輸出在畫面上。
4. 先偷綁一個點擊事件，落某 button 被點時觸發要回到第幾筆 squares 狀況。

```js
class Game extends Component {
  state = {
    history: [{
      squares: Array(9).fill(null)
    }],
    xisNext: true
  }

  doClick = (i) => {
    const history = this.state.history;
    const squares = history[history.length - 1].squares.slice(); //copy

    if (checkWin(squares) || squares[i]) return; //如果檢查勝利有結果，或者被點過就不發動後續

    squares[i] = this.state.xisNext ? 'X' : 'O';
    this.setState({
      history: history.concat([{ squares: squares }]), //陣列合併
      xisNext: !this.state.xisNext
    });
  }

  doJump = (e) => {
    console.log(e);
  }

  render() {
    const history = this.state.history;
    const historyLast = history[this.state.history.length - 1];
    const checkWinner = checkWin(historyLast.squares);
    const status = checkWinner ? 'Winner: ' + checkWinner : 'Next player: ' + (this.state.xisNext ? 'X' : 'O');

    const listMoves = history.map((v, i) => {
      const desc = i ? 'Go to move #' + i : 'Go to game start';

      return (
        <li key={nanoid(4)}>
          <button onClick={() => { this.doJump(i) }}>{desc}</button>
        </li>
      );
    });

    return (
      <>
        <Board
          squares={historyLast.squares}
          doClick={(i) => this.doClick(i)}
        />
        <div className="game-info">
          <div>{status}</div>
          <ol>{listMoves}</ol>
        </div>
      </>
    );
  }
}
```

### 動作反應
我們需要一個負責記錄目前是畫面為上步驟幾的 state.stepNum，這個值能控制 history 內的第幾格是我們的效果畫面。

1. 在 Game 組件內初始 state.stepNum 為 0，一開始是步驟 0。
2. 當 doJump 被觸發時，根據參數為步驟幾來修正 state.stepNum，也就是想要將畫面呈現在步驟幾的紀錄上。
3. 同上，同時還要修正由於 state.stepNum 而當時的 xisNext 為何，已知步驟 0 下該值為 true，步驟 1 為 false。
4. Game 每次渲染時，根據 state.stepNum 多少來決定 historyLast 的畫面資料。才能影響其他組件的渲染動作。原本是抓最後一筆做渲染，現在是根據 stepNum 為多少來決定哪筆渲染。
5. 其次，每次遊戲方塊被點擊時，stepNum值會遞增，修正stepNum值可根據目前history長度來獲得。
```js
class Game extends Component {
  state = {
    history: [{
      squares: Array(9).fill(null)
    }],
    xisNext: true,
    stepNum: 0
  }

  doClick = (i) => {
    const history = this.state.history;
    const squares = history[history.length - 1].squares.slice(); //copy

    if (checkWin(squares) || squares[i]) return; //如果檢查勝利有結果，或者被點過就不發動後續

    squares[i] = this.state.xisNext ? 'X' : 'O';
    this.setState({
      history: history.concat([{ squares: squares }]), //陣列合併
      xisNext: !this.state.xisNext,
      stepNum: history.length
    });
  }

  doJump = (e) => {
    // console.log(e);
    this.setState({
      xisNext: e % 2 === 0,
      stepNum: e
    })

  }

  render() {
    const history = this.state.history;
    // const historyLast = history[this.state.history.length - 1];
    const historyLast = history[this.state.stepNum];
    const checkWinner = checkWin(historyLast.squares);
    const status = checkWinner ? 'Winner: ' + checkWinner : 'Next player: ' + (this.state.xisNext ? 'X' : 'O');

    const listMoves = history.map((v, i) => {
      const desc = i ? 'Go to move #' + i : 'Go to game start';

      return (
        <li key={nanoid(4)}>
          <button onClick={() => { this.doJump(i) }}>{desc}</button>
        </li>
      );
    });

    return (
      <>
        <Board
          squares={historyLast.squares}
          doClick={(i) => this.doClick(i)}
        />
        <div className="game-info">
          <div>{status}</div>
          <ol>{listMoves}</ol>
        </div>
      </>
    );
  }
}
```

6. 最後要考量的BUG問題。當成功回朔到某舊步驟下時，當下觸發方塊點擊時。原本的history歷史紀錄就要捨棄原本後步驟的值。使得該歷史陣列修正到只記錄到目前步驟下的歷史陣列。透過slice複製出一個從0到stepNum+1的陣列範圍作為每次點擊方塊的history紀錄。
```js
class Game extends Component {
  state = {
    history: [{
      squares: Array(9).fill(null)
    }],
    xisNext: true,
    stepNum: 0
  }

  doClick = (i) => {
    // const history = this.state.history;
    const history = this.state.history.slice(0, this.state.stepNum + 1);
    const squares = history[history.length - 1].squares.slice(); //copy

    if (checkWin(squares) || squares[i]) return; //如果檢查勝利有結果，或者被點過就不發動後續

    squares[i] = this.state.xisNext ? 'X' : 'O';
    this.setState({
      history: history.concat([{ squares: squares }]), //陣列合併
      xisNext: !this.state.xisNext,
      stepNum: history.length
    });
  }

  doJump = (e) => {
    // console.log(e);
    this.setState({
      xisNext: e % 2 === 0,
      stepNum: e
    })
  }

  render() {
    const history = this.state.history;
    const historyLast = history[this.state.stepNum];
    const checkWinner = checkWin(historyLast.squares);
    const status = checkWinner ? 'Winner: ' + checkWinner : 'Next player: ' + (this.state.xisNext ? 'X' : 'O');

    const listMoves = history.map((v, i) => {
      const desc = i ? 'Go to move #' + i : 'Go to game start';

      return (
        <li key={nanoid(4)}>
          <button onClick={() => { this.doJump(i) }}>{desc}</button>
        </li>
      );
    });

    return (
      <>
        <Board
          squares={historyLast.squares}
          doClick={(i) => this.doClick(i)}
        />
        <div className="game-info">
          <div>{status}</div>
          <ol>{listMoves}</ol>
        </div>
      </>
    );
  }
}
```


# 參考文件
- [MDN - Array.prototype.slice()](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)
- [MDN - Array.prototype.concat()](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)