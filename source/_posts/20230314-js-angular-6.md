---
title: '[前端框架] Angular - 模組、'
categories:
  - Zero Road
  - Angular
tag:
  - Angular
  - JavaScript
date: 2023-03-14 11:02:45
---

![](https://i.imgur.com/WC5iApN.png)
待補充
<!-- 本篇介紹 Sass 這套預處理器，他能將大型專案上編寫 CSS 不易維護的問題進行改善。使用 Sass 的 Script 語言來進行 CSS 開發，再透過編譯 complier 後轉為瀏覽器可閱讀的 CSS。 -->

<!-- more -->

---

# Modules
模組（Modules）是 Angular 中的核心概念之一。它們是由 Angular 模組（Angular Module）負責定義、維護和載入。每個應用程序至少有一個模組，這個模組被稱為根模組（Root Module），其他模組可以被應用程序擴充和引用。

模組主要用於將應用程序拆分成可重用和可管理的部分，並定義應用程序的結構和功能。模組內可以包含元件 Components、服務 Services、指令 Directives、管道 custom Pipes 等等。通過將相關的元件和其他應用程序資源放在同一個模組中，可以更好地組織和管理代碼。

在 Angular 中，模組主要通過裝飾器來定義和配置。通過裝飾器，可以指定模組名稱、導入的模組、導出的元件和服務、提供的服務等等。一個簡單的模組定義如下：

```typescript app.module.ts
import { AuthInterceptorService } from './auth/auth-interceptor.service';
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';

import { AppComponent } from './app.component';
import { HeaderComponent } from './header/header.component';
import { RecipesComponent } from './recipes/recipes.component';
import { RecipeListComponent } from './recipes/recipe-list/recipe-list.component';
import { RecipeDetailComponent } from './recipes/recipe-detail/recipe-detail.component';
import { RecipeItemComponent } from './recipes/recipe-list/recipe-item/recipe-item.component';
import { ShoppingListComponent } from './shopping-list/shopping-list.component';
import { ShoppingEditComponent } from './shopping-list/shopping-edit/shopping-edit.component';
import { DropdownDirective } from './shared/dropdown.directive';
import { ShoppingListService } from './shopping-list/shopping-list.service';
import { AppRoutingModule } from './app-routing.module';
import { RecipeStartComponent } from './recipes/recipe-start/recipe-start.component';
import { RecipeEditComponent } from './recipes/recipe-edit/recipe-edit.component';
import { RecipeService } from './recipes/recipe.service';
import { AuthComponent } from './auth/auth.component';
import { LoadingSpinnerComponent } from './shared/loading-spinner/loading-spinner.component';
import { AlertComponent } from './shared/alert/alert/alert.component';

@NgModule({
  declarations: [ // 聲明所有 components, directives, custom pipes 於 array 內
    AppComponent,
    HeaderComponent,
    RecipesComponent,
    RecipeListComponent,
    RecipeDetailComponent,
    RecipeItemComponent,
    ShoppingListComponent,
    ShoppingEditComponent,
    DropdownDirective,
    RecipeStartComponent,
    RecipeEditComponent,
    AuthComponent,
    LoadingSpinnerComponent,
    AlertComponent,
  ],
  imports: [ //允許將其他的模組加入到此模組內，所以拆分 module 時很重要
    BrowserModule,
    FormsModule, // 舉例此內建的表單 module 能讓整個專案使用
    ReactiveFormsModule,
    HttpClientModule,
    AppRoutingModule // 路由用的模組，額外於下面代碼另解釋
  ],
  providers: [ // 定義所有的服務，若不想在此定義可以在該 service 內填寫`@Injectable({ providedIn: 'root' })`注入於整個專案 root
    ShoppingListService,
    RecipeService, {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptorService,
      multi: true
    }
  ],
  bootstrap: [AppComponent], //引導哪個元件對應 index.html 的<app-root>
  entryComponents:[ //動態元件使用元件
    AlertComponent,
  ]
})

@NgModule({
  declarations: [ AppComponent ], 
  imports: [ BrowserModule ], 
  bootstrap: [ AppComponent ]
})
export class AppModule { }
```

在這個例子中，@NgModule 裝飾器被用來定義一個模組 AppModule，並通過 declarations 屬性聲明了該模組包含一個名為 AppComponent 的元件。imports 屬性用來導入該模組需要的其他模組，這裡導入了 BrowserModule。bootstrap 屬性指定了模組的根元件，這裡是 AppComponent。

此外你也可以從 app-routing.module.ts 可以看到 @NgModule 裝飾器的編寫。app-routing 模組用來保存所有路由配置。你可以把路由寫在 app.module.ts 內，但因為代碼量太大才透過拆分方式另寫成 app-routing.module.ts，使得 app.module.ts 更精簡與維護。

```typescript src\app\app-routing.module.ts
import { AuthGuard } from './auth/auth-guard.service';
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';

import { RecipesComponent } from './recipes/recipes.component';
import { ShoppingListComponent } from './shopping-list/shopping-list.component';
import { RecipeStartComponent } from './recipes/recipe-start/recipe-start.component';
import { RecipeDetailComponent } from './recipes/recipe-detail/recipe-detail.component';
import { RecipeEditComponent } from './recipes/recipe-edit/recipe-edit.component';
import { RecipesResolverService } from './recipes/recipes-resolver.service';
import { AuthComponent } from './auth/auth.component';

const appRoutes: Routes = [
  { path: '', redirectTo: '/recipes', pathMatch: 'full' },
  {
    path: 'recipes',
    component: RecipesComponent,
    canActivate: [AuthGuard],
    children: [
      { path: '', component: RecipeStartComponent },
      { path: 'new', component: RecipeEditComponent },
      {
        path: ':id',
        component: RecipeDetailComponent,
        resolve: [RecipesResolverService]
      },
      {
        path: ':id/edit',
        component: RecipeEditComponent,
        resolve: [RecipesResolverService]
      }
    ]
  },
  { path: 'shopping-list', component: ShoppingListComponent },
  { path: 'auth', component: AuthComponent }
];

@NgModule({
  imports: [RouterModule.forRoot(appRoutes)], 
  /**
    導入內建的 Router 模組，由 Angular 提供路由進行特殊方法，
    再將我們指定路由規則的 appRoutes 物件參數提供給路由模組成為新規則的 RouterModule
  **/
  exports: [RouterModule]
  /**
    最後需導出 Router 模組，才能在 App.module.ts 裡面導入使用
  **/
})
export class AppRoutingModule { }
```

## 環境建置準備
本篇的起始素材放置於 GitHub 底下提供使用，使用資料目錄 lokiModule 作為初始環境。下載請記得 npm install 初始化環境。

>[Github download](https://github.com/summer10920/angularTraining) at lokiModule-start Folder

這份素材跟隨上次素材作業 lokiHttp 為中繼存放點，若您已持有可繼續使用。

## 拆分 Feature 模組
如路由模組來說，你可以將路由餐屬直接寫在 appModule 內，也可以為了簡約將路由相關直接拆分一個模組，透過 import 匯回到 appModule。同樣可以將每個工作集合為一個 Feature Module 功能模組再匯回到 appModule，使得整個組織性更好維護。
### appModule 拆分至 RecipesModule
本篇將示範將 app.module.tss 內的與 recipes 相關的作業獨立出一個 feature module，放置於 recipes 底下：

- 透過手動或 CLI 指令`ng g m recipes`建立於 src\app\recipes\recipes.module.ts
- 將 aap.module.ts 內 declarations 所指定的 Recipes 相關元件搬移至 recipes.module.ts（包含 import 聲明）
- 將 recipes.module.ts 宣告於 app.module.ts 內的 import 使得 app.module.ts 能載入此 feature module。
- 我們也可以將 Recipes 元件寫在 exports，使得整個其他模組能使用。（本素材上沒有此需求，可寫可不寫）

```typescript src\app\app.module.ts
// import { RecipesComponent } from './recipes/recipes.component';
// import { RecipeListComponent } from './recipes/recipe-list/recipe-list.component';
// import { RecipeDetailComponent } from './recipes/recipe-detail/recipe-detail.component';
// import { RecipeItemComponent } from './recipes/recipe-list/recipe-item/recipe-item.component';
// ...
// import { RecipeStartComponent } from './recipes/recipe-start/recipe-start.component';
// import { RecipeEditComponent } from './recipes/recipe-edit/recipe-edit.component';
import { RecipesModule } from './recipes/recipes.module'; // ※重點

@NgModule({
  declarations: [
    AppComponent,
    HeaderComponent,
    // RecipesComponent,
    // RecipeListComponent,
    // RecipeDetailComponent,
    // RecipeItemComponent,
    ShoppingListComponent,
    ShoppingEditComponent,
    DropdownDirective,
    // RecipeStartComponent,
    // RecipeEditComponent,
    AuthComponent,
    LoadingSpinnerComponent,
    AlertComponent,
  ],
  imports: [
    BrowserModule,
    FormsModule,
    ReactiveFormsModule,
    HttpClientModule,
    AppRoutingModule,
    RecipesModule // ※重點
  ],
  providers: [
    ShoppingListService,
    RecipeService, {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptorService,
      multi: true
    }
  ],
  bootstrap: [AppComponent],
  entryComponents: [
    AlertComponent,
  ]
})
export class AppModule { }
```
```typescript src\app\recipes\recipes.module.ts
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

import { RecipesComponent } from './recipes.component';
import { RecipeListComponent } from './recipe-list/recipe-list.component';
import { RecipeDetailComponent } from './recipe-detail/recipe-detail.component';
import { RecipeItemComponent } from './recipe-list/recipe-item/recipe-item.component';
import { RecipeStartComponent } from './recipe-start/recipe-start.component';
import { RecipeEditComponent } from './recipe-edit/recipe-edit.component';

@NgModule({
  declarations: [
    RecipesComponent,
    RecipeListComponent,
    RecipeDetailComponent,
    RecipeItemComponent,
    RecipeStartComponent,
    RecipeEditComponent,
  ],
  imports: [
    CommonModule,
  ],
  exports: [
    RecipesComponent,
    RecipeListComponent,
    RecipeDetailComponent,
    RecipeItemComponent,
    RecipeStartComponent,
    RecipeEditComponent,
  ],
})
export class RecipesModule { }
```

其中，exports 屬性是 NgModule 設置，用於將 NgModule 中的組件、指令等導出，從而讓其他模組可以使用它們。如果某個模組中的組件或指令未導出，其他模組就無法直接使用它們。

在使用 exports 屬性時，需要注意以下幾點：

- 可以將 exports 設置為一個組件類型，也可以設置為一個陣列，其中包含多個組件類型。
- 如果 NgModule 中的某個組件或指令被其他模組引用，但未導出，就會報錯。
- 如果要使用某個 NgModule 中導出的組件或指令，可以將該 NgModule 導入到需要使用它們的模組中，並將它們添加到 imports 屬性中。
總之，exports 屬性是一個非常重要的屬性，可以讓我們輕鬆地共用組件、指令等功能，提高代碼的重用性和可維護性。

此時，發現網頁執行可以獲得錯誤資訊`'router-outlet' is not a known element:`。這是由於彼此 module 所 import 的模組都是獨立不共享的，即使 app module 有 import 了 AppRoutingModule，但在 RecipesModule 內因獨立作業因此並沒有繼承路由模組。因此 RecipesModule 集合的這些 Recipe 元件若需要使用 router 就會看不懂（舉例 RecipesComponent.html)。這現象僅限於 Module，唯獨 Service 可以共享使用。

為了解決此事，你需要在指定模組下這些元件若有使用內建模組也需 import 使用。

```typescript src\app\recipes\recipes.module.ts
import { ReactiveFormsModule } from '@angular/forms';
import { RouterModule } from '@angular/router';

@NgModule({
  //...
  imports: [
    CommonModule, //for ngif 相關 common
    RouterModule, // for route path 使用
    ReactiveFormsModule, // for formGroup 使用
  ],
  //...
}
```

### AppRoutingModule 拆分至 RecipesRouteModule
appRoutes 也可以將路由參數進行拆分，如之前介紹過的 Route path 參數可以直接寫在 appModule 透過 RouterModule.forRoot() 完成。我們也可以寫在 RecipesModule 透過 RouterModule.forChild() 來完成。但這裡也是為了簡潔（當時為是另寫 AppRoutingModule 再 import 給 AppModule )，這裡將規劃一個 RecipesRouteModule 提供 import 給 RecipesModule。

- 手動或 cli 指令建立`src\app\recipes\recipes-routing.module.ts`為 RecipesRoutingModule
- 將 AppRoutingModule 與 Recipe 有關的路由都搬移到 RecipesRoutingModule
- 參考兩者寫法，在 RecipesRoutingModule 內需要使用 RouterModule.forChild 並 exports 供其他模組使用。
- 於 RecipesModule 相同方式，import 此 RecipesRoutingModule

```typescript src\app\app-routing.module.ts
// ...
// import { AuthGuard } from './auth/auth-guard.service';
// import { RecipesComponent } from './recipes/recipes.component';
// import { RecipeStartComponent } from './recipes/recipe-start/recipe-start.component';
// import { RecipeDetailComponent } from './recipes/recipe-detail/recipe-detail.component';
// import { RecipeEditComponent } from './recipes/recipe-edit/recipe-edit.component';
// import { RecipesResolverService } from './recipes/recipes-resolver.service';

const appRoutes: Routes = [
  { path: '', redirectTo: '/recipes', pathMatch: 'full' },
  // {
  //   path: 'recipes',
  //   component: RecipesComponent,
  //   canActivate: [AuthGuard],
  //   children: [
  //     { path: '', component: RecipeStartComponent },
  //     { path: 'new', component: RecipeEditComponent },
  //     {
  //       path: ':id',
  //       component: RecipeDetailComponent,
  //       resolve: [RecipesResolverService]
  //     },
  //     {
  //       path: ':id/edit',
  //       component: RecipeEditComponent,
  //       resolve: [RecipesResolverService]
  //     }
  //   ]
  // },
  { path: 'shopping-list', component: ShoppingListComponent },
  { path: 'auth', component: AuthComponent }
];

@NgModule({
  imports: [RouterModule.forRoot(appRoutes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```
```typescript src\app\recipes\recipes-routing.module.ts
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule, Routes } from '@angular/router';

import { AuthGuard } from '../auth/auth-guard.service';
import { RecipesComponent } from './recipes.component';
import { RecipeStartComponent } from './recipe-start/recipe-start.component';
import { RecipeDetailComponent } from './recipe-detail/recipe-detail.component';
import { RecipeEditComponent } from './recipe-edit/recipe-edit.component';
import { RecipesResolverService } from './recipes-resolver.service';

const recipesRoutes: Routes = [
  {
    path: 'recipes',
    component: RecipesComponent,
    canActivate: [AuthGuard],
    children: [
      { path: '', component: RecipeStartComponent },
      { path: 'new', component: RecipeEditComponent },
      {
        path: ':id',
        component: RecipeDetailComponent,
        resolve: [RecipesResolverService]
      },
      {
        path: ':id/edit',
        component: RecipeEditComponent,
        resolve: [RecipesResolverService]
      }
    ]
  },
]
  ;

@NgModule({
  imports: [RouterModule.forChild(recipesRoutes)],
  exports: [RouterModule]
})
export class RecipesRoutingModule { }
```
```typescript src\app\recipes\recipes.module.ts
//...
import { RecipesRoutingModule } from './recipes-routing.module'; // ※重點

@NgModule({
  // ...
  imports: [
    CommonModule, 
    RouterModule, 
    ReactiveFormsModule, 
    RecipesRoutingModule // ※重點
  ],
  //...
})
export class RecipesModule { }
```

> 如先前所說，目前的 Recipe 相關 Component 都被規畫到 RecipesModule 內，對於 AppComponent 或子元件並沒有出現使用 Recipe 相關元件，因此 RecipesModule 不需要將 Recipe 相關 Component 進行 export 提供 AppModule 使用。

### 練習規劃 ShoppingList Feature Module
試著也將 ShoppingList 獨立拆分為一個 shopping-list.module.ts

- 手動或 CLI 指令`ng g m shopping-list`規劃 src\app\shopping-list\shopping-list.module.ts
- 搬移 AppModules 內跟 shoppingList 有關的兩組元件至 ShoppingListModule
- 搬移 AppRoutingModule 內跟 shoppingList 有關的一組 path，由於很少可直接寫至 ShoppingListModule
- 同上，寫在 import 並使用 RouterModule.forChild() 方式填入
- ShoppingListModule 會用到表單模組
- 最後回到 AppModules，將此 ShoppingListModule 進行 import

```typescript src\app\shopping-list\shopping-list.module.ts
import { FormsModule } from '@angular/forms';
import { RouterModule } from '@angular/router';
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ShoppingListComponent } from './shopping-list.component';
import { ShoppingEditComponent } from './shopping-edit/shopping-edit.component';

@NgModule({
  declarations: [
    ShoppingListComponent,
    ShoppingEditComponent,
  ],
  imports: [
    CommonModule,
    FormsModule,
    RouterModule.forChild([
      { path: 'shopping-list', component: ShoppingListComponent },
    ])
  ]
})
export class ShoppingListModule { }
```
```typescript src\app\app-routing.module.ts
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
// import { ShoppingListComponent } from './shopping-list/shopping-list.component';
import { AuthComponent } from './auth/auth.component';

const appRoutes: Routes = [
  { path: '', redirectTo: '/recipes', pathMatch: 'full' },
  // { path: 'shopping-list', component: ShoppingListComponent },
  { path: 'auth', component: AuthComponent }
];

@NgModule({
  imports: [RouterModule.forRoot(appRoutes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```
```typescript src\app\app.module.ts
//...
// import { ShoppingListComponent } from './shopping-list/shopping-list.component';
// import { ShoppingEditComponent } from './shopping-list/shopping-edit/shopping-edit.component';

@NgModule({
  declarations: [
    AppComponent,
    HeaderComponent,
    // ShoppingListComponent,
    // ShoppingEditComponent,
    DropdownDirective,
    AuthComponent,
    LoadingSpinnerComponent,
    AlertComponent,
  ],
  imports: [
    BrowserModule,
    FormsModule,
    ReactiveFormsModule,
    HttpClientModule,
    AppRoutingModule,
    RecipesModule,
    ShoppingListModule // ※重點
  ],
  providers: [
    ShoppingListService,
    RecipeService, {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptorService,
      multi: true
    }
  ],
  bootstrap: [AppComponent],
  entryComponents: [
    AlertComponent,
  ]
})
export class AppModule { }
```

## 共享模組 Shard Modules
SharedModule 是一個用來匯出多個模組、元件、指令和服務的模組。這樣可以減少程式碼的重複性、提升模組的可重用性和可維護性。一般來說，在一個大型專案中，會有許多模組需要被多個元件或模組共用。如果每個元件或模組都要單獨引入這些模組，不僅會增加程式碼的複雜度，也會降低可維護性。因此，可以建立一個 SharedModule 模組，將這些常用的模組匯出，然後在其他模組中引入 SharedModule 就可以直接使用這些模組，而不需要重複引入。

如果在兩個 featureModule 持有部分相同的元件指令管道甚至模組，為了維護最佳化可以將這些持有相同的集合新規劃一個 SharedModule 再匯回這兩個 featureModule。

>注意的是如果持有相同的是內建模組（舉例 CommonModule)，是可以不用特別放入 sharedModule，這不會使效能變佳。本範例僅示範破例這樣做。

目前有一些元件被聲明於 appModule 內，供應整個 app 可以使用。為了精簡化代碼，理應規畫於 sharedModule，並在指定的 featureModule 內進行匯入與聲明。

- 手動或指令`ng g m shared`增加 src\app\shared\shared.module.ts
- 將 AlertComponent, LoadingSpinnerComponent, DropdownDirective 聲明給 SharedModule，若需讓其他模組使用此 SharedModule 的元件指令模組管道就需要 export 出來。
- 同上，由於 Alert 是動態元件要聲明 entryComponents 於內。

```typescript src\app\shared\shared.module.ts
import { DropdownDirective } from './dropdown.directive';
import { LoadingSpinnerComponent } from './loading-spinner/loading-spinner.component';
import { AlertComponent } from './alert/alert.component';
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

@NgModule({
  declarations: [
    AlertComponent,
    LoadingSpinnerComponent,
    DropdownDirective
  ],
  imports: [
    CommonModule
  ],
  exports: [
    AlertComponent,
    LoadingSpinnerComponent,
    DropdownDirective,
    CommonModule
  ],
  entryComponents: [
    AlertComponent,
  ]
})
export class SharedModule { }
```

此時，將 SharedModule 匯入給 RecipesModule 與 ShoppingListModule，如此一來這兩個 feature 就能使用該 SharedModule 內的指定元件指令管道模組。也能消除自己原先綁定的重複模組或元件

> 這裡的 CommonModule 是示範可以消除，這種內建模組其實可以不用做在 sharedModule

```typescript src\app\recipes\recipes.module.ts
// ...
// import { CommonModule } from '@angular/common';
import { SharedModule } from './../shared/shared.module';

@NgModule({
  declarations: [
    RecipesComponent,
    RecipeListComponent,
    RecipeDetailComponent,
    RecipeItemComponent,
    RecipeStartComponent,
    RecipeEditComponent,
  ],
  imports: [
    // CommonModule,
    RouterModule, 
    ReactiveFormsModule,
    RecipesRoutingModule,
    SharedModule // ※重點
  ],
  exports: [
  ],
})
export class RecipesModule { }
```
```typescript
// ...
// import { CommonModule } from '@angular/common';
import { SharedModule } from './../shared/shared.module';

@NgModule({
  declarations: [
    ShoppingListComponent,
    ShoppingEditComponent,
  ],
  imports: [
    // CommonModule,
    FormsModule,
    RouterModule.forChild([
      { path: 'shopping-list', component: ShoppingListComponent },
    ]),
    SharedModule  // ※重點
  ]
})
export class ShoppingListModule { }
```

然而要注意的是，目前執行上出現錯誤 compiler.js:2420 Uncaught Error: Type DropdownDirective is part of the declarations of 2 modules。

Component 不像 Module 那樣可以多次被任何需要的 feature 進行重複性 import 使用，Component 只能一次性被 declarations 聲明。因此以 DropdownDirective 而言被宣告在 appModule 與 sharedModule 有錯。

- 相較 haredModule 去取消 appModule 出現的重複元件。
- 在 appModule 內進行 haredModule 的 import，如此一來 appModule 仍可以使用這些元件。

```typescript src\app\app.module.ts
// ...
// import { DropdownDirective } from './shared/dropdown.directive';
// import { LoadingSpinnerComponent } from './shared/loading-spinner/loading-spinner.component';
// import { AlertComponent } from './shared/alert/alert.component';
import { SharedModule } from './shared/shared.module';

@NgModule({
  declarations: [
    AppComponent,
    HeaderComponent,
    AuthComponent,
    // DropdownDirective,
    // LoadingSpinnerComponent,
    // AlertComponent,
  ],
  imports: [
    BrowserModule,
    FormsModule,
    ReactiveFormsModule,
    HttpClientModule,
    AppRoutingModule,
    RecipesModule,
    ShoppingListModule,
    SharedModule  // ※重點
  ],
  providers: [
    ShoppingListService,
    RecipeService, {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptorService,
      multi: true
    }
  ],
  bootstrap: [AppComponent],
  // entryComponents: [
  //   AlertComponent,
  // ]
})
export class AppModule { }
```

注意，由於模組中的服務是在根注入器中註冊的，因此在 SharedModule 中匯出的服務也會被其他模組共用。如果在某個模組中需要自己定義一個服務，建議不要將這個服務加入到 SharedModule 的 providers 中，而是在該模組自己的 providers 中定義。這樣可以避免服務被多個模組共用時產生的問題。

## 核心模組 Core Modules
CoreModule 是一個用來放置應用程式的共享模組。這個模組通常只會被 AppModule 引用一次，並且會在應用程式一開始就載入，主要負責提供應用程式級別的服務、設定及其他共享資源。以下是 CoreModule 可能會包含的內容：

- HTTP 服務：提供應用程式全域共用的 HTTP 服務，讓你可以輕鬆地透過 DI 注入服務到任何元件中。
- 路由設定：在 CoreModule 中設定應用程式的路由，並載入路由器相關的模組。
- 共用服務：如果有多個元件需要存取同一份資料，可以把資料儲存在共用服務中，並在 CoreModule 中提供這些服務。
- 錯誤處理器：定義全域的錯誤處理邏輯，例如在 HTTP 請求失敗時要顯示錯誤訊息。
- 日誌服務：提供全域的日誌記錄功能，例如透過 console.log 輸出日誌，或是把日誌寫入檔案中。
- 語言本地化：提供全域的多語系支援，例如在不同語言環境下顯示不同的文字。

CoreModule 可以讓你將應用程式的共享邏輯從其他模組中抽離出來，並在應用程式一開始就載入。這樣可以讓你的程式碼更乾淨、更易於維護，並且可以提高程式碼的重用性和可讀性。

### 建立 CoreModule
將 appModule 內的服務數定拆分為 coreModule，這部分僅限定有宣告寫在 appModule 的服務，不包含自身持有`@Injectable({ providedIn: 'root' })`的服務，後者的宣告方式不需要填寫於 appModule 的 providers，同理也不會整理到 coreModule 的 providers 裡。

- 手動或 CLI 指令`ng g m core`建立於 src\app\core\core.module.ts
- 將 AppModule 的 providers 搬移至 CoreModule

```typescript src\app\core\core.module.ts
import { NgModule } from '@angular/core';

import { AuthInterceptorService } from '../auth/auth-interceptor.service';
import { ShoppingListService } from '../shopping-list/shopping-list.service';
import { RecipeService } from '../recipes/recipe.service';
import { HTTP_INTERCEPTORS } from '@angular/common/http';

@NgModule({
  providers: [
    ShoppingListService,
    RecipeService, {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptorService,
      multi: true
    }
  ],
})
export class CoreModule { }
```
```typescript src\app\app.module.ts
// ...
// import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { HttpClientModule } from '@angular/common/http';
// import { AuthInterceptorService } from './auth/auth-interceptor.service';
// import { ShoppingListService } from './shopping-list/shopping-list.service';
// import { RecipeService } from './recipes/recipe.service';
import { CoreModule } from './core/core.module';

@NgModule({
  declarations: [
    AppComponent,
    HeaderComponent,
    AuthComponent,
  ],
  imports: [
    BrowserModule,
    FormsModule,
    ReactiveFormsModule,
    HttpClientModule,
    AppRoutingModule,
    RecipesModule,
    ShoppingListModule,
    SharedModule,
    CoreModule
  ],
  // providers: [
  //   ShoppingListService,
  //   RecipeService, {
  //     provide: HTTP_INTERCEPTORS,
  //     useClass: AuthInterceptorService,
  //     multi: true
  //   }
  // ],
  bootstrap: [AppComponent],
})
export class AppModule { }
```

## 重構練習：auth Feature Module
綜合以上觀念，再次嘗試將 appModule 內的 auth 元件與相關工作，拆分解為 authModule

- 手動或 CLI 指令建立 src\app\auth\auth.module.ts
- 將 AppModule 內 declarations 的 AuthComponent 部分搬移至 AuthModule
- 現在 AppModule 內只剩 AppComponent 與 HeaderComponent，這些都用不到 FormsModule 除了 AuthComponent，這也一併搬走
- 將 AppRoutingModule 關於 auth 的 path 也搬移至 AuthModule

```typescript src\app\auth\auth.module.ts
import { SharedModule } from './../shared/shared.module';
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

import { AuthComponent } from './auth.component';
import { FormsModule } from '@angular/forms';
import { RouterModule } from '@angular/router';

@NgModule({
  declarations: [
    AuthComponent,
  ],
  imports: [
    CommonModule,
    FormsModule,
    RouterModule.forChild([
      { path: 'auth', component: AuthComponent }
    ]),
  ]
})
export class AuthModule { }
```
```typescript src\app\app.module.ts
// ...
// import { AuthComponent } from './auth/auth.component';
// import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { ReactiveFormsModule } from '@angular/forms';
import { AuthModule } from './auth/auth.module';

@NgModule({
  declarations: [
    AppComponent,
    HeaderComponent,
    // AuthComponent,
  ],
  imports: [
    BrowserModule,
    // FormsModule,
    ReactiveFormsModule,
    HttpClientModule,
    AppRoutingModule,
    RecipesModule,
    ShoppingListModule,
    SharedModule,
    CoreModule,
    AuthModule
  ],
  bootstrap: [AppComponent],
})
export class AppModule { }
```

此時執行時出現錯誤 'app-loading-spinner' is not a known element，由於 loading-spinner 元件被聲明於 sharedModule，為了取得此元件你需要讓 AuthModule 進行 SharedModule 的 import，才能認得此 loading 元件。

```typescript src\app\auth\auth.module.ts
imports: [
  CommonModule,
  FormsModule,
  RouterModule.forChild([
    { path: 'auth', component: AuthComponent }
  ]),
  SharedModule
]
```

## 延遲加載 lazy Loading 
是一種在需要時才加載某些功能模塊的技術，這樣可以大大減少應用程序的初始化時間和內存佔用。預設 angular 的開發情況採用 Eager loading 積極載入方式，當下拜訪'/'目錄時除了存取本該此頁面的模組元件等資源，也會將所其他子路由的模組元件等資源都加載。產生很多不必要的資源等待，我們可以透過通過路由機制來實現 lazy Loading。有拜訪指定路由時僅加載該路由頁面上所需的資源即可，具體步驟如下：

- 定義一個子路由，該子路由將要 lazy Loading 的模塊鏈接到該路由下。
- 在路由模塊中將該子路由定義為 lazy Loading 模式，即使用 loadChildren 屬性指向一個回調函數，在該函數中動態加載該模塊。

### 將 RecipesModule 接到指定路由下才存取
要使 lazy Loading 工作，該 Feature Module 必須自帶路由規則 Module。並且將該路由最上層的路徑設定為空，改由 AppRoutingModule 來指定路徑並追加設定 lazy Loading 參數。

```typescript src\app\recipes\recipes-routing.module.ts
{
  // path: 'recipes',
  path: '',
  component: RecipesComponent,
  canActivate: [AuthGuard],
  children: [
    { path: '', component: RecipeStartComponent },
    { path: 'new', component: RecipeEditComponent },
    {
      path: ':id',
      component: RecipeDetailComponent,
      resolve: [RecipesResolverService]
    },
    {
      path: ':id/edit',
      component: RecipeEditComponent,
      resolve: [RecipesResolverService]
    }
  ]
},
```

回到 AppRoutingModule，我們重新加回 path: 'recipes' 部分，第二個屬性不再是 component 而是改為 loadChildren。一旦觸發此路由，要求 Angular 只需加載我們所指定的內容模塊 RecipesModule 且指定一個相對路徑，以及要求該路徑內容底下的指定#別名 (class Name 為 RecipesModule) 對象。

```typescript src\app\app-routing.module.ts
const appRoutes: Routes = [
  { path: '', redirectTo: '/recipes', pathMatch: 'full' },
  { path: 'recipes', loadChildren: './recipes/recipes.module#RecipesModule' }, //fore es2015
  // { path: 'recipes', loadChildren: () => import('./recipes/recipes.module').then(m => m.RecipesModule) } // for es2020+
];
```

> 如果你的 Angular 專案預設不是使用 es2015 作為 --module 的設定（可觀察 tsconfig.json) 或更高 es 版本導致語法錯誤，可改使用動態 import 方式做為替代語法。

目前而言已經將 RecipesModule 成功禁止一開始進行加載，只有當拜訪該 recipes 路徑才會讀取 RecipesModule。另外還有重要的問題在 AppModule 內我們有加載 RecipesModule 會導致找不到此模組。因此也需拔除

```typescript src\app\app.module.ts
// ...
// import { RecipesModule } from './recipes/recipes.module';

@NgModule({
  declarations: [
    AppComponent,
    HeaderComponent,
  ],
  imports: [
    BrowserModule,
    ReactiveFormsModule,
    HttpClientModule,
    AppRoutingModule,
    // RecipesModule,
    ShoppingListModule,
    SharedModule,
    CoreModule,
    AuthModule
  ],
  bootstrap: [AppComponent],
})
export class AppModule { }
```

> import 語句也需拔除，否則以 import 特性來說將會一起打包而不會解決下載之效能問題。

最後重新啟用 ng serve 檢查運作。

### 同理 lazy 規劃 AuthModule 與 ShoppingListModule
相同方式嘗試規劃 AuthModule 與 ShoppingListModule，如下：

```typescript src\app\shopping-list\shopping-list.module.ts
RouterModule.forChild([
  // { path: 'shopping-list', component: ShoppingListComponent },
  { path: '', component: ShoppingListComponent },
]),
```
```typescript src\app\auth\auth.module.ts
RouterModule.forChild([
  // { path: 'auth', component: AuthComponent }
  { path: '', component: AuthComponent }
]),
```
```typescript src\app\app-routing.module.ts
const appRoutes: Routes = [
  { path: '', redirectTo: '/recipes', pathMatch: 'full' },
  { path: 'recipes', loadChildren: './recipes/recipes.module#RecipesModule' }, //fore es2015
  { path: 'shopping-list', loadChildren: './shopping-list/shopping-list.module#ShoppingListModule' }, //fore es2015
  { path: 'auth', loadChildren: './auth/auth.module#AuthModule' }, //fore es2015
];
```
```typescript src\app\app.module.ts
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { ReactiveFormsModule } from '@angular/forms';
import { HttpClientModule } from '@angular/common/http';

import { AppComponent } from './app.component';
import { HeaderComponent } from './header/header.component';
import { AppRoutingModule } from './app-routing.module';
import { SharedModule } from './shared/shared.module';
import { CoreModule } from './core/core.module';
// import { AuthModule } from './auth/auth.module';
// import { RecipesModule } from './recipes/recipes.module';
// import { ShoppingListModule } from './shopping-list/shopping-list.module';

@NgModule({
  declarations: [
    AppComponent,
    HeaderComponent,
  ],
  imports: [
    BrowserModule,
    ReactiveFormsModule,
    HttpClientModule,
    AppRoutingModule,
    // RecipesModule,
    // ShoppingListModule,
    // AuthModule
    SharedModule,
    CoreModule,
  ],
  bootstrap: [AppComponent],
})
export class AppModule { }
```

### Preloading 預加載機制
預加載機制 (Preloading) 是指在瀏覽器空閒的時間，提前載入未來可能需要用到的模組，以提升應用程式的速度和效能。相較於延遲載入 (lazy loading)，預加載能讓使用者更快速地瀏覽網站，提供更好的使用體驗。在 Angular 中，可以使用 PreloadAllModules 或 PreloadingStrategy 來實現預加載機制。

#### PreloadAllModules
Angular 預設提供了 PreloadAllModules 策略，它會在應用程式載入完成後，自動下載所有被 lazy loaded 的模組。你可以在 app.module.ts 中加入以下程式碼啟用預設的 PreloadAllModules 策略：

```typescript src\app\app-routing.module.ts
import { Routes, RouterModule, PreloadAllModules } from '@angular/router';
// ...

@NgModule({
  imports: [RouterModule.forRoot(appRoutes, {
    preloadingStrategy: PreloadAllModules
  })],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```

#### 自訂預加載策略
你也可以自訂預加載策略，以下是一個簡單的範例程式碼（未套入此素材做說明）。先規劃一組 service，要求傳遞 Route 參數進來，判斷 route 底下有無指定 data.preload 值，並回傳一個具可觀察的布林值或 null。

```typescript custom-preloading.strategy.ts
import { Injectable } from '@angular/core';
import { PreloadingStrategy, Route } from '@angular/router';
import { Observable, of } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class CustomPreloadingStrategy implements PreloadingStrategy {
  preload(route: Route, fn: () => Observable<any>): Observable<any> {
    if (route.data && route.data.preload) return fn();
    else return of(null);
  }
}
```

將此規則寫入 appRoutingModule

```typescript src\app\app-routing.module.ts
import { Routes, RouterModule, PreloadAllModules } from '@angular/router';
import {CustomPreloadingStrategy} from './custom-preloading.strategy.ts';
// ...

@NgModule({
  imports: [RouterModule.forRoot(appRoutes, {
    preloadingStrategy: CustomPreloadingStrategy
  })],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```

接著有要預加載的 lazy Feature Module 添加 data.preload 屬性

```typescript src\app\app-routing.module.ts
const appRoutes: Routes = [
  { path: '', redirectTo: '/recipes', pathMatch: 'full' },
  { path: 'recipes', loadChildren: './recipes/recipes.module#RecipesModule' }, //fore es2015
  { path: 'shopping-list', loadChildren: './shopping-list/shopping-list.module#ShoppingListModule' }, //fore es2015
  { 
    path: 'auth', 
    loadChildren: './auth/auth.module#AuthModule', 
    data: { preload: true } }
];
```

## 模組與服務共用
Service 經集合 providers 宣告於不同模組內，會根據 providers 的層級是否於相同模組或整份 App 來形成共用。以下建立測試用的 Service 並列舉一些模組上組合呼喚。

- 手動或 CLI 指令`ng g s log-test --skip-tests`建立 src\app\log-test.service.ts
- 這個 Service 會根據兩個模組順序透過 ngOnInit 執行 print，確認兩者 Module 是否共享此 Service 用。

```typescript src\app\log-test.service.ts
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class LogTestService {
  lastLog: string;
  printLog(message: string) {
    console.log('now:' + message);
    console.log('last:' + this.lastLog);
    this.lastLog = message;
  }
}
```

接下來以下情境請試著觀察拜訪 AppComponent & ShoppingListComponent 的 console 訊息。

### LogTestService :: providedIn: 'root'
目前 Service 編寫為`providedIn: 'root'`，因此不用修改 AppModule 添加 providers，理應全部 App 應用都應共享。

- 添加服務執行於 AppComponent 的 constructor 與 ngOnInit
- 添加服務執行於 ShoppingListComponent 的 constructor 與 ngOnInit

```typescript src\app\app.component.ts
export class AppComponent implements OnInit {
  constructor(
    private AuthService: AuthService,
    private LogTestService: LogTestService // ※重點
  ) { }

  ngOnInit(): void {
    this.AuthService.autoSignIn();
    this.LogTestService.printLog('AppComponent'); // ※重點
  }
```
```typescript src\app\shopping-list\shopping-list.component.ts
  constructor(
    private slService: ShoppingListService,
    private LogTestService: LogTestService // ※重點
  ) { }

  ngOnInit() {
    this.ingredients = this.slService.getIngredients();
    this.subscription = this.slService.ingredientsChanged
      .subscribe(
        (ingredients: Ingredient[]) => {
          this.ingredients = ingredients;
        }
      );
    this.LogTestService.printLog('ShoppingListComponent'); // ※重點
  }
```

觀察畫面拜訪 AppComponent（首頁）與 ShoppingListComponent(shopping-list 頁面）可獲得以下訊息。既代表兩個不同元件共享同一個記憶體下之物件。

```powershell
now:AppComponent
last:undefined
# ...
now:ShoppingListComponent
last:AppComponent
```

### AppModule :: providers
- 取消 LogTestService 的 Injectable 
- 改由 AppModule 宣告 `providers: [LogTestService]`。

同樣觀察畫面拜訪有相同訊息，及代表 Service 編寫`providedIn: 'root'`與從 AppModule 編寫 providers 都為代表整份 App 應用都是同樣的共享此記憶體位置。

```powershell
now:AppComponent
last:undefined
# ...
now:ShoppingListComponent
last:AppComponent
```

### CoreModule :: providers
- 取消 AppModule 宣告 `providers: [LogTestService]`
- 改於 CoreModule 宣告 `providers: [LogTestService]`

同樣觀察畫面拜訪有相同訊息，由於 CoreModule 是由 AppModule 拆分出去的，原理相同。

```powershell
now:AppComponent
last:undefined
# ...
now:ShoppingListComponent
last:AppComponent
```

### AppModule :: providers & ShoppingListModule :: providers
- 取消 CoreModule 宣告 `providers: [LogTestService]` 
- 改於 AppModule 宣告 `providers: [LogTestService]`
- 改於 ShoppingListModule 宣告 `providers: [LogTestService]`

同樣觀察畫面拜訪有<mark>undefined</mark>訊息，由於 ShoppingListModule 是事後產生的 lazy 模組，因此加載時會像記憶統重新佈署物件位置，導致這兩個 Service 為不同實體。

```powershell
now:AppComponent
last:undefined
# ...
now:ShoppingListComponent
last:undefined
```

### SharedModule :: providers
SharedModule 同樣立即加載魚 AppModule 與 ShoppingListModule 所使用，嘗試以下作業：

- 取消 ShoppingListModule 宣告 `providers: [LogTestService]` 
- 取消 AppModule 宣告 `providers: [LogTestService]`
- 改於 SharedModule 宣告 `providers: [LogTestService]`

同樣觀察畫面拜訪有<mark>undefined</mark>訊息，由於 ShoppingListModule 是事後產生的 lazy 模組，因此當下才會加載 SharedModule，同樣會記憶統重新佈署物件位置，導致這兩個 Service 為不同實體。

```powershell
now:AppComponent
last:undefined
# ...
now:ShoppingListComponent
last:undefined
```

### 結論
不論如何因由於 lazy Loading 關係，事後加載執行的都會是另一個實體化記憶體位置。因此需要特別注意模組加載 Service 是否是事後發生行為，預設編寫法則是以 root 整份應用確保記憶體共用於相同記憶體實體位置。

--- 
# 參考文獻
- [Udemy Angular - The Complete Guide (2023 Edition)](https://www.udemy.com/course/the-complete-guide-to-angular-2/) SESSION 22, 23, 24
- [Angular - NgModules](https://angular.io/guide/ngmodules)
- [Angular - NgModule FAQ](https://angular.io/guide/ngmodule-faq)