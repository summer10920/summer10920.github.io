---
title: '[學習之路] JS 前端框架 Angular - 元件和數據綁定'
categories:
  - Zero Road
  - Angular
tag:
  - Angular
  - JavaScript
date: 2022-04-15 14:15:57
---

![](https://i.imgur.com/WC5iApN.png)
前面介紹了基本安裝與工作環境，並且理解基本的資料綁定與內建指令。這裡會介紹元件和資料綁定的深入探討細節。
<!-- more -->

# 前置準備
本篇的起始素材放置於 GitHub 底下提供使用，使用資料目錄 lokiSecond 作為初始環境。下載請記得 npm install 初始化環境。

>[Github download](https://github.com/summer10920/angularTraining) at lokiSecond-start Folder

{% note info %}
  **小技巧：關於 Bootstrap In Angular**
  因為有使用 Bootstrap5 美化，如專案需要可自行安裝`npm install bootstrap`，並對 angular.json 的`styles:[]`多添加
  
```json angular.json
  "styles": [
    "node_modules/bootstrap/dist/css/bootstrap.min.css",
    "src/styles.css"
  ],
```
就能在 Angular 內使用 Bootstrap，載入 CSS 的位置還有其他方式可參考 [3+ Ways to Add Bootstrap 4 to Angular 10/9 With Example & Tutorial | Techiediaries](https://www.techiediaries.com/angular-bootstrap/) 說明教學。
{% endnote%}

素材的內容為提供標題與內容輸入，且提供兩個按鈕進行不同的 Card 列表並有些差異效果。大致上都是根據之前學過的語法來完成這些工作。現在都是同一份元件來進行作業。也許是讓文件更清爽好懂，分開元件使得工作更局部完整。

# 拆解 Component
根元件 app 應該保持簡潔，盡可能將代碼塞入其他子元件利用勘套的方式來完成。也能將小元件被重複使用。分開想法為將上列的輸入操作規劃為 cockpit 元件，下列的 card list 結果規劃為 server-element 元件。

透過 CLI 指令快速建立元件，完成後能在 app 目錄下多兩個元件目錄。

```shell
ng g c cockpit
ng g c server-el
```

接著將 app 元件內整理一下，跟隨以下步驟處理：

- 將 app-root 內的 hr 上半部`div.row`剪貼到 cockpit html 內。並替換成元件名稱。
```html app.component.html
<div class="container">
  <app-cockpit></app-cockpit>
  <hr>
  <!-- ... -->
</div>
```
```html cockpit.component.html
<div class="row">
  <div class="col-xs-12">
    <p>Add new Servers or blueprints!</p>
    <label>Server Name</label>
    <input
      type="text"
      class="form-control"
      [(ngModel)]="newServerName"
    >
    <label>Server Content</label>
    <input
      type="text"
      class="form-control"
      [(ngModel)]="newServerContent"
    >
    <br>
    <button
      class="btn btn-primary"
      (click)="onAddServer()"
    >Add Server</button>
    <button
      class="btn btn-primary"
      (click)="onAddBlueprint()"
    >Add Server Blueprint</button>
  </div>
</div>
```
- 利用 IDE 編輯器的報錯，cockpit 有使用到兩個屬性與兩個方法。一樣搬移到自己的 ts 內。
```ts cockpit.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-cockpit',
  templateUrl: './cockpit.component.html',
  styleUrls: ['./cockpit.component.css']
})
export class CockpitComponent {
  newServerName = '';
  newServerContent = '';

  onAddServer() {
    this.serverElements.push({
      type: 'server',
      name: this.newServerName,
      content: this.newServerContent
    });
  }

  onAddBlueprint() {
    this.serverElements.push({
      type: 'blueprint',
      name: this.newServerName,
      content: this.newServerContent
    });
  }
}
```
- 現在又報錯 serverElements 屬性缺少，我們先擱著，因為這個屬性另一個 server-el 也要用到。
- 原本需要將 app-root 內的 hr 下半部`div.row`剪貼到 server-el html 內，但因為有迴圈我們應該讓 server-el 為單筆 card 資訊，讓 app-root 能重複使用我們的小元件。因此剪貼範圍縮到 card 本身，並替換成元件名稱且執行 ngFor。
```html app.component.html
<div class="container">
  <app-cockpit></app-cockpit>
  <hr>
  <div class="row">
    <div class="col-xs-12">
      <app-server-el *ngFor="let element of serverElements"></app-server-el>
    </div>
  </div>
</div>
```
```html server-el.component.html
<div class="card mb-3">
  <div class="card-header">{{ element.name }}</div>
  <div class="card-body">
    <p>
      <strong
        *ngIf="element.type === 'server'"
        style="color: red"
      >{{ element.content }}</strong>
      <em *ngIf="element.type === 'blueprint'">{{ element.content }}</em>
    </p>
  </div>
</div>
```
- 現在這個 server-el 的 ts 也報錯，因為 element 屬性來自於 ngFor 批次出來的變數，但 ngFor 跑到上層元件去也是找不到。

最後，目前來說隨著分解元件導致有些通信斷掉。我們需要讓元件之間能傳遞資訊十分重要，接下來討論如何修好它。大致上的方向為 app 與 element-el 如何執行屬性綁定（讀取資料），以及 app 與 cockpit 如何執行事件綁定（寫入資料）。而資料會在 app 元件上等待兩個下層元件進行寫取。

# 元件之間的互動（屬性與事件綁定）
稍微盤點一下 Property & Event Binding 有在各話題上的綁定用途

- HTML Elements
透過元素的原生屬性來做一些事件，也就一開始學的基礎東西。像是控制 disable 屬性要不要執行、將事件綁定給屬性如 click 事件做些資料發送，甚至使用$event 獲得輸入值。全都是對元素進行屬性上的事件綁定。
- Directives
使用指令做些事情，像是 ngClass 與 ngStyle 這些，也使用屬性綁定來實現它。
- Component
對於元件的操作綁定用途，我們將歸入自訂的屬性與事件。優先示範使用屬性綁定來處理我們的元件屬性，下一個是事件綁定。

## 公開 server-el 屬性綁定 @Input
處理 server-el 問題之前，我們先將另一個 cockpit 元件內的方法註解掉，先專心處理 server-el 元件的問題。
```ts cockpit.component.ts
onAddServer() {
  // this.serverElements.push({
  //   type: 'server',
  //   name: this.newServerName,
  //   content: this.newServerContent
  // });
}

onAddBlueprint() {
  // this.serverElements.push({
  //   type: 'blueprint',
  //   name: this.newServerName,
  //   content: this.newServerContent
  // });
}
```
正式來到 server-el 這邊處理著手問題，我們知道元件缺少了 element 屬性，試著補上並提供強型別（目前並沒有提供值給這個屬性，只單純提供型別）。
```ts server-el.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-server-el',
  templateUrl: './server-el.component.html',
  styleUrls: ['./server-el.component.css']
})
export class ServerElComponent {
  element: { type: string, name: string, content: string };
}
```
回到上層的 app 元件這裡，這裡產生一些靜態假資料，屆時要提供給下層 server-el。
```ts app.component.ts
export class AppComponent {
  serverElements = [
    { type: 'server', name: 'TestName', content: 'TestString!' }
  ];
}
```
目前為止在 app html 的上面能成功跑迴圈產生一筆 card，app 能讀到 app 自己的陣列，但是資料內容 element 我們該如何送進去給下層的 server-el 元件。這是正要討論的問題。如果能類似 disable 那樣透過屬性綁定將 element 資料傳送給我們的下層 server-el 元件，原則上是可行的。為了區別開來 ngFor 的變數名稱換一下。

```html app.component.html
<div class="container">
  <app-cockpit></app-cockpit>
  <hr>
  <div class="row">
    <div class="col-xs-12">
      <app-server-el
        *ngFor="let item of serverElements"
        [element]="item"
      ></app-server-el>
    </div>
  </div>
</div>
```
但事實上會失敗，透過 console 錯誤資訊告知你，屬性 property 本身未定義。這是因為 app 元件本身沒有 element 這個屬性可用。既使下層的 server-el 元件有這個屬性，上層也認不出來。這是在公開權限上的問題，使得上層元件無法知道這個下層元件持有這個屬性而未知存在進行報錯。如果你想讓上層元件能知道下層元件有這個屬性，讓上層元件能綁定該屬性提供給下層，你需要對下層該屬性添加一些動作。

找到下層這個屬性位置，前綴添加`@Input()`，讓 Angular 知道下層的 element 屬性會從其他地方傳過來。現在能成功地從上層 app 將 element 傳遞給下層 server-el，因為下層有寫這個 element 來自於`@Input`。

```ts server-el.component.ts
import { Component, Input } from '@angular/core'; //注意這裡要添加來源處

@Component({
  selector: 'app-server-el',
  templateUrl: './server-el.component.html',
  styleUrls: ['./server-el.component.css']
})
export class ServerElComponent {
  @Input() element: { type: string, name: string, content: string };
}
```

現在透過這個可以成功將元素屬性傳遞給每個下層元件去，並綁定給該元件的元素屬性。這就是下層屬性公開了自己的 element 屬性提供進行輸入。

### 使用屬性別名
你可以使用別名方式讓外部元件以其他名字來傳遞給下層元件，下層元件再換成自己的屬性名稱。透過`@input('別名')`達到。這能幫助你在綁定屬性的命名上避免衝突到，這裡我們別名改成 srcElement 來試試。

```html app.component.html
<app-server-el
  *ngFor="let item of serverElements"
  [srcElement]="item"
></app-server-el>
```
```ts server-el.component.ts
export class ServerElComponent {
  @Input('srcElement') element: { type: string, name: string, content: string };
}
```

## 公開 cockpit 的事件綁定 @Output
接下來處理事件綁定的部分，同樣的我們要思考下層如何將它的資料傳遞出來給上層讓上層可以接受到。我們先處理上層元件，應該是讓上層元件接受一些資訊對自己的 serverElements 陣列進行寫入。相同的我們需要兩個 Method 來做寫入屬性動作。參考後來搬移給 cockpit 的 method 寫法。這裡名稱另外取名為 Done 是因為動作在 cockpit 已執行完畢，app 元件只是負責將它寫入到陣列內。

app 的 Method 會獲得兩個東西，分別是 name 與 content（來自 cockpit 的兩個 input)。因此假定我們透過參數拿到這樣的 object，並注意提供強型別。

```ts app.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  serverElements = [
    { type: 'server', name: 'TestName', content: 'TestString!' }
  ];

  onAddServerDone(serverData: { sName: string, sContent: string }) {
    this.serverElements.push({
      type: 'server',
      name: serverData.sName,
      content: serverData.sContent
    });
  }

  onAddBlueprintDone(serverData: { sName: string, sContent: string }) {
    this.serverElements.push({
      type: 'blueprint',
      name: serverData.sName,
      content: serverData.sContent
    });
  }
}
```

現在只要有誰執行了 app 的 method 就必須要提供參數才能寫入到 app 的屬性資料內。因此與 cockpit 關聯的地方在於 app html 上，我們需要綁定一個事件並提供$event 作為參數讓 app 的 method 能取得資料的 name 與 content。我們先命名創造出兩個 cockpit 根本不存在的名稱作為事件綁定，並能對 app 的 Method 傳遞資料參數，之後還要到 cockpit 裡面創造自定義的事件綁定。

```html app.component.html
<app-cockpit
  (serverCreated)="onAddServerDone($event)"
  (blueprintCreated)="onAddBlueprintDone($event)"
></app-cockpit>
```

來到 cockpit 這裡，元件內先創造兩個不存在的屬性。這兩個屬性是透過 new EventEmitter() 物件來建立，並額外告知強型別為我們指定的 object。

```ts cockpit.component.ts
import { Component, EventEmitter } from '@angular/core'; //宣告 EventEmitter 來源

@Component({
  selector: 'app-cockpit',
  templateUrl: './cockpit.component.html',
  styleUrls: ['./cockpit.component.css']
})
export class CockpitComponent {
  newServerName = '';
  newServerContent = '';
  serverCreated = new EventEmitter<{ sName: string, sContent: string }>();
  blueprintCreated = new EventEmitter<{ sName: string, sContent: string }>();

  onAddServer() {
    // this.serverElements.push({
    //   type: 'server',
    //   name: this.newServerName,
    //   content: this.newServerContent
    // });
  }

  onAddBlueprint() {
    // this.serverElements.push({
    //   type: 'blueprint',
    //   name: this.newServerName,
    //   content: this.newServerContent
    // });
  }
}
```

>EventEmitter 為事件發射器，作為自訂事件觸發與監聽。我們會用到 emit() 來操作要發出去的值。詳情請參閱 [Angular API](https://angular.tw/api/core/EventEmitter)

現在 cockpit 裡面已經準備好兩組自訂事件之屬性，該是考慮讓 cockpit 內的兩個 method 動作下能對該兩個自訂事件塞值進去。我們得透過 emit 來塞值。現在 method 已經大改了，我們替換如下

```ts cockpit.component.ts
export class CockpitComponent {
  newServerName = '';
  newServerContent = '';
  serverCreated = new EventEmitter<{ sName: string, sContent: string }>();
  blueprintCreated = new EventEmitter<{ sName: string, sContent: string }>();

  onAddServer() {
    this.serverCreated.emit({
      sName: this.newServerName,
      sContent: this.newServerContent
    });
  }

  onAddBlueprint() {
    this.blueprintCreated.emit({
      sName: this.newServerName,
      sContent: this.newServerContent
    });
  }
}
```

照理來說，目前的邏輯都很正常也沒有錯誤訊息依然無法提供給上層元件。跟前面的觀念一樣，`@input()`能讓屬性可以從外部進行屬性綁定。而這裡為`@Output`為讓我們的 cockpit 能接受到來自外面的監聽。

```ts cockpit.component.ts
import { Component, EventEmitter, Output } from '@angular/core'; //宣告 Output 來源

@Component({
  selector: 'app-cockpit',
  templateUrl: './cockpit.component.html',
  styleUrls: ['./cockpit.component.css']
})
export class CockpitComponent {
  newServerName = '';
  newServerContent = '';
  @Output() serverCreated = new EventEmitter<{ sName: string, sContent: string }>();
  @Output() blueprintCreated = new EventEmitter<{ sName: string, sContent: string }>();

  onAddServer() {
    this.serverCreated.emit({
      sName: this.newServerName,
      sContent: this.newServerContent
    });
  }

  onAddBlueprint() {
    this.blueprintCreated.emit({
      sName: this.newServerName,
      sContent: this.newServerContent
    });
  }
}
```

恭喜目前可以運作了，其實也就是屬性綁定與事件綁定話題。原本基礎觀念是對同元件下的 html 元素來進行作業，現在擴大到元件之間的通信。而元件之間的通信除了原本的屬性綁定與事件綁定，還要多考量 Input 與 Output，這是因為元件之間彼此獨立互不影響，透過這兩個函式才能外部綁定到內部屬性，或者是從內部接收來自外部的事件監聽。

### 使用不同屬性名稱
跟 Input 一樣，你可以使用別名來做兩者之間通信的名稱。也保護內部屬性的原名稱不曝光。

```html app.component.html
<app-cockpit
  (sLoki)="onAddServerDone($event)"
  (bLoki)="onAddBlueprintDone($event)"
></app-cockpit>
```
```ts cockpit.component.ts
@Output('sLoki') serverCreated = new EventEmitter<{ sName: string, sContent: string }>();
@Output('bLoki') blueprintCreated = new EventEmitter<{ sName: string, sContent: string }>();
```

## 總結
透過這些自訂屬性綁定與事件綁定，你可以讓上下層的父子元件之間進行通信，透過input將父層的資料傳送到子層，而透過output將子層的事件發送給父層被捕捉。

然而，如果是同層的兄弟元件就會比較複雜些，就要利用父元件當跳板傳遞給這些子元件並大量使用到 Input 與 Output，但這不是很實用的一件作法，之後有另外一種 servers 的做法可以讓兄弟元素之間進行通信。

# 元件之間的 View 封裝
你是否過程中發現，分解之前會有藍色字樣的輸出，經過分解與通信修復後，這個藍色的 CSS 效果消失了。這個 p 元素的 style 被設定在 app 的 css 內。其不像過去我們 CSS 觀念上所繼承給下層元件。事實上這是 Angular 的強制行為而不是瀏覽器對 CSS 的默認繼承行為。透過網頁 F12 檢查可以很清楚發現 Angular 會自作主張的對每個元件下的元素添加一些有的沒的。現在試著將這個藍色的效果搬移到 server-el 元件內的 css 看看。

```css server-el.component.css
p {
  color: blue;
}
```

現在再去檢查並嘗試輸入一下欄位送出，會發現藍色字樣跑出來了。透過 F12 檢查可以發現 angular 對 p 元素添加了隨機的屬性名稱，而 css 的選擇器也自動添加這個屬性名稱。這都是 Angular 搞得鬼，這是一個保護機制，意味了我們每個元件都有自己封裝的 View 範圍彼此不受影響而被保護。如果你不想要這樣的保護，你可以編譯到 index.html 那層的 styles.css，那裏才是對整個網頁所影響的樣式表，元件內的樣式表只對該元件有效，這是 Angular 默認行為。

## 取消元件封裝
如果這個元件不想要封裝，也就是不要產生類似影子 DOM，將所有元件下的元素都不要添加相同亂碼的元素屬性某參數。可以找到該元件的 `@Component` 添加 ViewEncapsulation 並指定參數 None 調整 (Emulated 模擬為預設值可以不用寫）。

```ts server-el.component.ts
import { Component, Input, ViewEncapsulation } from '@angular/core'; //宣告來源

@Component({
  selector: 'app-server-el',
  templateUrl: './server-el.component.html',
  styleUrls: ['./server-el.component.css'],
  encapsulation: ViewEncapsulation.None  //關閉封裝功能
  // encapsulation: ViewEncapsulation.Emulated  //預設值，開啟封裝
})
export class ServerElComponent {
  @Input('srcElement') element: { type: string, name: string, content: string };
}
```

現在回頭看一下 F12 發現已經沒有奇怪字串值屬性出現在這個元件內的元素上，同時該元件的 css 部分也不會去添加奇怪字串值屬性。因此現在這個元件下的 css 將會影響整個網頁。舉例

```css server-el.component.css
label{
  color:red;
  font-size: 2rem;
}
```

現在這個效果因為沒有封裝而導致影響到另一個 cockpit 元件內的 label 元素之樣式了。

## 使用本地變數做範本訪問
舉例 cockpit 元件，原本的素材包有使用到 ngModal 來進行雙向綁定。每當我們輸入資料時，會同時的變動元件內的屬性值這是已知做法。事實上在同一份元件的 template 內，我們有更快的方法來取代這個雙向綁定。就是直接對本地進行引用參考。所謂的本地變數就是將 html 元素進行別名使用`#name`作為 html 屬性。

### 透過事件綁定的參數傳遞
接著透過 event binding 作為參數提供給 TS，這樣就能在 ts 內對這個元素進行使用。這裡拿其中一組 input 的 ngModal 做修改示範。

- 對目標 HTML 元素提供 `#inputServerName` 屬性給予一個別名
- 現在在這個 html 內已經存在這個物件，你可以找地方試試`{{inputServerName}}`當做字串輸出
- 將這個別名放在按鈕的事件綁定成為一個本地的變數，當作參數傳遞給 TypeScript
- 由於這個參數的強型別為 HTML 的 input 元素，記得給予 HTMLInputElement 型別，可試著 console.log 看看這是甚麼參數
- 既然獲得了這個元素，很自然能用元素底下的 value 當作我們來源值使用
- 最後，如果修改成功，原本 ts 內的 newServerName 初始屬性也就用不到了

```html cockpit.component.html
<div class="row">
  <div class="col-xs-12">
    <p>Add new Servers or blueprints!</p>
    <label>Server Name</label>
    <!-- <input
      type="text"
      class="form-control"
      [(ngModel)]="newServerName"
    > -->
    <input
      type="text"
      class="form-control"
      #inputServerName
    >
    <label>Server Content</label>
    <input
      type="text"
      class="form-control"
      [(ngModel)]="newServerContent"
    >
    <br>
    <button
      class="btn btn-primary"
      (click)="onAddServer(inputServerName)"
    >Add Server</button>
    <button
      class="btn btn-primary"
      (click)="onAddBlueprint(inputServerName)"
    >Add Server Blueprint</button>
    <!-- 將別名後的元素當作參數傳遞給元件的 method -->
  </div>
</div>
```
```ts cockpit.component.ts
export class CockpitComponent {
  // newServerName = '';  //用不到了
  newServerContent = '';
  @Output('sLoki') serverCreated = new EventEmitter<{ sName: string, sContent: string }>();
  @Output('bLoki') blueprintCreated = new EventEmitter<{ sName: string, sContent: string }>();

  onAddServer(inputEl: HTMLInputElement) {
    //console.log(inputEl); 
    //print  <input _ngcontent-cwy-c41="" type="text" class="form-control">

    //因此我們可以利用 inputEl.value 作為我們來源值
    this.serverCreated.emit({
      sName: inputEl.value,
      sContent: this.newServerContent
    });
  }

  onAddBlueprint(inputEl: HTMLInputElement) {
    this.blueprintCreated.emit({
      sName: inputEl.value,
      sContent: this.newServerContent
    });
  }
}
```
這個方法只限定於本地上使用，同時需要搭配參數的方式傳遞給 TypeScript。

### ViewChild 檢視查詢
如果你不想透過 Method 使用參數方式傳遞給 TypeScript，可以考慮使用`@viewChild`方式來獲得該訪問權限。ViewChild 能透過查詢找到 View 裡面的小孩（需要別名）提取出來，我們拿另一個 input 做修改示範。

- 首先還是需要一個本地變數來實作第一步。這裡命名為 `#inputServerContent`
- 現在不透過 html 這裡的 event binding，而是直接來到 TypeScript 這裡創造一個初始屬性為透過@viewChild 並根據變數別名而獲得的屬性值。
- 嘗試 Console 出來看看，拿到一個 ElementRef。所以回頭補上強型別為 ElementRef，而一開始不認識 ElementRef，所以也要宣告 ElementRef 的來源。
- 要取出 value，就藏在這個物件的 nativeElement.value 底下。所以修改了 Method 改從這裡提取來源值。
- 如此一來我們透過`@viewChild`方式來獲取，直接去訪問 template 範本內的本地變數，而不是透過事件綁定來獲得。

```html cockpit.component.html
<div class="row">
  <div class="col-xs-12">
    <p>Add new Servers or blueprints!</p>
    <label>Server Name</label>
    <!-- <input
      type="text"
      class="form-control"
      [(ngModel)]="newServerName"
    > -->
    <input
      type="text"
      class="form-control"
      #inputServerName
    >
    <label>Server Content</label>
    <!-- <input
      type="text"
      class="form-control"
      [(ngModel)]="newServerContent"
    > -->
    <input
      type="text"
      class="form-control"
      #inputServerContent
    >
    <br>
    <button
      class="btn btn-primary"
      (click)="onAddServer(inputServerName)"
    >Add Server</button>
    <!-- 將別名後的元素當作參數傳遞給元件的 method -->
    <button
      class="btn btn-primary"
      (click)="onAddBlueprint(inputServerName)"
    >Add Server Blueprint</button>
  </div>
</div>
```
```ts cockpit.component.ts
import { Component, EventEmitter, Output, ViewChild, ElementRef } from '@angular/core'; //宣告 Output 來源

@Component({
  selector: 'app-cockpit',
  templateUrl: './cockpit.component.html',
  styleUrls: ['./cockpit.component.css']
})
export class CockpitComponent {
  // newServerName = '';
  // newServerContent = '';  //也用不到了
  @Output('sLoki') serverCreated = new EventEmitter<{ sName: string, sContent: string }>();
  @Output('bLoki') blueprintCreated = new EventEmitter<{ sName: string, sContent: string }>();

  @ViewChild('inputServerContent') inputServerContent: ElementRef;

  onAddServer(inputEl: HTMLInputElement) {
    // console.log(this.inputServerContent);
    // 是 ElementRef 物件

    //因此我們可以利用 this.inputServerContent.nativeElement.value 作為我們來源值
    this.serverCreated.emit({
      sName: inputEl.value,
      // sContent: this.newServerContent
      sContent: this.inputServerContent.nativeElement.value
    });
  }

  onAddBlueprint(inputEl: HTMLInputElement) {

    this.blueprintCreated.emit({
      sName: inputEl.value,
      // sContent: this.newServerContent
      sContent: this.inputServerContent.nativeElement.value
    });
  }
}
```

>目前這兩招都不是透過雙向綁定來取得資料，都是透過本地變數搭配參數傳遞或從 ViewChild 來獲取。但是是直接去對應到元素的記憶體位置，因此不建議你在 TypeScript 去修改 value，這會影響 View 這裡的值被固定住。

# ng-content 內容投影
內容投影是一種模式，你可以在其中插入來自另一個地方中使用的內容進行投影。舉例來說下層的 cockpit 內的 ngFor 想搬到上層元件內（雖然一開始素材就這樣做，這裡只是為了示範有這種神操作）。在那之前有一個觀念要說明，在上層元件的 html 內，使用子元件作為元素替代時，此時該子元件元素下的內容，任何東西都會被 Angular 所捨棄。

```html app.component.html
<app-server-el
  *ngFor="let item of serverElements"
  [srcElement]="item"
>
  這裡寫的任何東西都會被 Angular 所拋棄
</app-server-el>
```

如果子元件內的 html 有指定 ng-content 元素，則代表我有一部份內容投影到來自放在上層元素 html 那裏。為了示範方便把原本的部分代碼註解起來。

```html server-el.component.html
<div class="card mb-3">
  <div class="card-header">{{ element.name }}</div>
  <div class="card-body">
    <!-- 這裡有東西放在爸爸那裏唷 -->
    <ng-content></ng-content>
    <!-- <p>
      <strong
        *ngIf="element.type === 'server'"
        style="color: red"
      >{{ element.content }}</strong>
      <em *ngIf="element.type === 'blueprint'">{{ element.content }}</em>
    </p> -->
  </div>
</div>
```

此時觀看畫面，會發現 card-body 內的這個地方會來自父元件 html 那裏所填寫的子元件內容。這就是 ng-content 的用法。現在把註解的地方搬移到父元件那裏的子元件元素當做內容。然而因為提升到父元件那裏，element 這個變數認不得，但我們可以取到上源父元件這裡的 item 做替換。

```html app.component.html
<div class="container">
  <app-cockpit
    (sLoki)="onAddServerDone($event)"
    (bLoki)="onAddBlueprintDone($event)"
  ></app-cockpit>
  <hr>
  <div class="row">
    <div class="col-xs-12">
      <app-server-el
        *ngFor="let item of serverElements"
        [srcElement]="item"
      >
        <!-- 投影 start，事實上這裡應該還有 card>card-header+card-body -->
        <p>
          <strong
            *ngIf="item.type === 'server'"
            style="color: red"
          >{{ item.content }}</strong>
          <em *ngIf="item.type === 'blueprint'">{{ item.content }}</em>
        </p>
        <!-- 投影 end -->
      </app-server-el>
    </div>
  </div>
</div>
```

現在畫面正常了，事實上子元件還是跑到父元件那裏索討內容，這例子唯一比較搞混的問題是 template 範本內的變數是否存在。ng-content 可以做為取代一些屬性綁定的資料傳送，本身就是一種 HTML 轉義行為，在跨網域 Script 駭客攻擊上有很好的預防效果。

# 元件的生命週期 Hook
生命週期是每一個框架經典需知道的重要觀念。Angular 提供了一些相關流程過程並提供一些方法，允許你監聽指令和元件的生命週期，比如建立、更新和銷燬等。舉例來說每次 CLI 產生的原件就有附加提供 onInit 的 Hook 使用。Angular 會按以下順序呼叫 Hook 鉤子方法：

- ngOnChanges - 在輸入屬性 (input)/輸出屬性 (output) 的繫結值發生變化時呼叫。
- ngOnInit - 在第一次 ngOnChanges 完成後呼叫。
- ngDoCheck - 開發者自訂變更檢測。
- ngAfterContentInit - 在元件內容初始化後呼叫。
- ngAfterContentChecked - 在元件內容每次檢查後呼叫。
- ngAfterContentChecked: After every check of component content.
- ngAfterViewInit - 在元件檢視 (View) 初始化後呼叫。
- ngAfterViewChecked - 在元件檢視 (View) 每次檢查後呼叫。
- ngOnDestroy - 在指令銷燬前呼叫。

> 參閱官方文件關於 [生命週期鉤子（Lifecycle hook）](https://angular.tw/guide/glossary#lifecycle-hook)

當創建一個元件並運行時 Angular 透過 selector 對象找到這個元件開始實體化創建到我們的 DOM，過程上會經歷一些階段。因此我們可以利用這些階段安排一些代碼作業。透過 Angular 提供的方法來進行這些 Hook 動作。

**OnChanges**
第一個 Hook 階段，一開始創建元件時就開始執行，且後續還可能會被執行很多次，當我們屬性綁定的`@Input`或`@Output`接受到新值會再經歷一次。

**OnInit**
第二個 Hook 階段，當元件被初始化後就會被執行，此時還沒有添加到 DOM 上，只是 Angular 正在對元件做基本的初始化，ngOnInit 會在建構函數 constructor 之後執行，

**DoCheck**
第三個階段且只有在變更檢測當下運行。因為第一階段 ngOnChange 的關係也可能影響到到被執行多次。變更檢測只是 Angular 需要確定元件內的 template 或內部資料要確認是否有些內容被更改。譬如某個數字 1 變成 2 並該屬性需要在 template 輸出，那就會需要做變更檢測才能重新渲染這個 template。

有些時候第一階段的 ngDoCheck 會再次運行，因為你可能做了一些沒有改變資料的事件，但由於是一個事件行為，Angular 還是得去進行 ngDoCheck 的變更檢測作業執行。Angular 會確保檢查是否有變。

雖然看起來很吃效能但 Angular 處理得很好沒有花費多少效能，你可以利用變更檢測當下週期做一些 Angular 無法預判到的變化時給予代碼作業。

**AfterContentInit**
第四階段，每當使用 ng-content 內容投影進行初始化時會觸發這個階段。因此不是指該元件本的 View，而是父元件的 View 那裏，尤其是透過內容投影添加到自己元件的 View 時。每當改變檢測檢查時發現到我們的內容投影有更改而被執行，

**AfterViewInit**
第五步驟，當第四步驟完成了該元件的 View 完成初始化後就會達到這階段。

**AfterViewChecked**
第六步驟，前步驟會緊接著將 View 進行被檢查，確保所有的更改都會顯示到 View 內，或者當 Angular 沒有檢測到任何變化時，會進入這個階段。

**OnDestroy**
如果你要銷毀一個元件，例如透過 ngIf 設定為 false，要求 DOM 銷毀掉這個元件，在銷毀之前就會觸發這個階段。

## 連續示範操作
使用剛剛的教材做一下示範流程透過 Console 探討這些 Hook 發生的時機為何。

### ngOnInit()
跳到 server-el 的 ts，也許被我們刪除掉了試著重新使用 ngOnInit。

>使用這些 Hook 需注意要在 Class 後面宣告使用該工具 (implements) 以及宣告來源。每個 Hook 都是獨立實施。

```ts server-el.component.ts
import { Component, Input, ViewEncapsulation, OnInit } from '@angular/core'; //宣告來源

@Component({
  selector: 'app-server-el',
  templateUrl: './server-el.component.html',
  styleUrls: ['./server-el.component.css'],
  encapsulation: ViewEncapsulation.None
})
export class ServerElComponent implements OnInit { //使用工具 OnInit
  @Input('srcElement') element: { type: string, name: string, content: string };

  constructor() {
    console.log('0th is constructor');
  }

  //1st 是 OnChanges 等等談

  ngOnInit() {
    console.log('2nd is ngOnInit');
  }
}
```

當我們執行加載應用程式時，我們會發現這個元件會經歷了 1th 與 2nd 兩個。如果嘗試操作按鈕讓 server-el 元件重複地被使用並實體化出來。會出現 1th > 2nd > 1th > 2nd > ...，因此所有的 Hook 都會再次被執行，因為每次的元件使用都是全新被實體化出來。以及有個共通點在於物件類別 Class 的建構函式之後。

### ngOnChanges()
回到週期的一開始討論到 ngOnChanges 會第一階段被執行。這裡的例子剛好有使用`@Input`可以拿來示範，添加 ngOnChanges 方法來運行。另外再告知這裡事實上能接受到一個參數（只有這個 Hook 才有），他的強型別為 SimpleChanges 故需要宣告來源。

```ts server-el.component.ts
import { Component, Input, ViewEncapsulation, OnInit, OnChanges, SimpleChanges } from '@angular/core'; //宣告來源

@Component({
  selector: 'app-server-el',
  templateUrl: './server-el.component.html',
  styleUrls: ['./server-el.component.css'],
  encapsulation: ViewEncapsulation.None  //關閉封裝功能
})
export class ServerElComponent implements OnInit, OnChanges { //使用工具 OnInit & OnChanges
  @Input('srcElement') element: { type: string, name: string, content: string };

  constructor() {
    console.log('0th is constructor');
  }

  ngOnChanges(changes: SimpleChanges) {
    console.log('1st is ngOnChanges');
    console.log(changes);
/* print 
{element: SimpleChange}
  element: SimpleChange
    currentValue: {type: 'server', name: 'TestName', content: 'TestString!'}
    firstChange: true
    previousValue: undefined
    [[Prototype]]: Object
*/
  }

  ngOnInit() {
    console.log('2nd is ngOnInit');
  }
}
```

查看 changes 參數就是我們的@input 所提供的元素（使用 SimpleChange 型別）。可以獲得一些資訊
- currentValue : 我們因為@input 而獲得資料在 element.currentValue
- firstChange: 這是我們第一次的改變，因為才剛初始化。
- previousValue: 前一次的舊值為 undefined，因為之前還沒有獲得此資料。

也就是說可推理出 ngOnChanges 會發生很多次影響這些 SimpleChanges 不同內容。跟著做以下代碼操作來試著測出這些可能性。

- 到父元件 app，找一個單純地方增加一個按鈕為 Change First Element 並做事件綁定觸發 onChangeOne() 方法
- 同樣父元件 app 需提供一個 onChangeOne() 方法去修改，我們只想更改原本 element.currentValue.name 而已。

```html app.component.html
<div class="container">
  <app-cockpit
    (sLoki)="onAddServerDone($event)"
    (bLoki)="onAddBlueprintDone($event)"
  ></app-cockpit>
  <hr>
  <div class="row">
    <div class="col-xs-12">
      <!-- 放在這，迴圈之外 -->
      <button class="btn btn-danger" (click)="onChangeOne()">Change 1st Element</button>
      <app-server-el
        *ngFor="let item of serverElements"
        [srcElement]="item"
      >
        <!-- 投影 start -->
        <p>
          <strong
            *ngIf="item.type === 'server'"
            style="color: red"
          >{{ item.content }}</strong>
          <em *ngIf="item.type === 'blueprint'">{{ item.content }}</em>
        </p>
        <!-- 投影 end -->
      </app-server-el>
    </div>
  </div>
</div>
```
```ts app.component.ts
export class AppComponent {
  serverElements = [
    { type: 'server', name: 'TestName', content: 'TestString!' }
  ];

  onAddServerDone(serverData: { sName: string, sContent: string }) {
    this.serverElements.push({
      type: 'server',
      name: serverData.sName,
      content: serverData.sContent
    });
  }

  onAddBlueprintDone(serverData: { sName: string, sContent: string }) {
    this.serverElements.push({
      type: 'blueprint',
      name: serverData.sName,
      content: serverData.sContent
    });
  }
  //只對陣列指定處修改值，因為我們要改變值而不是對 serverElements 陣列重寫。
  onChangeOne() {
    this.serverElements[0].name = 'Test by OnChanges again';
  }
}
```

現在觀察畫面，嘗試按下 btn-danger 按鈕，可以成功改寫 Server Name 但是 console.log 不會觸發 OnChanges 執行。因為我們只是更改`@input element{...}`裡面的記憶體內某處的數據，Angular 不會感覺到這個值被改寫而觸發 OnChanges，因此我們要多做一個@input 只感應 name 這個參數。

- 對子元件 server-el 多設計一個`@input name`，因為原本的@input 我們沒有辦法去改變整個陣列
- 對父元件 app 對引用元件的地方做屬性綁定，將我們的 name 提供給子元件。

```ts server-el.component.html
export class ServerElComponent implements OnInit, OnChanges {
  @Input('srcElement') element: { type: string, name: string, content: string };
  @Input() name: String; //為了能被 Angular 偵測到變化，多一個 input 做前後改變

  constructor() {
    console.log('0th is constructor');
  }

  ngOnChanges(changes: SimpleChanges) {
    console.log('1st is ngOnChange');
    console.log(changes);
  }

  ngOnInit() {
    console.log('2nd is ngOnInit');
  }
}
```

現在試著回到畫面，一開始的 ngOnChange 被觸發因為有兩個`@input`提供到 SimpleChange 物件。可以看到第二組`@input`的初始之況狀，接著下一步驟按下 btn-danger 可以又獲得 ngOnChange（且無 0th & 2nd)。經檢查發現第二組`@input`有感受到變化而再次運行提供給我們並得知為修改之況狀（新舊值且非初次變化）。

![](https://i.imgur.com/6GpusZM.png)

最後清楚了解根據以上的示範，換言之可以利用這方法，找出用戶修改前的舊值並把它儲存起來，提供資料復原的神操作。

### ngDoCheck()
能提供每次變更檢測的方法，來示範 ngDoCheck 如何被使用。並透過檢查畫面發現 3rd 的訊息出現（基本上應該只會出現一次，但因為目前在開發模式下 Angular 會多一次進行額外的更改檢測週期）。

```ts server-el.component.ts
export class ServerElComponent implements OnInit, OnChanges, DoCheck {
  @Input('srcElement') element: { type: string, name: string, content: string };
  @Input() name: String;

  constructor() {
    console.log('0th is constructor');
  }

  ngOnChanges(changes: SimpleChanges) {
    console.log('1st is ngOnChange');
    console.log(changes);
  }

  ngOnInit() {
    console.log('2nd is ngOnInit');
  }

  ngDoCheck() {
    console.log('3rd is ngDoCheck');
  }
}
```

現在嘗試去按幾次 btn-danger 來觀察 3rd 在 console 上的時機，如下圖可以解釋出
- 紅色部分 - 因為一開始初始化會進行變更檢測
- 黃色部分 - 因為 ng serve 的開發模式影響多一次額外檢測
- 綠色部分第 1 下 - 按下 btn-danger 也會進行變更檢測（同時因為有變化觸發 ngOnChanges)
- 綠色部分第 2~10 下 - 再次按下 btn-danger 也會進行變更檢測（因為`@input`值沒有變化不會再出現 ngOnChanges)

![](https://i.imgur.com/dwbgjNg.png)

最後每次 Angular 要進行變更檢測時都會觸發這個方法，不管是不是有改還是沒改的 event 事件或是 promise 承諾來觸發（還有其他的觸發器）。但你通常不會在這裡寫太多代碼，不然每次都會被觸發這些代碼很浪費效能，畢竟他運行頻率太頻繁。如果只是開發上的 Debug 測試就蠻適合的。

### ngAfterContentInit()
在經過更改檢查週期之下一階段才進行此部分，透過添加方法並觀察後畫面上的第一組 server 是透過內容投影產生到 View 上面，因此只有一次調用，在此之後就沒有任何重新變化下這裡不會重新初始化。

```ts server-el.component.ts
import {
  Component, Input, ViewEncapsulation,
  OnInit, OnChanges, SimpleChanges,
  DoCheck, AfterContentInit
} from '@angular/core'; //宣告來源

@Component({
  selector: 'app-server-el',
  templateUrl: './server-el.component.html',
  styleUrls: ['./server-el.component.css'],
  encapsulation: ViewEncapsulation.None  //關閉封裝功能
})
export class ServerElComponent implements OnInit, OnChanges, DoCheck, AfterContentInit {
  @Input('srcElement') element: { type: string, name: string, content: string };
  @Input() name: String; //為了能被 Angular 偵測到變化，多一個 input 做前後改變

  constructor() {
    console.log('0th is constructor');
  }

  ngOnChanges(changes: SimpleChanges) {
    console.log('1st is ngOnChange');
    console.log(changes);
  }

  ngOnInit() {
    console.log('2nd is ngOnInit');
  }

  ngDoCheck() {
    console.log('3rd is ngDoCheck');
  }

  ngAfterContentInit() {
    console.log('4th is ngAfterContentInit');
  }
}
```

接著嘗試以下動作
- 按下 btn-danger 10 次，沒再次執行因為內容投影未改變。
- 填值（輸入 No.2 *) 並按下 Add Server 來增加第二組 Server，因為內容投影有更改故對第二組 server 內容進行初始化。

現在來討論顏色範圍的時機為
- 第一次紫色 - 那是 Test Server 的系列過程，最後停留在 4th 也就是該內容被初始化
- 第一次綠色 - 同前一次觀念 btn-danger 在第一下觸發到 ngOnChange（`@Input`有新變化），之後每下 click 僅剩更改檢查
- 第二次紫色 - 那是 No.2 Server 的產生過程
- 第二次綠色 - 這來開發模式下的更改檢測動作。

![](https://i.imgur.com/2dtNwUO.png)

### ngAfterViewInit() & ngAfterViewChecked()
ngAfterViewInit 將所需要的 View 畫面產生出來後執行，並透過 ngAfterViewChecked 已確保所有的更改結果都在這個 View 裡面後執行。

```ts server-el.component.ts
import {
  Component, Input, ViewEncapsulation,
  OnInit, OnChanges, SimpleChanges, DoCheck,
  AfterContentInit, AfterContentChecked,
  AfterViewInit, AfterViewChecked
} from '@angular/core'; //宣告來源

@Component({
  selector: 'app-server-el',
  templateUrl: './server-el.component.html',
  styleUrls: ['./server-el.component.css'],
  encapsulation: ViewEncapsulation.None  //關閉封裝功能
})
export class ServerElComponent implements OnInit, OnChanges, DoCheck,
  AfterContentInit, AfterContentChecked,
  AfterViewInit, AfterViewChecked {
  @Input('srcElement') element: { type: string, name: string, content: string };
  @Input() name: String; //為了能被 Angular 偵測到變化，多一個 input 做前後改變

  constructor() {
    console.log('0th is constructor');
  }

  ngOnChanges(changes: SimpleChanges) {
    console.log('1st is ngOnChange');
    console.log(changes);
  }

  ngOnInit() {
    console.log('2nd is ngOnInit');
  }

  ngDoCheck() {
    console.log('3rd is ngDoCheck');
  }

  ngAfterContentInit() {
    console.log('4th is ngAfterContentInit');
  }
  ngAfterContentChecked() {
    console.log('5th is ngAfterContentChecked');
  }

  ngAfterViewInit() {
    console.log('6th is ngAfterViewInit');
  }
  ngAfterViewChecked() {
    console.log('7th is ngAfterViewChecked');
  }
}
```

### ngAfterViewChecked()
元件被銷毀時觸發，除了宣告 OnDestroy 工具使用外，我們額外做一個 click 事件綁定銷毀第一組 server 的元件。

```ts server-el.component.ts
import {
  Component, Input, ViewEncapsulation,
  OnInit, OnChanges, SimpleChanges, DoCheck,
  AfterContentInit, AfterContentChecked,
  AfterViewInit, AfterViewChecked, OnDestroy
} from '@angular/core'; //宣告來源

@Component({
  selector: 'app-server-el',
  templateUrl: './server-el.component.html',
  styleUrls: ['./server-el.component.css'],
  encapsulation: ViewEncapsulation.None  //關閉封裝功能
})
export class ServerElComponent implements OnInit, OnChanges, DoCheck,
  AfterContentInit, AfterContentChecked,
  AfterViewInit, AfterViewChecked,
  OnDestroy {
  @Input('srcElement') element: { type: string, name: string, content: string };
  @Input() name: String;

  constructor() {
    console.log('0th is constructor');
  }

  ngOnChanges(changes: SimpleChanges) {
    console.log('1st is ngOnChange');
    console.log(changes);
  }

  ngOnInit() {
    console.log('2nd is ngOnInit');
  }

  ngDoCheck() {
    console.log('3rd is ngDoCheck');
  }

  ngAfterContentInit() {
    console.log('4th is ngAfterContentInit');
  }
  ngAfterContentChecked() {
    console.log('5th is ngAfterContentChecked');
  }

  ngAfterViewInit() {
    console.log('6th is ngAfterViewInit');
  }
  ngAfterViewChecked() {
    console.log('7th is ngAfterViewChecked');
  }
  ngOnDestroy() {
    console.log('8th is ngOnDestroy');
  }
}
```

來到 app 元件這裡規劃一個本地的事件綁定。並試著刪掉陣列中第一組 server-el 元件，陣列拔除的方式因為到時候 ngFor 執行時因為失去了陣列之中的這格也就會被 DOM 所刪除。

```ts app.component.ts
onKillOne() {
  this.serverElements.splice(0, 1);
}
```
```html app.component.html
<button class="btn btn-warning" (click)="onKillOne()">Kill 1st Element</button>
```

現在操作添加第二組 server-el 元件後，嘗試刪除第一組 server-el 元件。透過

![](https://i.imgur.com/HkqfbYX.png)

最後結論上，告知你會很少會使用到這些 Hook 工具，除非你需要這些 Hook 來幫助你做一些特定的代碼。

## ViewChild 的使用問題
前面聊過本地變數與範本訪問做法，從同一元件我們學過可以 TS 的`@VueChild`來訪問範本的本地變數來取得 DOM。但是如果我們的生命週期上使用有啥問題存在。

試著建立 viewChild 在 server-el 看看，讓範本的本地變數能被 TS 所使用。這裡本地變數為`#cardHeader`。

```html server-el.component.html
<div class="card-header" #cardHeader>{{ element.name }}</div>
```
```ts server-el.component.ts
import {
  Component, Input, ViewEncapsulation,
  OnInit, OnChanges, SimpleChanges, DoCheck,
  AfterContentInit, AfterContentChecked,
  AfterViewInit, AfterViewChecked, OnDestroy,
  ViewChild, ElementRef  //※　重點：宣告
} from '@angular/core'; 

@Component({
  selector: 'app-server-el',
  templateUrl: './server-el.component.html',
  styleUrls: ['./server-el.component.css'],
  encapsulation: ViewEncapsulation.None
})
export class ServerElComponent implements OnInit, OnChanges, DoCheck,
  AfterContentInit, AfterContentChecked,
  AfterViewInit, AfterViewChecked,
  OnDestroy {
  @Input('srcElement') element: { type: string, name: string, content: string };
  @Input() name: String;

  //※　重點：透過 ViewChild 來獲得範本內的本地變數成為本檔案的變數
  @ViewChild('cardHeader') cardHeader: ElementRef;　

  constructor() {
    console.log('0th is constructor');
  }

  ngOnChanges(changes: SimpleChanges) {
    console.log('1st is ngOnChange');
    console.log(changes);
  }

  ngOnInit() {
    console.log('2nd is ngOnInit');
    console.log('2nd: ' + this.cardHeader);
    //※　重點：undefined，因為 DOM 還沒生成怎會有本地變數
  }

  ngDoCheck() {
    console.log('3rd is ngDoCheck');
  }

  ngAfterContentInit() {
    console.log('4th is ngAfterContentInit');
  }
  ngAfterContentChecked() {
    console.log('5th is ngAfterContentChecked');
  }

  ngAfterViewInit() {
    console.log('6th is ngAfterViewInit');
    console.log('6td: ' + this.cardHeader);
    //※　重點：undefined，因為 View 生成了，才會有本地變數可獲得

  }
  ngAfterViewChecked() {
    console.log('7th is ngAfterViewChecked');
  }
  ngOnDestroy() {
    console.log('8th is ngOnDestroy');
  }
}
```

由此可知，生命週期的 View 生成時間，會影響到我們去取得本地變數的存在與否 (View 是否已出來了）。

## ContentChild 用於內容投影
之前學到 ViewChild 可以從 View 找到指定的元素。但如果是在 ng-content 內容投影就無法處理。因為內容投影的那段 html 被放置在父元件那裏根本不是 View 的一部分。這時侯需要改用 ContentChild 來作業。兩者的差異在於一個是在 View 上查找取得；一個是 Content（內容投影）上查找取得。

- 舉例我們來到使用內容投影的地方，位於 app 元件上，對其 Content 部分規劃別名。
- app 元件的內容會被投影到 server-el 這裡，因此在下層元件這裡我們需要宣告`@ContentChild()`來補貨，記得提供別名作為 selector 給該函式。
- 回到 element-el 的週期，他的出現時機在於 ContentInit 時才會產生（比 ViewInit 早）。
- 也參考 OnInit 是否可讀到此元素。

```html app.component.html
<app-server-el
  *ngFor="let item of serverElements"
  [srcElement]="item"
  [name]="item.name"
>
  <!-- 投影 start，事實上這裡應該還有 card>card-header+card-body -->
  <p #contentPpp>
    <strong
      *ngIf="item.type === 'server'"
      style="color: red"
    >{{ item.content }}</strong>
    <em *ngIf="item.type === 'blueprint'">{{ item.content }}</em>
  </p>
  <!-- 投影 end -->
</app-server-el>
```
```ts server-el.component.ts
import {
  Component, Input, ViewEncapsulation,
  OnInit, OnChanges, SimpleChanges, DoCheck,
  AfterContentInit, AfterContentChecked,
  AfterViewInit, AfterViewChecked, OnDestroy,
  ViewChild, ElementRef,
  ContentChild // ※重點：宣告
} from '@angular/core';

@Component({
  selector: 'app-server-el',
  templateUrl: './server-el.component.html',
  styleUrls: ['./server-el.component.css'],
  encapsulation: ViewEncapsulation.None  
})
export class ServerElComponent implements OnInit, OnChanges, DoCheck,
  AfterContentInit, AfterContentChecked,
  AfterViewInit, AfterViewChecked,
  OnDestroy {
  @Input('srcElement') element: { type: string, name: string, content: string };
  @Input() name: String;

  @ViewChild('cardHeader') cardHeader: ElementRef;　
  @ContentChild('contentPpp') contentByApp: ElementRef;　// ※重點

  constructor() {
    console.log('0th is constructor');
  }

  ngOnChanges(changes: SimpleChanges) {
    console.log('1st is ngOnChange');
    console.log(changes);
  }

  ngOnInit() {
    console.log('2nd is ngOnInit');
    console.error('2nd View: ' + this.cardHeader);
    console.warn('2nd Content: ' + this.contentByApp);// ※重點
  }

  ngDoCheck() {
    console.log('3rd is ngDoCheck');
  }

  ngAfterContentInit() {
    console.log('4th is ngAfterContentInit');
    console.warn('4th Content: ' + this.contentByApp);// ※重點
  }
  ngAfterContentChecked() {
    console.log('5th is ngAfterContentChecked');
  }

  ngAfterViewInit() {
    console.log('6th is ngAfterViewInit');
    console.error('6td View: ' + this.cardHeader);

  }
  ngAfterViewChecked() {
    console.log('7th is ngAfterViewChecked');
  }
  ngOnDestroy() {
    console.log('8th is ngOnDestroy');
  }
}
```

最後回到 console 這裡，你就能知道 ContentInit 在生命週期內的用途時機為何了，這裡為了顏色差異才做 error 與 warn 提示。

![](https://i.imgur.com/iPYMK3j.png)

# 小節練習 
以下根據本篇學到的東西做一個練習，動作要求如下：

1. 建立三個元件 GameControl, Odd, Even
2. GameControl 需要提供 Start 與 Pause 按鈕
3. 當開始遊戲時，GameControl 事件會一直記數（記錄這個值）並每秒`ref=setInterval()`累加
4. 這個事件產生的數字必須列表輸出到外面的元件上
5. 當暫停遊戲時，原本的事件會停止記數`clearInterval(ref)`
6. 新 Odd 元件要能捕獲到每個奇數值，Even 元件也是要捕獲到偶數值
7. 簡單的輸出文字規格為`ODD - *`與 `EVEN - *`在這兩個元件
8. 使用樣式表例如 p 為選擇器做不同的文字顯示在這兩個元件內

作法如下：

- 首先我們需要對 Game-ctl 進行設計規劃兩個按鈕並提供兩個事件綁定分別是 onGameStart 與 onGamePause
- 然後到 TS 這裡規劃這兩個方法，而在 Start 那裡規劃 setInterval 並獲得一個 key 方便之後做 clearInterval 把動作取消
- key 放置在 class 內作為屬性初始，雖然 JS 的 setInterval 所回傳的是一個 key，但 Node.js 這裡的回傳的型別是`<Timer>`我們無法給予初始值因此給予 any 型別
- 由於要透過外層元件也就是上層的 app 負責輸出，這裡用自訂事件來儲存 count 數字（不是用 type number 來做，因為我們要`@Output`一個事件綁定給外層）
- 規劃 count 的強行別為 new EventEmitter() 並提供回傳的強型別會是 number。然後我們還要用一個 number 型別的變數拿來做疊加的紀錄值好更新我們自訂事件的回傳值
- 來到 onGameStart() 這裡，使用 setInterval 於每秒使用 emit 來更新這個自訂事件的回傳值
- 目前為止只需要輸出到外層元件去，因此我們需要透過@Output 把我們的 count 送出去，記得 count 是一個自訂事件
- 來到外層元件app這裡，設定一個自訂事件綁定，來呼喊app元件下的方法負責輸出工作，先用console來測試Start與Pause是否成功

```html game-ctl.component.html
<button (click)="onGameStart()">Start</button>
<button (click)="onGamePause()">Pause</button>
```
```ts game-ctl.component.ts
import { Component, OnInit, EventEmitter, Output } from '@angular/core';

@Component({
  selector: 'app-game-ctl',
  templateUrl: './game-ctl.component.html',
  styleUrls: ['./game-ctl.component.css']
})
export class GameCtlComponent implements OnInit {
  @Output() count = new EventEmitter<number>();
  lastNum = 0;
  intervalKey: any;

  constructor() { }

  ngOnInit(): void {
  }

  onGameStart() {
    this.intervalKey = setInterval(() => {
      this.count.emit(this.lastNum + 1);
      this.lastNum++;
    }, 1000);

  }
  onGamePause() {
    clearInterval(this.intervalKey);
  }

}
```
```html app.component.html
<app-game-ctl (count)="onGetCount($event)"></app-game-ctl>
```
```ts app.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {

  onGetCount(arg: number) {
    console.log(arg);
  }
}
```

接下來根據要求，需要把值送到Odd與Event元件內由它們來負責輸出到畫面上。

- odd與even元件代表的是一個p段落就好。由app來控制重複使用even與odd元件，先嘗試各別都只有完成一個元素，因為要接受來是外部元件所以要用到`@Input`
- 來到Odd與Even，來創造一個可訪問的`@input`屬性，同時這個屬性變數會提供給範本html使用，透過字串差值來輸出畫面。
- 來到app元件這裡，我們會跑回圈重複使用下層元件Odd與Even，既然是迴圈就必須要把數字存成陣列。且還要把數字弄成屬性綁定要提供給下層各元件使用。
- 最後是強型別的問題，注意app那裏的數字陣列如何宣告，以及Odd與Even的屬性強行別，因為不想弄初始值會報錯，所以用斷言符號強迫一定是數字。
- 目前跑起來，兩邊底層元件都會跑12345有成功透過`@input`將資料傳送進去。

```html odd.component.html
<p>ODD - {{number}}</p>
```
```html even.component.html
<p>EVEN - {{number}}</p>
```
```ts odd.component.ts
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-odd',
  templateUrl: './odd.component.html',
  styleUrls: ['./odd.component.css']
})
export class OddComponent {
  @Input() number!: number;
}
```
```ts even.component.ts
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-even',
  templateUrl: './even.component.html',
  styleUrls: ['./even.component.css']
})
export class EvenComponent {
  @Input() number!: number;
}
```
```html app.component.html
<app-game-ctl (count)="onGetCount($event)"></app-game-ctl>
<app-even
  *ngFor="let item of args"
  [number]="item"
></app-even>
<app-odd
  *ngFor="let item of args"
  [number]="item"
></app-odd>
```
```ts app.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  args: number[] = [];
  onGetCount(arg: number) {
    this.args.push(arg);
  }
}
```

最後想辦法多個判斷式弄成兩個陣列給不同下層元件，利用餘數是否為0判斷奇偶數。

```html app.component.html
<app-game-ctl (count)="onGetCount($event)"></app-game-ctl>
<app-even
  *ngFor="let item of argsEven"
  [number]="item"
></app-even>
<app-odd
  *ngFor="let item of argsOdd"
  [number]="item"
></app-odd>
```
```ts app.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  argsOdd: number[] = [];
  argsEven: number[] = [];
  onGetCount(arg: number) {
    if (arg % 2 === 0) this.argsEven.push(arg);
    else this.argsOdd.push(arg);
  }
}
```

以及最後一小段要求，在這兩個小元件規劃P字色就好。

```css odd.component.css
p {
  color: blue;
}
```
```css even.component.css
p {
  color: green;
}
```

最後美中不足的是，如果click連續同一按會跑多次interval動作。所以多一個判斷是否給予按鈕禁用屬性。

```html game-ctl.component.html
<button (click)="onGameStart()" [disabled]="bool">Start</button>
<button (click)="onGamePause()" [disabled]="!bool">Pause</button>
```
```ts game-ctl.component.ts
export class GameCtlComponent {
  @Output() count = new EventEmitter<number>();
  lastNum = 0;
  intervalKey: any;

  bool: boolean = false;

  onGameStart() {
    this.bool = !this.bool;
    this.intervalKey = setInterval(() => {
      this.count.emit(this.lastNum + 1);
      this.lastNum++;
    }, 1000);

  }
  onGamePause() {
    this.bool = !this.bool;
    clearInterval(this.intervalKey);
  }
}
```

完成如下

{% iframe https://stackblitz.com/edit/angular-ivy-muvwvn 100% 500 %}

# 參考文獻
- [Udemy Angular - The Complete Guide (2022 Edition)](https://www.udemy.com/course/the-complete-guide-to-angular-2/) SESSION 5