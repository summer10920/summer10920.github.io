---
title: '[學習之路] JS 前端框架 Angular - 元件和數據綁定'
categories:
  - Zero Road
  - Web Fronted
tag:
  - Untagged
date: 2022-04-15 14:15:57
---

![](https://i.imgur.com/WC5iApN.png)
前面介紹了基本安裝與工作環境，並且理解基本的資料綁定與內建指令。這裡會介紹元件和資料綁定的深入探討細節。
<!-- more -->

# 前置準備
本篇的起始素材放置於 GitHub 底下提供使用，使用資料目錄 lokiSecond 作為初始環境。下載請記得 npm install 初始化環境。

>[Github download](https://github.com/summer10920/angularTraining) at lokiSecond Folder

{% note info %}
  **小技巧：關於 Bootstrap In Angular**
  因為有使用 Bootstrap5 美化，如專案需要可自行安裝`npm install bootstrap`，並對 angular.json 的`styles:[]`多添加
  
```json angular.json
  "styles": [
    "node_modules/bootstrap/dist/css/bootstrap.min.css",
    "src/styles.css"
  ],
```
就能在 Angular 內使用 Bootstrap，載入 CSS 的位置還有其他方式可參考 [3+ Ways to Add Bootstrap 4 to Angular 10/9 With Example & Tutorial | Techiediaries](https://www.techiediaries.com/angular-bootstrap/) 說明教學。
{% endnote%}

素材的內容為提供標題與內容輸入，且提供兩個按鈕進行不同的 Card 列表並有些差異效果。大致上都是根據之前學過的語法來完成這些工作。現在都是同一份元件來進行作業。也許是讓文件更清爽好懂，分開元件使得工作更局部完整。

# 拆解 Component
根元件 app 應該保持簡潔，盡可能將代碼塞入其他子元件利用勘套的方式來完成。也能將小元件被重複使用。分開想法為將上列的輸入操作規劃為 cockpit 元件，下列的 card list 結果規劃為 server-element 元件。

透過 CLI 指令快速建立元件，完成後能在 app 目錄下多兩個元件目錄。

```shell
ng g c cockpit
ng g c server-el
```

接著將 app 元件內整理一下，跟隨以下步驟處理：

- 將 app-root 內的 hr 上半部`div.row`剪貼到 cockpit html 內。並替換成元件名稱。
```html app.component.html
<div class="container">
  <app-cockpit></app-cockpit>
  <hr>
  <!-- ... -->
</div>
```
```html cockpit.component.html
<div class="row">
  <div class="col-xs-12">
    <p>Add new Servers or blueprints!</p>
    <label>Server Name</label>
    <input
      type="text"
      class="form-control"
      [(ngModel)]="newServerName"
    >
    <label>Server Content</label>
    <input
      type="text"
      class="form-control"
      [(ngModel)]="newServerContent"
    >
    <br>
    <button
      class="btn btn-primary"
      (click)="onAddServer()"
    >Add Server</button>
    <button
      class="btn btn-primary"
      (click)="onAddBlueprint()"
    >Add Server Blueprint</button>
  </div>
</div>
```
- 利用 IDE 編輯器的報錯，cockpit 有使用到兩個屬性與兩個方法。一樣搬移到自己的 ts 內。
```ts cockpit.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-cockpit',
  templateUrl: './cockpit.component.html',
  styleUrls: ['./cockpit.component.css']
})
export class CockpitComponent {
  newServerName = '';
  newServerContent = '';

  onAddServer() {
    this.serverElements.push({
      type: 'server',
      name: this.newServerName,
      content: this.newServerContent
    });
  }

  onAddBlueprint() {
    this.serverElements.push({
      type: 'blueprint',
      name: this.newServerName,
      content: this.newServerContent
    });
  }
}
```
- 現在又報錯 serverElements 屬性缺少，我們先擱著，因為這個屬性另一個 server-el 也要用到。
- 原本需要將 app-root 內的 hr 下半部`div.row`剪貼到 server-el html 內，但因為有迴圈我們應該讓 server-el 為單筆 card 資訊，讓 app-root 能重複使用我們的小元件。因此剪貼範圍縮到 card 本身，並替換成元件名稱且執行 ngFor。
```html app.component.html
<div class="container">
  <app-cockpit></app-cockpit>
  <hr>
  <div class="row">
    <div class="col-xs-12">
      <app-server-el *ngFor="let element of serverElements"></app-server-el>
    </div>
  </div>
</div>
```
```html server-el.component.html
<div class="card mb-3">
  <div class="card-header">{{ element.name }}</div>
  <div class="card-body">
    <p>
      <strong
        *ngIf="element.type === 'server'"
        style="color: red"
      >{{ element.content }}</strong>
      <em *ngIf="element.type === 'blueprint'">{{ element.content }}</em>
    </p>
  </div>
</div>
```
- 現在這個 server-el 的 ts 也報錯，因為 element 屬性來自於 ngFor 批次出來的變數，但 ngFor 跑到上層元件去也是找不到。

最後，目前來說隨著分解元件導致有些通信斷掉。我們需要讓元件之間能傳遞資訊十分重要，接下來討論如何修好它。大致上的方向為 app 與 element-el 如何執行屬性綁定（讀取資料），以及 app 與 cockpit 如何執行事件綁定（寫入資料）。而資料會在 app 元件上等待兩個下層元件進行寫取。

# 元件之間的屬性與事件綁定
稍微盤點一下 Property & Event Binding 有在各話題上的綁定用途

- HTML Elements
透過元素的原生屬性來做一些事件，也就一開始學的基礎東西。像是控制 disable 屬性要不要執行、將事件綁定給屬性如 click 事件做些資料發送，甚至使用$event 獲得輸入值。全都是對元素進行屬性上的事件綁定。
- Directives
使用指令做些事情，像是 ngClass 與 ngStyle 這些，也使用屬性綁定來實現它。
- Component
對於元件的操作綁定用途，我們將歸入自訂的屬性與事件。優先示範使用屬性綁定來處理我們的元件屬性，下一個是事件綁定。

## 公開 server-el 屬性綁定並傳入
處理 server-el 問題之前，我們先將另一個 cockpit 元件內的方法註解掉，先專心處理 server-el 元件的問題。
```ts cockpit.component.ts
onAddServer() {
  // this.serverElements.push({
  //   type: 'server',
  //   name: this.newServerName,
  //   content: this.newServerContent
  // });
}

onAddBlueprint() {
  // this.serverElements.push({
  //   type: 'blueprint',
  //   name: this.newServerName,
  //   content: this.newServerContent
  // });
}
```
正式來到 server-el 這邊處理著手問題，我們知道元件缺少了 element 屬性，試著補上並提供強型別（目前並沒有提供值給這個屬性，只單純提供型別）。
```ts server-el.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-server-el',
  templateUrl: './server-el.component.html',
  styleUrls: ['./server-el.component.css']
})
export class ServerElComponent {
  element: { type: string, name: string, content: string };
}
```
回到上層的 app 元件這裡，這裡產生一些靜態假資料，屆時要提供給下層 server-el。
```ts app.component.ts
export class AppComponent {
  serverElements = [
    { type: 'server', name: 'TestName', content: 'TestString!' }
  ];
}
```
目前為止在 app html 的上面能成功跑迴圈產生一筆 card，app 能讀到 app 自己的陣列，但是資料內容 element 我們該如何送進去給下層的 server-el 元件。這是正要討論的問題。如果能類似 disable 那樣透過屬性綁定將 element 資料傳送給我們的下層 server-el 元件，原則上是可行的。為了區別開來 ngFor 的變數名稱換一下。

```html app.component.html
<div class="container">
  <app-cockpit></app-cockpit>
  <hr>
  <div class="row">
    <div class="col-xs-12">
      <app-server-el
        *ngFor="let item of serverElements"
        [element]="item"
      ></app-server-el>
    </div>
  </div>
</div>
```
但事實上會失敗，透過 console 錯誤資訊告知你，屬性 property 本身未定義。這是因為 app 元件本身沒有 element 這個屬性可用。既使下層的 server-el 元件有這個屬性，上層也認不出來。這是在公開權限上的問題，使得上層元件無法知道這個下層元件持有這個屬性而未知存在進行報錯。如果你想讓上層元件能知道下層元件有這個屬性，讓上層元件能綁定該屬性提供給下層，你需要對下層該屬性添加一些動作。

找到下層這個屬性位置，前綴添加`@Input()`，讓 Angular 知道下層的 element 屬性會從其他地方傳過來。現在能成功地從上層 app 將 element 傳遞給下層 server-el，因為下層有寫這個 element 來自於`@Input`。

```ts server-el.component.ts
import { Component, Input } from '@angular/core'; //注意這裡要添加來源處

@Component({
  selector: 'app-server-el',
  templateUrl: './server-el.component.html',
  styleUrls: ['./server-el.component.css']
})
export class ServerElComponent {
  @Input() element: { type: string, name: string, content: string };
}
```

現在透過這個可以成功將元素屬性傳遞給每個下層元件去，並綁定給該元件的元素屬性。這就是下層屬性公開了自己的 element 屬性提供進行輸入。

### 使用不同屬性名稱
你可以使用別名方式讓外部元件以其他名字來傳遞給下層元件，下層元件再換成自己的屬性名稱。透過`@input('別名')`達到。這能幫助你在綁定屬性的命名上避免衝突到，這裡我們別名改成 srcElement 來試試。

```html app.component.html
<app-server-el
  *ngFor="let item of serverElements"
  [srcElement]="item"
></app-server-el>
```
```ts server-el.component.ts
export class ServerElComponent {
  @Input('srcElement') element: { type: string, name: string, content: string };
}
```

## 公開 cockpit 的事件綁定並傳出
接下來處理事件綁定的部分，同樣的我們要思考下層如何將它的資料傳遞出來給上層讓上層可以接受到。我們先處理上層元件，應該是讓上層元件接受一些資訊對自己的 serverElements 陣列進行寫入。相同的我們需要兩個 Method 來做寫入屬性動作。參考後來搬移給 cockpit 的 method 寫法。這裡名稱另外取名為 Done 是因為動作在 cockpit 已執行完畢，app 元件只是負責將它寫入到陣列內。

app 的 Method 會獲得兩個東西，分別是 name 與 content（來自 cockpit 的兩個 input)。因此假定我們透過參數拿到這樣的 object，並注意提供強型別。

```ts app.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  serverElements = [
    { type: 'server', name: 'TestName', content: 'TestString!' }
  ];

  onAddServerDone(serverData: { sName: string, sContent: string }) {
    this.serverElements.push({
      type: 'server',
      name: serverData.sName,
      content: serverData.sContent
    });
  }

  onAddBlueprintDone(serverData: { sName: string, sContent: string }) {
    this.serverElements.push({
      type: 'blueprint',
      name: serverData.sName,
      content: serverData.sContent
    });
  }
}
```

現在只要有誰執行了 app 的 method 就必須要提供參數才能寫入到 app 的屬性資料內。因此與 cockpit 關聯的地方在於 app html 上，我們需要綁定一個事件並提供$event 作為參數讓 app 的 method 能取得資料的 name 與 content。我們先命名創造出兩個 cockpit 根本不存在的名稱作為事件綁定，並能對 app 的 Method 傳遞資料參數，之後還要到 cockpit 裡面創造自定義的事件綁定。

```html app.component.html
<app-cockpit
  (serverCreated)="onAddServerDone($event)"
  (blueprintCreated)="onAddBlueprintDone($event)"
></app-cockpit>
```

來到 cockpit 這裡，元件內先創造兩個不存在的屬性。這兩個屬性是透過 new EventEmitter() 物件來建立，並額外告知強型別為我們指定的 object。

```ts cockpit.component.ts
import { Component, EventEmitter } from '@angular/core'; //宣告 EventEmitter 來源

@Component({
  selector: 'app-cockpit',
  templateUrl: './cockpit.component.html',
  styleUrls: ['./cockpit.component.css']
})
export class CockpitComponent {
  newServerName = '';
  newServerContent = '';
  serverCreated = new EventEmitter<{ sName: string, sContent: string }>();
  blueprintCreated = new EventEmitter<{ sName: string, sContent: string }>();

  onAddServer() {
    // this.serverElements.push({
    //   type: 'server',
    //   name: this.newServerName,
    //   content: this.newServerContent
    // });
  }

  onAddBlueprint() {
    // this.serverElements.push({
    //   type: 'blueprint',
    //   name: this.newServerName,
    //   content: this.newServerContent
    // });
  }
}
```

>EventEmitter 為事件發射器，作為自訂事件觸發與監聽。我們會用到 emit() 來操作要發出去的值。詳情請參閱 [Angular API](https://angular.tw/api/core/EventEmitter)

現在 cockpit 裡面已經準備好兩組自訂事件之屬性，該是考慮讓 cockpit 內的兩個 method 動作下能對該兩個自訂事件塞值進去。我們得透過 emit 來塞值。現在 method 已經大改了，我們替換如下

```ts cockpit.component.ts
export class CockpitComponent {
  newServerName = '';
  newServerContent = '';
  serverCreated = new EventEmitter<{ sName: string, sContent: string }>();
  blueprintCreated = new EventEmitter<{ sName: string, sContent: string }>();

  onAddServer() {
    this.serverCreated.emit({
      sName: this.newServerName,
      sContent: this.newServerContent
    });
  }

  onAddBlueprint() {
    this.blueprintCreated.emit({
      sName: this.newServerName,
      sContent: this.newServerContent
    });
  }
}
```

照理來說，目前的邏輯都很正常也沒有錯誤訊息依然無法提供給上層元件。跟前面的觀念一樣，`@input()`能讓屬性可以從外部進行屬性綁定。而這裡為`@Output`為讓我們的 cockpit 能接受到來自外面的監聽。

```ts cockpit.component.ts
import { Component, EventEmitter, Output } from '@angular/core'; //宣告 Output 來源

@Component({
  selector: 'app-cockpit',
  templateUrl: './cockpit.component.html',
  styleUrls: ['./cockpit.component.css']
})
export class CockpitComponent {
  newServerName = '';
  newServerContent = '';
  @Output() serverCreated = new EventEmitter<{ sName: string, sContent: string }>();
  @Output() blueprintCreated = new EventEmitter<{ sName: string, sContent: string }>();

  onAddServer() {
    this.serverCreated.emit({
      sName: this.newServerName,
      sContent: this.newServerContent
    });
  }

  onAddBlueprint() {
    this.blueprintCreated.emit({
      sName: this.newServerName,
      sContent: this.newServerContent
    });
  }
}
```

恭喜目前可以運作了，其實也就是屬性綁定與事件綁定話題。原本基礎觀念是對同元件下的 html 元素來進行作業，現在擴大到元件之間的通信。而元件之間的通信除了原本的屬性綁定與事件綁定，還要多考量 Input 與 Output，這是因為元件之間彼此獨立互不影響，透過這兩個函式才能外部綁定到內部屬性，或者是從內部接收來自外部的事件監聽。

### 使用不同屬性名稱
跟 Input 一樣，你可以使用別名來做兩者之間通信的名稱。也保護內部屬性的原名稱不曝光。

```html app.component.html
<app-cockpit
  (sLoki)="onAddServerDone($event)"
  (bLoki)="onAddBlueprintDone($event)"
></app-cockpit>
```
```ts cockpit.component.ts
@Output('sLoki') serverCreated = new EventEmitter<{ sName: string, sContent: string }>();
@Output('bLoki') blueprintCreated = new EventEmitter<{ sName: string, sContent: string }>();
```

## 總結
透過這些自訂屬性綁定與事件綁定，你可以讓上下層的父子元件之間進行通信，但如果是同層的兄弟元件就會比較複雜些，就要利用父元件當跳板傳遞給這些子元件並大量使用到 Input 與 Output，但這不是很實用的一件作法，之後有另外一種 servers 的做法可以讓兄弟元素之間進行通信。

# 元件之間的 View 封裝
你是否過程中發現，分解之前會有藍色字樣的輸出，經過分解與通信修復後，這個藍色的 CSS 效果消失了。這個 p 元素的 style 被設定在 app 的 css 內。其不像過去我們 CSS 觀念上所繼承給下層元件。事實上這是 Angular 的強制行為而不是瀏覽器對 CSS 的默認繼承行為。透過網頁 F12 檢查可以很清楚發現 Angular 會自作主張的對每個元件下的元素添加一些有的沒的。現在試著將這個藍色的效果搬移到 server-el 元件內的 css 看看。

```css server-el.component.css
p {
  color: blue;
}
```

現在再去檢查並嘗試輸入一下欄位送出，會發現藍色字樣跑出來了。透過 F12 檢查可以發現 angular 對 p 元素添加了隨機的屬性名稱，而 css 的選擇器也自動添加這個屬性名稱。這都是 Angular 搞得鬼，這是一個保護機制，意味了我們每個元件都有自己封裝的 View 範圍彼此不受影響而被保護。如果你不想要這樣的保護，你可以編譯到 index.html 那層的 styles.css，那裏才是對整個網頁所影響的樣式表，元件內的樣式表只對該元件有效，這是 Angular 默認行為。

## 取消元件封裝
如果這個元件不想要封裝，也就是不要產生類似影子 DOM，將所有元件下的元素都不要添加相同亂碼的元素屬性某參數。可以找到該元件的@Component 添加 ViewEncapsulation 並指定參數 None 調整 (Emulated 模擬為預設值可以不用寫）。

```ts server-el.component.ts
import { Component, Input, ViewEncapsulation } from '@angular/core'; //宣告來源

@Component({
  selector: 'app-server-el',
  templateUrl: './server-el.component.html',
  styleUrls: ['./server-el.component.css'],
  encapsulation: ViewEncapsulation.None  //關閉封裝功能
})
export class ServerElComponent {
  @Input('srcElement') element: { type: string, name: string, content: string };
}
```

現在回頭看一下 F12 發現已經沒有奇怪字串值屬性出現在這個元件內的元素上，同時該元件的 css 部分也不會去添加奇怪字串值屬性。因此現在這個元件下的 css 將會影響整個網頁。舉例

```css server-el.component.css
label{
  color:red;
  font-size: 2rem;
}
```

現在這個效果因為沒有封裝而導致影響到另一個 cockpit 元件內的label元素之樣式了。

## 樣板內使用本地引用
