---
title: '[學習之路] JS 前端框架 React - 高級'
categories:
  - Zero Road
  - ReactJS
tag:
  - ReactJS
  - JavaScript
date: 2021-11-23 13:24:56
---

![](https://i.imgur.com/iWnyS9n.png)
本篇開始深入探討一些 React 細節或不常用的認知學習單元，根據參考官方手冊逐步學習。同時會略過一些對於未來性將捨棄的原有功能。

<!-- more -->

# 代碼分割
React 本身透過 import 來載入必要的模組，而自己設計的組件也能學樣的規劃成外部組件庫透過 import 載入。export 可以將函式、物件甚至是純值匯出。而 import 與 export 本身來自 JavaScript 的模組管理方法。

**named export**
指定具名方式可以多個同時 export，而 import 時需要相同名稱才能使用。

```js src/App.js
import React from 'react';

function WelcomeF() {
  return <h1>Hello!!</h1>;
}

class WelcomeC extends React.Component {
  render() { //表達此 class 組件要呈現的內容
    return <h1>Hello!!</h1>;
  }
}

export { WelcomeF, WelcomeC };
```
```js src/index.js
import { render } from 'react-dom';
import { WelcomeC, WelcomeF } from "./App";

render(<WelcomeF />, document.querySelector('#demo1'));
render(<WelcomeC />, document.querySelector('#demo2'));
```

**default export**
預設輸出就只能輸出一組，視為這個檔案內的唯一輸出。但輸入時可以用任何其他名稱來承接。

```js src/App.js
import React from 'react';

function WelcomeF() {
  return <h1>Hello!!</h1>;
}

export default WelcomeF;
```
```js src/index.js
import { render } from 'react-dom';
import Demo from "./App";

render(<Demo />, document.querySelector('#demo1'));
```

或者包裝成物件方式來使用。

```js src/App.js
import React from 'react';

function WelcomeF() {
  return <h1>Hello!!</h1>;
}

class WelcomeC extends React.Component {
  render() { //表達此 class 組件要呈現的內容
    return <h1>Hello!!</h1>;
  }
}

export default { WelcomeF, WelcomeC };
```
```js src/index.js
import { render } from 'react-dom';
import Demo from "./App";

render(<Demo.WelcomeC />, document.querySelector('#demo1'));
render(<Demo.WelcomeF />, document.querySelector('#demo2'));
```

## 動態 import()
隨代碼的開發量變大，載入等待時間會影響網頁執行效能。可以考慮使用動態載入（非同步作業）透過 import() 函式，使程式碼讀取到此部分會自動額外進行載入。此功能為 Webpack(Create React App) 或其他 Next.js 框架提供之功能函式。

```js src/App.js
import React from 'react';

function WelcomeF() {
  return <h1>Hello!!</h1>;
}

class WelcomeC extends React.Component {
  render() { //表達此 class 組件要呈現的內容
    return <h1>Hello!!</h1>;
  }
}

export { WelcomeF, WelcomeC };
```
```js src/index.js
import { render } from 'react-dom';

//這段代碼可以在任何地方使用，不用一開始做 import。
import("./App").then(obj => {
  console.log(obj); //因為非同步，時間上此晚出現
  render(<obj.WelcomeC />, document.querySelector('#demo1'));
  render(<obj.WelcomeF />, document.querySelector('#demo2'));
}).catch(err => {
  // Handle failure
  console.log(err);
});
console.log('first command'); //會先出現
```
> 如果使用 default export 方式，獲得多一層為 default 的 object，使用上就變成為`obj.default.WelcomeC`。

## 優化載入 React Suspense & React Lazy
在開發專案的時候透過 webpack 將不同模組的 component 打包成同一支 js，但規模越大載入時間也會拉長影響使用者體驗，而且並非所有的程式碼的功能會在一開始就使用。透過 React lazy 可以將程式碼拆分成不同的區塊延遲進行動態 import ，優先載入比較重要的 js。並搭配 suspense 包覆 component 讓 React 知道這部分內容需要等 Lazy 載入回來才能顯示，suspense 能使用多個 Lazy 組件。

> 此來自 16.6 才開始有的功能，但無法在 SSR(server-side) 使用 (React 承諾將在未來版本上解決）。如果有 SSR 開發上使用需求則需要透過別人的 [Loadable Components](https://github.com/gregberge/loadable-components) 來解決。

### React.lazy()
此函式能協助我們從外部組件進行動態匯入，由於只能獲得一個組件結果因此只能對 default export 組件檔案存取。而參數必須是一個非同步連結（具備 Promise 回應）的 import() 函式結果。

```js
const SomeComponent = React.lazy(() => import('./SomeComponent'));
```
接著就是搭配 Suspense 提供做為渲染使用。

### React.Suspense
本身是一個預留用的組件標籤，提供屬性 fallback 能在未動態取回時呈現預設等待之內容。而下層內容為可指定 JSX 與 lazy。

```js
import React, { Suspense } from 'react';

const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  );
}
```

lazy 可以多個於同一個 Suspense 內。

```js
import React, { Suspense } from 'react';

const OtherComponent = React.lazy(() => import('./OtherComponent'));
const AnotherComponent = React.lazy(() => import('./AnotherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <section>
          <OtherComponent />
          <AnotherComponent />
        </section>
      </Suspense>
    </div>
  );
}
```

### 抽取來自 named export
由於 lazy() 只能對應一個組件，如果你的組件來自於 named export 其中一項將無法取得。只能透過一個中繼方式從中獲取指定一項輸出成 default export，再由 lazy 取回。

```js  ManyComponents.js
export const ComponentA = /* ... */;
export const ComponentB = /* ... */;
```

```js  MyComponentB.js
export { ComponentB as default } from "./ManyComponents.js";
```
```js  MyApp.js
import React, { lazy } from 'react';
const MyComponentB = lazy(() => import("./MyComponentB.js"));
```

# Context
用於解決多層組件由上至下傳遞 props 的繁瑣問題。而 Context 可在不使用 props 情況下完成，先創建 Context 全域組件變數後，能在起始點組件上塞入值，並在目的端取出值。適合用在一些下層多數組件都需要的變數。

舉例來說，下列組合組件的結構為 APP（提供參數）>Toolbar>ThemeButton>Button（使用參數），勢必需要透過 prop 來一個個傳遞下去。

```js
import {render} from 'react-dom';

function App() {
  return <Toolbar theme="yellow" />;
}

function Toolbar(props) {
  return (
    <div>
      <ThemedButton theme={props.theme} />
    </div>
  );
}

function ThemedButton(props) {
  return <Button theme={props.theme} />;
}

function Button(props) {
  return (
    <button style={{ backgroundColor: props.theme }}>DEMO</button>
  );
}

render(
  <App />, document.getElementById('demo')
);
```

## class 的 Context
Context 不支援 function 來使用（但可使用 Hook)，使用方式如下：

1. 在全域上利用`React.createContext()`建立 Context 組件變數，參數可提供一開始之初始值。
2. 在需要使用此 Context 變數改寫值的地方，使用 Context.Provider 並指定屬性 value 進行內容值改變。React 自從被 createContext 時會去尋找最近的 Provider 讀取值。
3. 接著在想要傳遞的組件放置在該 Context 標籤內，React 會幫你把此值往指定組件傳送過去。
4. 中途組件不需特別設定。
5. 目標 class 組件要取此 Context 時，需要特別指定此 context 給該組件的 contextType。
```js
import { Component, createContext } from 'react';
import { render } from 'react-dom';

const MyContext = createContext('red'); //規劃 context 變數，初始賦予 red

function App() {
  return (
    <MyContext.Provider value='yellow'>  //要將新值提供給 context 時，需要用標籤包覆起來。
      <Toolbar />
    </MyContext.Provider>
  );
}

function Toolbar() {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}

class ThemedButton extends Component {
  render() {
    return <Button theme={this.context} />;
  }
}
// 因為不知道要使用的 context 為何，因此需要綁定 class 的 contextType 為哪個 Context 變數
ThemedButton.contextType = MyContext; 

function Button(props) {
  return (
    <button style={{ backgroundColor: props.theme }}>DEMO</button>
  );
}

render(
  <App />, document.getElementById('demo')
);
```
6. 或者專案環境支援 public class fields syntax 語法，與前步驟效果相同，可以改用 class 的 static 方式來設定 contextType。
```js
class ThemedButton extends Component {
  static contextType = MyContext;
  render() {
    console.log(this.context); // yellow
    return <Button theme={this.context} />;
  }
}
// ThemedButton.contextType = MyContext;
```
### API 相關說明

#### React.createContext
建立一個 Context 物件，當 React 進行渲染到此指令，會從這個組件關聯樹狀尋找與他對應的 Provider 之內容值。如果找不到 Provider 則會以原本的初始參數來生效。

```js
const MyContext = React.createContext(defaultValue);
```

#### Context.Provider
Context 物件會有一個 Provider 用的组件形式。Context 能被其他組件連接並修改 Context 的值，透過 Provider 組件屬性 value 來修改，並根據包覆的組件進行關聯樹狀傳遞此 Context。Provider 可以在不同的其他組件建立關聯樹狀。而一旦 value 產生變化 React 會去對關聯樹狀上的目標組件上重新渲染翻新此值。

```js
<MyContext.Provider value={/* 某个值 */}>
```

#### Class.contextType
目標 Class 組件想從 Context 上獲得值，則必須要指定 Class 的 contextType 指定為哪個 Context 物件。接著能在任何生命週期或 render 上使用 this.context 取得內容值。

```js
class MyClass extends React.Component {
  //...
  render() {
    let value = this.context;
  }
}
MyClass.contextType = MyContext;  //method 1
```

或者在支援 [public class fields](https://babeljs.io/docs/en/babel-plugin-proposal-class-properties) 環境，使用 static 類屬性來初始化這個 class 的 contextType。

```js
class MyClass extends React.Component {
  static contextType = MyContext;  //method 2
  render() {
    let value = this.context;
  }
}
```

#### Context.Consumer
與Context.Provider雷同都是修改context值，但屬於適用在 render props的方式下(之後介紹)，依賴。

```js
<MyContext.Consumer>
  {value => /* 基于 context 值进行渲染*/}
</MyContext.Consumer>
```

#### Context.displayName
對Context提供一個名稱使用文字串，在開發工具上可以看見此Context名字。

```js
const MyContext = React.createContext(/* some value */);
MyContext.displayName = 'LokiName';

<MyContext.Provider> // "LokiName.Provider" by DevTools
<MyContext.Consumer> // "LokiName.Consumer" by DevTools
```


## 不使用 Context 的替代方案
Context 主要是讓在不同層級下的多數組件能訪問相同的數據使用。但如果只是只針對一組使用來說整體的規畫準備就不太適合。假設與前面例子類似有以下組件需要傳遞。如果都使用 props 來接力傳遞就太笨拙，而 Context 只有 Link 進行存取就不適宜。

```js
<Page user={user} avatarSize={avatarSize} />
//
<PageLayout user={user} avatarSize={avatarSize} />
//
<NavigationBar user={user} avatarSize={avatarSize} />
//
<Link href={user.permalink}>
  <Avatar user={user} size={avatarSize} />
</Link>
```

我們可改用 Component 組合模型來規畫此功能。先將範例設計出來逐步修改，首先用到 props.childen 來解決 Link>Avatar 的組合模型。

```js
import { render } from 'react-dom';

function App() {
  const user = {
    permalink: "http://www.loki.com",
    img: "./loki.jpg"
  }, avatarSize = 100;
  return (
    <Page user={user} avatarSize={avatarSize} />
  );
}

function Page(props) {
  return (
    <PageLayout user={props.user} avatarSize={props.avatarSize} />
  );
}

function PageLayout(props) {
  return (
    <NavigationBar user={props.user} avatarSize={props.avatarSize} />
  );
}

function NavigationBar(props) {
  return (
    <Link href={props.user.permalink}>
      <Avatar user={props.user} size={props.avatarSize} />
    </Link>
  );
}

function Link(props) {
  return (
    <a href={props.href}>{props.children}</a>
  );
}

function Avatar(props) {
  return <img src={props.user.img} width={props.size} alt="description" />;
}

render(
  <App />, document.getElementById('demo')
);
```

接著將會用到這些資料的組件標籤提升到與資料來源相同的同層組件，將直接獲得這些數據的組件標籤當作內容傳遞下去。這樣的設計只有 App 組件是知道 Link 與 Avatar 是如何去使用 user 與 size 資料的，其他下層組件不用去幫忙傳遞這兩筆，但會幫忙傳遞整個組件下去。

```js
import { render } from 'react-dom';

function App() {
  const user = {
    permalink: "http://www.loki.com",
    img: "./loki.jpg"
  }, avatarSize = 100;

  const userLink = (
    <Link href={user.permalink}>
      <Avatar user={user} size={avatarSize} />
    </Link>
  );
  return (
    <Page userLink={userLink} />
  );
}

function Page(props) {
  return (
    <PageLayout userLink={props.userLink} />
  );
}

function PageLayout(props) {
  return (
    <NavigationBar userLink={props.userLink} />
  );
}

function NavigationBar(props) {
  return props.userLink;
}

function Link(props) {
  return (
    <a href={props.href}>{props.children}</a>
  );
}

function Avatar(props) {
  return <img src={props.user.img} width={props.size} alt="description" />;
}

render(
  <App />, document.getElementById('demo')
);
```

這樣的反轉寫法雖然還是 props 大隊接力，但能減少 props 的使用量並減少代碼。如果你想傳遞的不只一個組件，可以再多一組件變數做兩筆大隊接力傳遞。

```js
function Page(props) {
  const user = props.user;
  const content = <Feed user={user} />; //組件模型
  const topBar = (
    <NavigationBar>
      <Link href={user.permalink}>
        <Avatar user={user} size={props.avatarSize} />
      </Link>
    </NavigationBar>
  ); //組件模型
  return (
    <PageLayout
      topBar={topBar}
      content={content}
    />
  );//傳遞 2 個組件
}
```

# 友善化網頁
這部分集結一節討論，包含 WAI-ARIA 無障礙應用技術、HTML5 語意標籤、表單輔助、

## WAI-ARIA
即是一個能藉由添加進一步的語意幫助處理這種問題的技術 ，讓瀏覽器與輔助科技可以辨識及用以讓使用者知道發生甚麼事情。熟悉 Bootstrap 的人很常看到 aria-*的屬性標籤。JSX 編寫這些屬性不需要遵守駝峰命名直接寫入即可。

```js
<input
  type="text"
  aria-label={labelText}
  aria-required="true"
  onChange={onchangeHandler}
  value={inputValue}
  name="name"
/>
```

## 語意標籤
語意化為 HTML5 提倡的觀念，盡可能用適合的標籤名稱去結構網頁想表達的內容使瀏覽器或搜尋演算法充分理解。由於常常組件互相勘套時會破壞這標籤結構且組件的 render 必須要一組標籤，因此可以使用短語法`<>`（或稱空標籤且之前出現過）來當一組標籤避免多餘層級標籤。

```js
//短語法
function ListItem({ item }) {
  return (
    <>
      <dt>{item.term}</dt>
      <dd>{item.description}</dd>
    </>
  );
}
```

或者舊方式使用`<fragment></fragment>`分段標籤來替代，Fragment 需要從 react 宣告匯入。

```js
//Fragment
import { Fragment } from 'react';
function ListItem({ item }) {
  return (
    <Fragment>
      <dt>{item.term}</dt>
      <dd>{item.description}</dd>
    </Fragment>
  );
}
```

唯獨不同是 Fragment 可以添加一些 props 或是 key 使用。

```js
function Glossary(props) {
  return (
    <dl>
      {props.items.map(item => (
        // Fragments should also have a `key` prop when mapping collections
        <Fragment key={item.id}>
          <dt>{item.term}</dt>
          <dd>{item.description}</dd>
        </Fragment>
      ))}
    </dl>
  );
}
```

## HTML5 表單機制
HTML5 在表單上提供一些有用的機制，其中例如 label 標籤的設計，需搭配 for 屬性來指定對應表單元素。然而 for 為特別關鍵字，在 JSX 內必須改用 htmlFor 來表示。

```js
<label htmlFor="namedInput">Name:</label>
<input id="namedInput" type="text" name="name"/>
```

控制 focus 看不懂 略過，跟 ref 有關
https://zh-hans.reactjs.org/docs/accessibility.html#focus-control

滑鼠事件看不懂，同尚
